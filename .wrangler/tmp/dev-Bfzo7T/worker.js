var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isBrowser.js
function isBrowser() {
  return typeof window !== "undefined" && typeof window.scrollY === "number";
}
var init_isBrowser = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isBrowser.js"() {
    __name(isBrowser, "isBrowser");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/unique.js
function unique(arr) {
  return Array.from(new Set(arr));
}
var init_unique = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/unique.js"() {
    __name(unique, "unique");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getGlobalObject.js
function getGlobalObject(moduleId, defaultValue) {
  const globals = getGlobals();
  const globalObject24 = globals[moduleId] ?? (globals[moduleId] = defaultValue);
  return globalObject24;
}
function getGlobals() {
  var _a2;
  globalThis._vike ?? (globalThis._vike = {});
  (_a2 = globalThis._vike).globals ?? (_a2.globals = {});
  return globalThis._vike.globals;
}
var init_getGlobalObject = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getGlobalObject.js"() {
    __name(getGlobalObject, "getGlobalObject");
    __name(getGlobals, "getGlobals");
  }
});

// node_modules/.pnpm/@brillout+picocolors@1.0.28/node_modules/@brillout/picocolors/dist/esm/picocolors.js
function isBrowser2() {
  return Object.getOwnPropertyDescriptor(globalThis, "window")?.get?.toString().includes("[native code]") ?? false;
}
function stripAnsi(string) {
  return string.replace(ansiRegex, "");
}
function getAnsiRegex() {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(pattern, "g");
}
var p, argv, env, isColorSupported, formatter, replaceClose, createColors, pc, picocolors_default, ansiRegex;
var init_picocolors = __esm({
  "node_modules/.pnpm/@brillout+picocolors@1.0.28/node_modules/@brillout/picocolors/dist/esm/picocolors.js"() {
    if (isBrowser2())
      throw new Error("This file should never be included in the browser.");
    p = typeof process === "undefined" ? {} : process;
    argv = p.argv || [];
    env = p.env || {};
    isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
    formatter = /* @__PURE__ */ __name((open, close, replace = open) => (input) => {
      let string = "" + input;
      let index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    }, "formatter");
    replaceClose = /* @__PURE__ */ __name((string, close, replace, index) => {
      let start = string.substring(0, index) + replace;
      let end = string.substring(index + close.length);
      let nextIndex = end.indexOf(close);
      return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
    }, "replaceClose");
    createColors = /* @__PURE__ */ __name((enabled = isColorSupported) => {
      const cyan = formatter("\x1B[36m", "\x1B[39m");
      return {
        isColorSupported: enabled,
        code: enabled ? cyan : (s) => `\`${s}\``,
        string: enabled ? cyan : (s) => `'${s}'`,
        reset: enabled ? (s) => `\x1B[0m${s}\x1B[0m` : String,
        bold: enabled ? formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
        dim: enabled ? formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
        italic: enabled ? formatter("\x1B[3m", "\x1B[23m") : String,
        underline: enabled ? formatter("\x1B[4m", "\x1B[24m") : String,
        inverse: enabled ? formatter("\x1B[7m", "\x1B[27m") : String,
        hidden: enabled ? formatter("\x1B[8m", "\x1B[28m") : String,
        strikethrough: enabled ? formatter("\x1B[9m", "\x1B[29m") : String,
        black: enabled ? formatter("\x1B[30m", "\x1B[39m") : String,
        red: enabled ? formatter("\x1B[31m", "\x1B[39m") : String,
        green: enabled ? formatter("\x1B[32m", "\x1B[39m") : String,
        yellow: enabled ? formatter("\x1B[33m", "\x1B[39m") : String,
        blue: enabled ? formatter("\x1B[34m", "\x1B[39m") : String,
        magenta: enabled ? formatter("\x1B[35m", "\x1B[39m") : String,
        cyan: enabled ? cyan : String,
        white: enabled ? formatter("\x1B[37m", "\x1B[39m") : String,
        gray: enabled ? formatter("\x1B[90m", "\x1B[39m") : String,
        bgBlack: enabled ? formatter("\x1B[40m", "\x1B[49m") : String,
        bgRed: enabled ? formatter("\x1B[41m", "\x1B[49m") : String,
        bgGreen: enabled ? formatter("\x1B[42m", "\x1B[49m") : String,
        bgYellow: enabled ? formatter("\x1B[43m", "\x1B[49m") : String,
        bgBlue: enabled ? formatter("\x1B[44m", "\x1B[49m") : String,
        bgMagenta: enabled ? formatter("\x1B[45m", "\x1B[49m") : String,
        bgCyan: enabled ? formatter("\x1B[46m", "\x1B[49m") : String,
        bgWhite: enabled ? formatter("\x1B[47m", "\x1B[49m") : String,
        rm: stripAnsi
      };
    }, "createColors");
    pc = createColors();
    picocolors_default = pc;
    __name(isBrowser2, "isBrowser");
    __name(stripAnsi, "stripAnsi");
    ansiRegex = getAnsiRegex();
    __name(getAnsiRegex, "getAnsiRegex");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/PROJECT_VERSION.js
var PROJECT_VERSION;
var init_PROJECT_VERSION = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/PROJECT_VERSION.js"() {
    PROJECT_VERSION = "0.4.238";
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertSingleInstance.js
function genGlobalConfig() {
  return getGlobalObject("utils/assertSingleInstance.ts", {
    instances: [],
    alreadyLogged: /* @__PURE__ */ new Set()
  });
}
function getGlobalObjectSafe() {
  globalObject ?? (globalObject = genGlobalConfig());
  return globalObject;
}
function assertSingleInstance() {
  const globalObject24 = getGlobalObjectSafe();
  {
    const versions2 = unique(globalObject24.instances);
    assertWarning(
      versions2.length <= 1,
      // Do *NOT* patch Vike to remove this warning: you *will* eventually encounter the issues listed at https://vike.dev/warning/version-mismatch
      // - This happened before: https://github.com/vikejs/vike/issues/1108#issuecomment-1719061509
      `vike@${picocolors_default.bold(versions2[0])} and vike@${picocolors_default.bold(versions2[1])} loaded which is highly discouraged, see ${picocolors_default.underline("https://vike.dev/warning/version-mismatch")}`,
      { onlyOnce: true, showStackTrace: false }
    );
  }
  if (globalObject24.checkSingleInstance && globalObject24.instances.length > 1) {
    assertWarning(false, clientNotSingleInstance, { onlyOnce: true, showStackTrace: true });
  }
}
function assertSingleInstance_onAssertModuleLoad() {
  const globalObject24 = getGlobalObjectSafe();
  globalObject24.instances.push(PROJECT_VERSION);
  assertSingleInstance();
}
function assertWarning(condition, errorMessage2, { onlyOnce, showStackTrace }) {
  const globalObject24 = getGlobalObjectSafe();
  if (condition) {
    return;
  }
  const msg = `[Vike][Warning] ${errorMessage2}`;
  if (onlyOnce) {
    const { alreadyLogged: alreadyLogged2 } = globalObject24;
    const key = onlyOnce === true ? msg : onlyOnce;
    if (alreadyLogged2.has(key)) {
      return;
    } else {
      alreadyLogged2.add(key);
    }
  }
  if (showStackTrace) {
    console.warn(new Error(msg));
  } else {
    console.warn(msg);
  }
}
var globalObject, clientNotSingleInstance;
var init_assertSingleInstance = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertSingleInstance.js"() {
    init_unique();
    init_getGlobalObject();
    init_picocolors();
    init_PROJECT_VERSION();
    globalObject ?? (globalObject = genGlobalConfig());
    __name(genGlobalConfig, "genGlobalConfig");
    __name(getGlobalObjectSafe, "getGlobalObjectSafe");
    clientNotSingleInstance = "Client runtime loaded twice https://vike.dev/client-runtime-duplicated";
    __name(assertSingleInstance, "assertSingleInstance");
    __name(assertSingleInstance_onAssertModuleLoad, "assertSingleInstance_onAssertModuleLoad");
    __name(assertWarning, "assertWarning");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isNodeJS.js
function isNodeJS() {
  if (typeof process === "undefined")
    return false;
  if (!process.cwd)
    return false;
  if (!process.versions || typeof process.versions.node === "undefined")
    return false;
  if (!process.release || process.release.name !== "node")
    return false;
  return true;
}
var init_isNodeJS = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isNodeJS.js"() {
    __name(isNodeJS, "isNodeJS");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/createErrorWithCleanStackTrace.js
function createErrorWithCleanStackTrace(errorMessage2, numberOfStackTraceLinesToRemove5) {
  const err = new Error(errorMessage2);
  if (isNodeJS()) {
    err.stack = clean(err.stack, numberOfStackTraceLinesToRemove5);
  }
  return err;
}
function clean(errStack, numberOfStackTraceLinesToRemove5) {
  if (!errStack) {
    return errStack;
  }
  const stackLines = splitByLine(errStack);
  let linesRemoved = 0;
  const stackLine__cleaned = stackLines.filter((line) => {
    if (line.includes(" (internal/") || line.includes(" (node:internal")) {
      return false;
    }
    if (linesRemoved < numberOfStackTraceLinesToRemove5 && isStackTraceLine(line)) {
      linesRemoved++;
      return false;
    }
    return true;
  }).join("\n");
  return stackLine__cleaned;
}
function isStackTraceLine(line) {
  return line.startsWith("    at ");
}
function splitByLine(str) {
  return str.split(/\r?\n/);
}
var init_createErrorWithCleanStackTrace = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/createErrorWithCleanStackTrace.js"() {
    init_isNodeJS();
    __name(createErrorWithCleanStackTrace, "createErrorWithCleanStackTrace");
    __name(clean, "clean");
    __name(isStackTraceLine, "isStackTraceLine");
    __name(splitByLine, "splitByLine");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isObject.js
function isObject(value) {
  return typeof value === "object" && value !== null;
}
var init_isObject = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isObject.js"() {
    __name(isObject, "isObject");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assert.js
function assert(condition, debugInfo) {
  if (condition)
    return;
  const debugStr = (() => {
    if (!debugInfo) {
      return null;
    }
    const debugInfoSerialized = typeof debugInfo === "string" ? debugInfo : JSON.stringify(debugInfo);
    return picocolors_default.dim(`Debug info for Vike maintainers (you can ignore this): ${debugInfoSerialized}`);
  })();
  const link = picocolors_default.underline("https://github.com/vikejs/vike/issues/new?template=bug.yml");
  let errMsg = [
    `You stumbled upon a Vike bug. Go to ${link} and copy-paste this error. A maintainer will fix the bug (usually within 24 hours).`,
    debugStr
  ].filter(Boolean).join(" ");
  errMsg = addWhitespace(errMsg);
  errMsg = addPrefixAssertType(errMsg, bugTag);
  errMsg = addPrefixProjectName(errMsg, true);
  const internalError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);
  globalObject2.onBeforeLog?.();
  throw internalError;
}
function assertUsage(condition, errMsg, { showStackTrace, exitOnError } = {}) {
  if (condition)
    return;
  showStackTrace = showStackTrace || globalObject2.alwaysShowStackTrace;
  errMsg = addWhitespace(errMsg);
  errMsg = addPrefixAssertType(errMsg, "Wrong Usage");
  errMsg = addPrefixProjectName(errMsg);
  const usageError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);
  if (showStackTrace) {
    globalObject2.showStackTraceList.add(usageError);
  }
  globalObject2.onBeforeLog?.();
  if (!exitOnError) {
    throw usageError;
  } else {
    console.error(showStackTrace ? usageError : errMsg);
    process.exit(1);
  }
}
function getProjectError(errMsg) {
  errMsg = addWhitespace(errMsg);
  errMsg = addPrefixAssertType(errMsg, "Error");
  errMsg = addPrefixProjectName(errMsg);
  const projectError = createErrorWithCleanStackTrace(errMsg, numberOfStackTraceLinesToRemove);
  return projectError;
}
function assertWarning2(condition, msg, { onlyOnce, showStackTrace }) {
  if (condition)
    return;
  showStackTrace = showStackTrace || globalObject2.alwaysShowStackTrace;
  msg = addWhitespace(msg);
  msg = addPrefixAssertType(msg, "Warning");
  msg = addPrefixProjectName(msg);
  if (onlyOnce) {
    const { alreadyLogged: alreadyLogged2 } = globalObject2;
    const key = onlyOnce === true ? msg : onlyOnce;
    if (alreadyLogged2.has(key))
      return;
    alreadyLogged2.add(key);
  }
  globalObject2.onBeforeLog?.();
  if (showStackTrace) {
    const err = createErrorWithCleanStackTrace(msg, numberOfStackTraceLinesToRemove);
    globalObject2.showStackTraceList.add(err);
    globalObject2.logger(err, "warn");
  } else {
    globalObject2.logger(msg, "warn");
  }
}
function assertInfo(condition, msg, { onlyOnce }) {
  if (condition) {
    return;
  }
  msg = addWhitespace(msg);
  msg = addPrefixProjectName(msg);
  if (onlyOnce) {
    const { alreadyLogged: alreadyLogged2 } = globalObject2;
    const key = msg;
    if (alreadyLogged2.has(key)) {
      return;
    } else {
      alreadyLogged2.add(key);
    }
  }
  globalObject2.onBeforeLog?.();
  globalObject2.logger(msg, "info");
}
function addPrefixAssertType(msg, tag) {
  let prefix3 = `[${tag}]`;
  const color = tag === "Warning" ? "yellow" : "red";
  prefix3 = picocolors_default.bold(picocolors_default[color](prefix3));
  return `${prefix3}${msg}`;
}
function addWhitespace(msg) {
  if (msg.startsWith("[")) {
    return msg;
  } else {
    return ` ${msg}`;
  }
}
function addPrefixProjectName(msg, showProjectVersion = false) {
  const prefix3 = showProjectVersion ? projectTagWithVersion : projectTag;
  return `${prefix3}${msg}`;
}
function isBug(err) {
  return String(err).includes(`[${bugTag}]`);
}
function setAlwaysShowStackTrace() {
  globalObject2.alwaysShowStackTrace = true;
}
var globalObject2, projectTag, projectTagWithVersion, bugTag, numberOfStackTraceLinesToRemove;
var init_assert = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assert.js"() {
    init_assertSingleInstance();
    init_createErrorWithCleanStackTrace();
    init_getGlobalObject();
    init_isObject();
    init_PROJECT_VERSION();
    init_picocolors();
    globalObject2 = getGlobalObject("utils/assert.ts", {
      alreadyLogged: /* @__PURE__ */ new Set(),
      // Production logger. Overwritten by loggerNotProd.ts in non-production environments.
      logger(msg, logType) {
        if (logType === "info") {
          console.log(msg);
        } else {
          console.warn(msg);
        }
      },
      showStackTraceList: /* @__PURE__ */ new WeakSet()
    });
    assertSingleInstance_onAssertModuleLoad();
    projectTag = `[vike]`;
    projectTagWithVersion = `[vike@${PROJECT_VERSION}]`;
    bugTag = "Bug";
    numberOfStackTraceLinesToRemove = 2;
    __name(assert, "assert");
    __name(assertUsage, "assertUsage");
    __name(getProjectError, "getProjectError");
    __name(assertWarning2, "assertWarning");
    __name(assertInfo, "assertInfo");
    __name(addPrefixAssertType, "addPrefixAssertType");
    __name(addWhitespace, "addWhitespace");
    __name(addPrefixProjectName, "addPrefixProjectName");
    __name(isBug, "isBug");
    __name(setAlwaysShowStackTrace, "setAlwaysShowStackTrace");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/slice.js
function slice(thing, from2, to2) {
  if (typeof thing === "string") {
    return sliceArray(thing.split(""), from2, to2).join("");
  } else {
    return sliceArray(thing, from2, to2);
  }
}
function sliceArray(list, from2, to2) {
  const listSlice = [];
  let start = from2 >= 0 ? from2 : list.length + from2;
  assert(start >= 0 && start <= list.length);
  let end = to2 >= 0 ? to2 : list.length + to2;
  assert(end >= 0 && end <= list.length);
  while (true) {
    if (start === end) {
      break;
    }
    if (start === list.length) {
      start = 0;
    }
    if (start === end) {
      break;
    }
    const el = list[start];
    assert(el !== void 0);
    listSlice.push(el);
    start++;
  }
  return listSlice;
}
var init_slice = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/slice.js"() {
    init_assert();
    __name(slice, "slice");
    __name(sliceArray, "sliceArray");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/parseUrl.js
function parseUrl(url, baseServer2) {
  assert(isUrl(url), url);
  assert(baseServer2.startsWith("/"));
  const { hashString: hashOriginal, withoutHash: urlWithoutHash } = extractHash(url);
  assert(hashOriginal === null || hashOriginal.startsWith("#"));
  const hash = hashOriginal === null ? "" : decodeSafe(hashOriginal.slice(1));
  const { searchString: searchOriginal, withoutSearch: urlWithoutHashNorSearch } = extractSearch(urlWithoutHash);
  assert(searchOriginal === null || searchOriginal.startsWith("?"));
  let searchString = "";
  if (searchOriginal !== null) {
    searchString = searchOriginal;
  } else if (url.startsWith("#")) {
    const baseURI = getBaseURI();
    searchString = baseURI && extractSearch(baseURI).searchString || "";
  }
  const search = {};
  const searchAll = {};
  Array.from(new URLSearchParams(searchString)).forEach(([key, val]) => {
    search[key] = val;
    searchAll[key] = [...searchAll.hasOwnProperty(key) ? searchAll[key] : [], val];
  });
  let { protocol, origin, pathnameAbsoluteWithBase } = getPathnameAbsoluteWithBase(urlWithoutHashNorSearch, baseServer2);
  const pathnameOriginal = urlWithoutHashNorSearch.slice((origin || "").length);
  assertUrlComponents(url, origin, pathnameOriginal, searchOriginal, hashOriginal);
  let { pathname, isBaseMissing } = removeBaseServer(pathnameAbsoluteWithBase, baseServer2);
  const href = createUrlFromComponents(origin, pathname, searchOriginal, hashOriginal);
  const host = !origin ? null : origin.slice(protocol.length);
  const { hostname, port } = parseHost(host, url);
  pathname = decodePathname(pathname);
  assert(pathname.startsWith("/"));
  return {
    href,
    protocol,
    hostname,
    port,
    origin,
    pathname,
    pathnameOriginal,
    isBaseMissing,
    search,
    searchAll,
    searchOriginal,
    hash,
    hashOriginal
  };
}
function extractHash(url) {
  const [withoutHash, ...parts] = url.split("#");
  const hashString = ["", ...parts].join("#") || null;
  return { hashString, withoutHash };
}
function extractSearch(url) {
  const [withoutSearch, ...parts] = url.split("?");
  const searchString = ["", ...parts].join("?") || null;
  return { searchString, withoutSearch };
}
function decodeSafe(urlComponent) {
  try {
    return decodeURIComponent(urlComponent);
  } catch {
  }
  try {
    return decodeURI(urlComponent);
  } catch {
  }
  return urlComponent;
}
function decodePathname(urlPathname) {
  urlPathname = urlPathname.replace(/\s+$/, "");
  urlPathname = urlPathname.split("/").map((dir) => decodeSafe(dir).split("/").join("%2F")).join("/");
  return urlPathname;
}
function getPathnameAbsoluteWithBase(url, baseServer2) {
  assert(!url.includes("?") && !url.includes("#"));
  {
    const { protocol, origin, pathname } = parseOrigin(url);
    if (origin) {
      return { protocol, origin, pathnameAbsoluteWithBase: pathname };
    }
    assert(pathname === url);
  }
  if (url.startsWith("/")) {
    return { protocol: null, origin: null, pathnameAbsoluteWithBase: url };
  } else {
    const baseURI = getBaseURI();
    let base;
    if (baseURI) {
      base = parseOrigin(baseURI.split("?")[0].split("#")[0]).pathname;
    } else {
      base = baseServer2;
    }
    const pathnameAbsoluteWithBase = resolveUrlPathnameRelative(url, base);
    return { protocol: null, origin: null, pathnameAbsoluteWithBase };
  }
}
function getBaseURI() {
  const baseURI = typeof window !== "undefined" ? window?.document?.baseURI : void 0;
  return baseURI;
}
function parseOrigin(url) {
  if (!isUrlWithProtocol(url)) {
    return { pathname: url, origin: null, protocol: null };
  } else {
    const { protocol, uriWithoutProtocol } = parseProtocol(url);
    assert(protocol);
    const [host, ...rest] = uriWithoutProtocol.split("/");
    const origin = protocol + host;
    const pathname = "/" + rest.join("/");
    return { pathname, origin, protocol };
  }
}
function parseHost(host, url) {
  const ret = { hostname: null, port: null };
  if (!host)
    return ret;
  const parts = host.split(":");
  if (parts.length > 1) {
    const port = parseInt(parts.pop(), 10);
    assert(port || port === 0, url);
    ret.port = port;
  }
  ret.hostname = parts.join(":");
  return ret;
}
function parseProtocol(uri) {
  const SEP = ":";
  const [before, ...after] = uri.split(SEP);
  if (after.length === 0 || // https://github.com/vikejs/vike/commit/886a99ff21e86a8ca699a25cee7edc184aa058e4#r143308934
  // https://en.wikipedia.org/wiki/List_of_URI_schemes
  // https://www.rfc-editor.org/rfc/rfc7595
  !/^[a-z][a-z0-9\+\-]*$/i.test(before)) {
    return { protocol: null, uriWithoutProtocol: uri };
  }
  let protocol = before + SEP;
  let uriWithoutProtocol = after.join(SEP);
  const SEP2 = "//";
  if (uriWithoutProtocol.startsWith(SEP2)) {
    protocol = protocol + SEP2;
    uriWithoutProtocol = uriWithoutProtocol.slice(SEP2.length);
  }
  return { protocol, uriWithoutProtocol };
}
function isUrlProtocol(protocol) {
  const blocklist = [
    // https://docs.ipfs.tech/how-to/address-ipfs-on-web
    "ipfs://",
    "ipns://"
  ];
  if (blocklist.includes(protocol))
    return false;
  return protocol.endsWith("://");
}
function resolveUrlPathnameRelative(pathnameRelative, base) {
  const stack = base.split("/");
  const parts = pathnameRelative.split("/");
  let baseRestoreTrailingSlash = base.endsWith("/");
  if (pathnameRelative.startsWith(".")) {
    stack.pop();
  }
  for (const i in parts) {
    const p2 = parts[i];
    if (p2 == "" && i === "0")
      continue;
    if (p2 == ".")
      continue;
    if (p2 == "..")
      stack.pop();
    else {
      baseRestoreTrailingSlash = false;
      stack.push(p2);
    }
  }
  let pathnameAbsolute = stack.join("/");
  if (baseRestoreTrailingSlash && !pathnameAbsolute.endsWith("/"))
    pathnameAbsolute += "/";
  if (!pathnameAbsolute.startsWith("/"))
    pathnameAbsolute = "/" + pathnameAbsolute;
  return pathnameAbsolute;
}
function removeBaseServer(pathnameAbsoluteWithBase, baseServer2) {
  assert(pathnameAbsoluteWithBase.startsWith("/"));
  assert(isBaseServer(baseServer2));
  let urlPathname = pathnameAbsoluteWithBase;
  assert(urlPathname.startsWith("/"));
  assert(baseServer2.startsWith("/"));
  if (baseServer2 === "/") {
    const pathname = pathnameAbsoluteWithBase;
    return { pathname, isBaseMissing: false };
  }
  let baseServerNormalized = baseServer2;
  if (baseServer2.endsWith("/") && urlPathname === slice(baseServer2, 0, -1)) {
    baseServerNormalized = slice(baseServer2, 0, -1);
    assert(urlPathname === baseServerNormalized);
  }
  if (!urlPathname.startsWith(baseServerNormalized)) {
    const pathname = pathnameAbsoluteWithBase;
    return { pathname, isBaseMissing: true };
  }
  assert(urlPathname.startsWith("/") || urlPathname.startsWith("http"));
  assert(urlPathname.startsWith(baseServerNormalized));
  urlPathname = urlPathname.slice(baseServerNormalized.length);
  if (!urlPathname.startsWith("/"))
    urlPathname = "/" + urlPathname;
  assert(urlPathname.startsWith("/"));
  return { pathname: urlPathname, isBaseMissing: false };
}
function isBaseServer(baseServer2) {
  return baseServer2.startsWith("/");
}
function assertUrlComponents(url, origin, pathnameOriginal, searchOriginal, hashOriginal) {
  const urlRecreated = createUrlFromComponents(origin, pathnameOriginal, searchOriginal, hashOriginal);
  assert(url === urlRecreated);
}
function createUrlFromComponents(origin, pathname, search, hash) {
  const urlRecreated = `${origin || ""}${pathname}${search || ""}${hash || ""}`;
  return urlRecreated;
}
function isUrl(url) {
  return isUrlWithProtocol(url) || url.startsWith("/") || isUrlRelative(url);
}
function isUrlRedirectTarget(url) {
  return url.startsWith("/") || isUri(url) || isUrlWithProtocol(url);
}
function isUrlRelative(url) {
  return [".", "?", "#"].some((c) => url.startsWith(c)) || url === "";
}
function isUrlWithProtocol(url) {
  const { protocol } = parseProtocol(url);
  return !!protocol && isUrlProtocol(protocol);
}
function isUri(uri) {
  const { protocol } = parseProtocol(uri);
  return !!protocol && !isUrlProtocol(uri);
}
function assertUsageUrlPathnameAbsolute(url, errPrefix) {
  assertUsageUrl(url, errPrefix);
}
function assertUsageUrlRedirectTarget(url, errPrefix, isUnresolved) {
  assertUsageUrl(url, errPrefix, { isRedirectTarget: isUnresolved ? "unresolved" : true });
}
function assertUsageUrl(url, errPrefix, { isRedirectTarget } = {}) {
  if (url.startsWith("/"))
    return;
  let errMsg = `${errPrefix} is ${picocolors_default.string(url)} but it should start with ${picocolors_default.string("/")}`;
  if (isRedirectTarget) {
    if (isUrlRedirectTarget(url))
      return;
    errMsg += ` or a protocol (${picocolors_default.string("http://")}, ${picocolors_default.string("mailto:")}, ...)`;
    if (isRedirectTarget === "unresolved") {
      if (url === "*")
        return;
      errMsg += `, or be ${picocolors_default.string("*")}`;
    }
  }
  assertUsage(false, errMsg);
}
var init_parseUrl = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/parseUrl.js"() {
    init_slice();
    init_assert();
    init_picocolors();
    __name(parseUrl, "parseUrl");
    __name(extractHash, "extractHash");
    __name(extractSearch, "extractSearch");
    __name(decodeSafe, "decodeSafe");
    __name(decodePathname, "decodePathname");
    __name(getPathnameAbsoluteWithBase, "getPathnameAbsoluteWithBase");
    __name(getBaseURI, "getBaseURI");
    __name(parseOrigin, "parseOrigin");
    __name(parseHost, "parseHost");
    __name(parseProtocol, "parseProtocol");
    __name(isUrlProtocol, "isUrlProtocol");
    __name(resolveUrlPathnameRelative, "resolveUrlPathnameRelative");
    __name(removeBaseServer, "removeBaseServer");
    __name(isBaseServer, "isBaseServer");
    __name(assertUrlComponents, "assertUrlComponents");
    __name(createUrlFromComponents, "createUrlFromComponents");
    __name(isUrl, "isUrl");
    __name(isUrlRedirectTarget, "isUrlRedirectTarget");
    __name(isUrlRelative, "isUrlRelative");
    __name(isUrlWithProtocol, "isUrlWithProtocol");
    __name(isUri, "isUri");
    __name(assertUsageUrlPathnameAbsolute, "assertUsageUrlPathnameAbsolute");
    __name(assertUsageUrlRedirectTarget, "assertUsageUrlRedirectTarget");
    __name(assertUsageUrl, "assertUsageUrl");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectAssign.js
function objectAssign(obj, objAddendum, objAddendumCanBeOriginalObject) {
  if (!objAddendum)
    return;
  if (!objAddendumCanBeOriginalObject)
    assert(!objAddendum._isOriginalObject);
  Object.defineProperties(obj, Object.getOwnPropertyDescriptors(objAddendum));
}
var init_objectAssign = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectAssign.js"() {
    init_assert();
    __name(objectAssign, "objectAssign");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectReplace.js
function objectReplace(objOld, objNew, except) {
  Object.keys(objOld).filter((key) => !except?.includes(key)).forEach((key) => delete objOld[key]);
  Object.defineProperties(objOld, Object.getOwnPropertyDescriptors(objNew));
}
var init_objectReplace = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectReplace.js"() {
    __name(objectReplace, "objectReplace");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isCallable.js
function isCallable(thing) {
  return thing instanceof Function || typeof thing === "function";
}
var init_isCallable = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isCallable.js"() {
    __name(isCallable, "isCallable");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/sorter.js
function higherFirst(getValue) {
  return (element1, element2) => {
    const val1 = getValue(element1);
    const val2 = getValue(element2);
    if (val1 === val2) {
      return 0;
    }
    return val1 > val2 ? -1 : 1;
  };
}
function lowerFirst(getValue) {
  return (element1, element2) => {
    const val1 = getValue(element1);
    const val2 = getValue(element2);
    if (val1 === val2) {
      return 0;
    }
    return val1 < val2 ? -1 : 1;
  };
}
function makeFirst(getValue) {
  return (element1, element2) => {
    const val1 = getValue(element1);
    const val2 = getValue(element2);
    assert([true, false, null].includes(val1));
    assert([true, false, null].includes(val2));
    if (val1 === val2) {
      return 0;
    }
    if (val1 === true || val2 === false) {
      return -1;
    }
    if (val2 === true || val1 === false) {
      return 1;
    }
    assert(false);
  };
}
function makeLast(getValue) {
  return makeFirst((element) => {
    const val = getValue(element);
    if (val === null) {
      return null;
    } else {
      return !val;
    }
  });
}
var init_sorter = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/sorter.js"() {
    init_assert();
    __name(higherFirst, "higherFirst");
    __name(lowerFirst, "lowerFirst");
    __name(makeFirst, "makeFirst");
    __name(makeLast, "makeLast");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isArray.js
function isArray(value) {
  return Array.isArray(value);
}
var init_isArray = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isArray.js"() {
    __name(isArray, "isArray");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isArrayOfStrings.js
function isArrayOfStrings(val) {
  return isArray(val) && val.every((v) => typeof v === "string");
}
var init_isArrayOfStrings = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isArrayOfStrings.js"() {
    init_isArray();
    __name(isArrayOfStrings, "isArrayOfStrings");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isObjectOfStrings.js
function isObjectOfStrings(val) {
  return isObject(val) && Object.values(val).every((v) => typeof v === "string");
}
var init_isObjectOfStrings = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isObjectOfStrings.js"() {
    init_isObject();
    __name(isObjectOfStrings, "isObjectOfStrings");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/hasProp.js
function hasProp(obj, prop, type2) {
  if (!isObject(obj))
    return false;
  if (!(prop in obj)) {
    return type2 === "undefined";
  }
  if (type2 === void 0) {
    return true;
  }
  const propValue = obj[prop];
  if (type2 === "undefined") {
    return propValue === void 0;
  }
  if (type2 === "array") {
    return isArray(propValue);
  }
  if (type2 === "object") {
    return isObject(propValue);
  }
  if (type2 === "string[]") {
    return isArrayOfStrings(propValue);
  }
  if (type2 === "string{}") {
    return isObjectOfStrings(propValue);
  }
  if (type2 === "function") {
    return isCallable(propValue);
  }
  if (isArray(type2)) {
    return typeof propValue === "string" && type2.includes(propValue);
  }
  if (type2 === "null") {
    return propValue === null;
  }
  if (type2 === "true") {
    return propValue === true;
  }
  if (type2 === "false") {
    return propValue === false;
  }
  return typeof propValue === type2;
}
var init_hasProp = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/hasProp.js"() {
    init_isCallable();
    init_isObject();
    init_isArrayOfStrings();
    init_isObjectOfStrings();
    init_isArray();
    __name(hasProp, "hasProp");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isPlainObject.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  return (
    /* Doesn't work in Cloudflare Pages workers
    value.constructor === Object
    */
    value.constructor.name === "Object"
  );
}
var init_isPlainObject = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isPlainObject.js"() {
    __name(isPlainObject, "isPlainObject");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/compareString.js
function compareString(str1, str2) {
  if (str1.toLowerCase() < str2.toLowerCase())
    return -1;
  if (str1.toLowerCase() > str2.toLowerCase())
    return 1;
  return 0;
}
var init_compareString = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/compareString.js"() {
    __name(compareString, "compareString");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isNullish.js
function isNullish(val) {
  return val === null || val === void 0;
}
function isNotNullish(p2) {
  return !isNullish(p2);
}
function isNotNullish_keyVal(arg) {
  return !isNullish(arg[1]);
}
var init_isNullish = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isNullish.js"() {
    __name(isNullish, "isNullish");
    __name(isNotNullish, "isNotNullish");
    __name(isNotNullish_keyVal, "isNotNullish_keyVal");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/stringifyStringArray.js
function stringifyStringArray(stringList) {
  return "[" + stringList.map((str) => "'" + str + "'").join(", ") + "]";
}
var init_stringifyStringArray = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/stringifyStringArray.js"() {
    __name(stringifyStringArray, "stringifyStringArray");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/cast.js
function cast(_thing) {
}
var init_cast = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/cast.js"() {
    __name(cast, "cast");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isPropertyGetter.js
function isPropertyGetter(obj, prop) {
  const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  return !!descriptor && !("value" in descriptor) && !!descriptor.get;
}
var init_isPropertyGetter = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isPropertyGetter.js"() {
    __name(isPropertyGetter, "isPropertyGetter");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isPromise.js
function isPromise(val) {
  return typeof val === "object" && val !== null && "then" in val && isCallable(val.then);
}
var init_isPromise = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isPromise.js"() {
    init_isCallable();
    __name(isPromise, "isPromise");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/checkType.js
function checkType(_) {
}
var init_checkType = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/checkType.js"() {
    __name(checkType, "checkType");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getValuePrintable.js
function getValuePrintable(value) {
  if ([null, void 0].includes(value))
    return String(value);
  if (["boolean", "number", "string"].includes(typeof value))
    return JSON.stringify(value);
  return null;
}
var init_getValuePrintable = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getValuePrintable.js"() {
    __name(getValuePrintable, "getValuePrintable");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/escapeRegex.js
function escapeRegex(str) {
  return str.replace(/[/\-\\^$*+?.()|[\]{}]/g, "\\$&");
}
var init_escapeRegex = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/escapeRegex.js"() {
    __name(escapeRegex, "escapeRegex");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/changeEnumerable.js
function changeEnumerable(obj, prop, enumerable) {
  const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  Object.defineProperty(obj, prop, { ...descriptor, enumerable });
}
var init_changeEnumerable = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/changeEnumerable.js"() {
    __name(changeEnumerable, "changeEnumerable");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectDefineProperty.js
function objectDefineProperty(obj, prop, { get, ...args }) {
  Object.defineProperty(obj, prop, { ...args, get });
}
var init_objectDefineProperty = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectDefineProperty.js"() {
    __name(objectDefineProperty, "objectDefineProperty");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isScriptFile.js
function isScriptFile(filePath) {
  return scriptFileExtensionList.some((ext) => filePath.endsWith("." + ext));
}
function isTemplateFile(filePath) {
  return extTemplates.some((ext) => filePath.endsWith("." + ext));
}
var extJs, extTs, extJsOrTs, extJsx, extTsx, extJsxOrTsx, extTemplates, scriptFileExtensionList, scriptFileExtensionPattern;
var init_isScriptFile = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isScriptFile.js"() {
    extJs = [
      "js",
      "cjs",
      "mjs"
    ];
    extTs = [
      "ts",
      "cts",
      "mts"
    ];
    extJsOrTs = [...extJs, ...extTs];
    extJsx = [
      "jsx",
      "cjsx",
      "mjsx"
    ];
    extTsx = [
      "tsx",
      "ctsx",
      "mtsx"
    ];
    extJsxOrTsx = [...extJsx, ...extTsx];
    extTemplates = [
      "vue",
      "svelte",
      "marko",
      "md",
      "mdx"
    ];
    scriptFileExtensionList = [...extJsOrTs, ...extJsxOrTsx, ...extTemplates];
    scriptFileExtensionPattern = "(" + scriptFileExtensionList.join("|") + ")";
    __name(isScriptFile, "isScriptFile");
    __name(isTemplateFile, "isTemplateFile");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectFilter.js
function objectFilter(obj, filter) {
  return Object.fromEntries(Object.entries(obj).filter(filter));
}
var init_objectFilter = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectFilter.js"() {
    __name(objectFilter, "objectFilter");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getPropAccessNotation.js
function getPropAccessNotation(key) {
  return typeof key === "string" && isKeyDotNotationCompatible(key) ? `.${key}` : `[${JSON.stringify(key)}]`;
}
function isKeyDotNotationCompatible(key) {
  return /^[a-z0-9\$_]+$/i.test(key);
}
var init_getPropAccessNotation = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getPropAccessNotation.js"() {
    __name(getPropAccessNotation, "getPropAccessNotation");
    __name(isKeyDotNotationCompatible, "isKeyDotNotationCompatible");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/genPromise.js
function genPromise({ timeout: timeoutSeconds = timeoutSecondsDefault } = {}) {
  let resolve;
  let reject;
  let finished = false;
  const promise_internal = new Promise((resolve_, reject_) => {
    resolve = /* @__PURE__ */ __name((...args) => {
      finished = true;
      timeoutClear();
      return resolve_(...args);
    }, "resolve");
    reject = /* @__PURE__ */ __name((...args) => {
      finished = true;
      timeoutClear();
      return reject_(...args);
    }, "reject");
  });
  const timeoutClear = /* @__PURE__ */ __name(() => timeouts.forEach((t) => clearTimeout(t)), "timeoutClear");
  const timeouts = [];
  let promise;
  if (!timeoutSeconds) {
    promise = promise_internal;
  } else {
    promise = new Proxy(promise_internal, {
      get(target, prop) {
        if (prop === "then" && !finished) {
          const err = new Error(`Promise hasn't resolved after ${timeoutSeconds} seconds`);
          timeouts.push(setTimeout(() => {
            assert(err.stack);
            assertWarning2(false, removeStackErrorPrefix(err.stack), { onlyOnce: false });
          }, timeoutSeconds * 1e3));
        }
        const value = Reflect.get(target, prop);
        return typeof value === "function" ? value.bind(target) : value;
      }
    });
  }
  return { promise, resolve, reject };
}
function removeStackErrorPrefix(errStack) {
  const errorPrefix3 = "Error: ";
  if (errStack.startsWith(errorPrefix3))
    errStack = errStack.slice(errorPrefix3.length);
  return errStack;
}
var timeoutSecondsDefault;
var init_genPromise = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/genPromise.js"() {
    init_assert();
    timeoutSecondsDefault = 25;
    __name(genPromise, "genPromise");
    __name(removeStackErrorPrefix, "removeStackErrorPrefix");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/utils.js
var init_utils = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/utils.js"() {
    init_assert();
    init_parseUrl();
    init_objectAssign();
    init_objectReplace();
    init_isCallable();
    init_isObject();
    init_unique();
    init_slice();
    init_sorter();
    init_isBrowser();
    init_hasProp();
    init_isPlainObject();
    init_compareString();
    init_isNullish();
    init_stringifyStringArray();
    init_cast();
    init_isPropertyGetter();
    init_isPromise();
    init_checkType();
    init_getValuePrintable();
    init_escapeRegex();
    init_isArray();
    init_changeEnumerable();
    init_objectDefineProperty();
    init_isScriptFile();
    init_objectFilter();
    init_getPropAccessNotation();
    init_getGlobalObject();
    init_genPromise();
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/error-page.js
function getErrorPageId(pageFilesAll, pageConfigs) {
  if (pageConfigs.length > 0) {
    const errorPageConfigs = pageConfigs.filter((p2) => p2.isErrorPage);
    if (errorPageConfigs.length === 0)
      return null;
    assertUsage(errorPageConfigs.length === 1, "Only one error page can be defined");
    return errorPageConfigs[0].pageId;
  }
  const errorPageIds = unique(pageFilesAll.map(({ pageId }) => pageId).filter((pageId) => isErrorPageId(pageId, false)));
  assertUsage(errorPageIds.length <= 1, `Only one _error.page.js is allowed, but found several: ${errorPageIds.join(" ")}`);
  if (errorPageIds.length > 0) {
    const errorPageId = errorPageIds[0];
    assert(errorPageId);
    return errorPageId;
  }
  return null;
}
function isErrorPageId(pageId, _isV1Design) {
  assert(!pageId.includes("\\"));
  return pageId.includes("/_error");
}
function isErrorPage(pageId, pageConfigs) {
  if (pageConfigs.length > 0) {
    const pageConfig = pageConfigs.find((p2) => p2.pageId === pageId);
    assert(pageConfig);
    return !!pageConfig.isErrorPage;
  } else {
    return isErrorPageId(pageId, false);
  }
}
var init_error_page = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/error-page.js"() {
    init_utils();
    __name(getErrorPageId, "getErrorPageId");
    __name(isErrorPageId, "isErrorPageId");
    __name(isErrorPage, "isErrorPage");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getTerminalWidth.js
function getTerminalWidth() {
  return typeof process !== "undefined" && typeof process.stdout !== "undefined" && process.stdout.columns || void 0;
}
var init_getTerminalWidth = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getTerminalWidth.js"() {
    __name(getTerminalWidth, "getTerminalWidth");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/debug.js
function debug(...args) {
  if (!globalObject3.createDebugger)
    return;
  if (!globalObject3.debug) {
    globalObject3.debug = globalObject3.createDebugger("vike:routing");
  }
  globalObject3.debug(...args);
}
function setCreateDebugger(createDebugger3) {
  globalObject3.createDebugger = createDebugger3;
}
var globalObject3;
var init_debug = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/debug.js"() {
    init_getGlobalObject();
    globalObject3 = getGlobalObject("route/debug.ts", {});
    __name(debug, "debug");
    __name(setCreateDebugger, "setCreateDebugger");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertIsNotBrowser.js
function assertIsNotBrowser() {
  assert(!isBrowser());
}
var init_assertIsNotBrowser = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertIsNotBrowser.js"() {
    init_isBrowser();
    init_assert();
    __name(assertIsNotBrowser, "assertIsNotBrowser");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/debug.js
function createDebugger(flag, optionsGlobal) {
  checkType(flag);
  assert(flags.includes(flag));
  const debugWithOptions = /* @__PURE__ */ __name((optionsLocal) => {
    return (...msgs) => {
      const options = { ...optionsGlobal, ...optionsLocal };
      debug_(flag, options, ...msgs);
    };
  }, "debugWithOptions");
  const debug7 = /* @__PURE__ */ __name((...msgs) => debugWithOptions({})(...msgs), "debug");
  objectAssign(debug7, { options: debugWithOptions, isActivated: isDebugActivated(flag) });
  return debug7;
}
function debug_(flag, options, ...msgs) {
  if (!isDebugActivated(flag))
    return;
  let [msgFirst, ...msgsRest] = msgs;
  const padding = " ".repeat(flag.length + 1);
  msgFirst = formatMsg(msgFirst, options, padding, "FIRST");
  msgsRest = msgsRest.map((msg, i) => {
    const position = i === msgsRest.length - 1 ? "LAST" : "MIDDLE";
    return formatMsg(msg, options, padding, position);
  });
  let logFirst;
  let logsRest;
  const noNewLine = msgsRest.length <= 1 && [msgFirst, ...msgsRest].every((m) => typeof m === "string" ? !m.includes("\n") : !isObject(m));
  if (noNewLine) {
    logFirst = [msgFirst, ...msgsRest].map((m) => typeof m !== "string" ? m : m.trim());
    logsRest = [];
  } else {
    logFirst = [msgFirst];
    logsRest = msgsRest;
  }
  console.log("\x1B[1m%s\x1B[0m", flag, ...logFirst);
  logsRest.forEach((msg) => {
    console.log(msg);
  });
}
function isDebugActivated(flag) {
  checkType(flag);
  assert(flags.includes(flag));
  const { flagsActivated, all } = getFlagsActivated();
  const isActivated = flagsActivated.includes(flag) || all && !flagsSkipWildcard.includes(flag);
  return isActivated;
}
function formatMsg(info, options, padding, position) {
  if (info === void 0) {
    return void 0;
  }
  let str = position === "FIRST" ? "" : padding;
  if (typeof info === "string") {
    str += info;
  } else if (isArray(info)) {
    if (info.length === 0) {
      str += options.serialization?.emptyArray ?? "[]";
    } else {
      str += info.map(strUnknown).join("\n");
    }
  } else {
    str += strUnknown(info);
  }
  str = pad(str, padding);
  if (position !== "LAST" && position !== "FIRST") {
    str += "\n";
  }
  return str;
}
function pad(str, padding) {
  const terminalWidth = getTerminalWidth();
  const lines = [];
  str.split("\n").forEach((line) => {
    if (!terminalWidth) {
      lines.push(line);
    } else {
      chunk(line, terminalWidth - padding.length).forEach((chunk3) => {
        lines.push(chunk3);
      });
    }
  });
  return lines.join("\n" + padding);
}
function chunk(str, size) {
  if (str.length <= size) {
    return [str];
  }
  const chunks = str.match(new RegExp(".{1," + size + "}", "g"));
  assert(chunks);
  return chunks;
}
function strUnknown(thing) {
  return typeof thing === "string" ? thing : strObj(thing);
}
function strObj(obj, newLines = true) {
  return JSON.stringify(obj, replaceFunctionSerializer, newLines ? 2 : void 0);
}
function replaceFunctionSerializer(_key, value) {
  if (isCallable(value)) {
    return value.toString().split(/\s+/).join(" ");
  }
  return value;
}
function assertFlagsActivated() {
  const { flagsActivated } = getFlagsActivated();
  flagsActivated.forEach((flag) => {
    assertUsage(flags.includes(flag), `Unknown DEBUG flag ${picocolors_default.cyan(flag)}. Valid flags:
${flags.map((f) => `  ${picocolors_default.cyan(f)}`).join("\n")}`);
  });
}
function getFlagsActivated() {
  const flagsActivated = DEBUG.match(flagRegex) ?? [];
  const all = DEBUG.includes("vike:*");
  return { flagsActivated, all };
}
function isDebug() {
  const { flagsActivated, all } = getFlagsActivated();
  return all || flagsActivated.length > 0;
}
function getDEBUG() {
  let DEBUG3;
  try {
    DEBUG3 = process.env.DEBUG;
  } catch {
  }
  return DEBUG3;
}
var flags, flagsSkipWildcard, flagRegex, DEBUG;
var init_debug2 = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/debug.js"() {
    init_isCallable();
    init_objectAssign();
    init_assert();
    init_checkType();
    init_getTerminalWidth();
    init_picocolors();
    init_isArray();
    init_isObject();
    init_debug();
    init_assertIsNotBrowser();
    assertIsNotBrowser();
    setCreateDebugger(createDebugger);
    flags = [
      "vike:crawl",
      "vike:error",
      "vike:esbuild-resolve",
      "vike:pluginExtractAssets",
      "vike:pluginExtractExportNames",
      "vike:glob",
      "vike:globalContext",
      "vike:log",
      "vike:optimizeDeps",
      "vike:outDir",
      "vike:pageFiles",
      "vike:pointer-imports",
      "vike:resolve",
      "vike:routing",
      "vike:setup",
      "vike:stream",
      "vike:virtualFiles",
      "vike:vite-rpc"
    ];
    flagsSkipWildcard = ["vike:log"];
    flagRegex = /\bvike:[a-zA-Z-]+/g;
    DEBUG = getDEBUG() ?? "";
    if (isDebug())
      Error.stackTraceLimit = Infinity;
    assertFlagsActivated();
    __name(createDebugger, "createDebugger");
    __name(debug_, "debug_");
    __name(isDebugActivated, "isDebugActivated");
    __name(formatMsg, "formatMsg");
    __name(pad, "pad");
    __name(chunk, "chunk");
    __name(strUnknown, "strUnknown");
    __name(strObj, "strObj");
    __name(replaceFunctionSerializer, "replaceFunctionSerializer");
    __name(assertFlagsActivated, "assertFlagsActivated");
    __name(getFlagsActivated, "getFlagsActivated");
    __name(isDebug, "isDebug");
    __name(getDEBUG, "getDEBUG");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/trackLogs.js
function trackLogs() {
  const logOriginal = process.stdout.write;
  const log = /* @__PURE__ */ __name((msg) => logOriginal.call(process.stdout, msg + "\n"), "log");
  ["stdout", "stderr"].forEach((stdName) => {
    var methodOriginal = process[stdName].write;
    process[stdName].write = function(...args) {
      log(picocolors_default.bold(picocolors_default.blue("*** LOG ***")));
      methodOriginal.apply(process[stdName], args);
      log(new Error().stack.replace(/^Error(\:|)/, picocolors_default.magenta("*** LOG ORIGIN ***")));
    };
  });
  Error.stackTraceLimit = Infinity;
}
var init_trackLogs = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/trackLogs.js"() {
    init_debug2();
    init_picocolors();
    init_assertIsNotBrowser();
    assertIsNotBrowser();
    if (isDebugActivated("vike:log")) {
      trackLogs();
    }
    __name(trackLogs, "trackLogs");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertVersion.js
function assertVersion(dependencyName, versionActual, versionExpected) {
  assert(versionActual);
  assert(versionExpected);
  assertUsage(isVersionOrAbove(versionActual, versionExpected), `${dependencyName} ${versionActual} isn't supported, use ${dependencyName} >= ${versionExpected} instead.`);
}
function isVersionOrAbove(versionActual, versionExpected) {
  const p1 = parseVersion(versionActual);
  const p2 = parseVersion(versionExpected);
  if (p1[0] !== p2[0])
    return p1[0] > p2[0];
  if (p1[1] !== p2[1])
    return p1[1] > p2[1];
  if (p1[2] !== p2[2])
    return p1[2] > p2[2];
  return true;
}
function parseVersion(version2) {
  version2 = version2.split("-")[0];
  let partsStr = version2.split(".");
  partsStr = partsStr.slice(0, 3);
  assert(partsStr.length === 3);
  assert(partsStr.every((s) => s.length > 0));
  const parts = partsStr.map((s) => parseInt(s, 10));
  return parts;
}
var init_assertVersion = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertVersion.js"() {
    init_assert();
    init_assertIsNotBrowser();
    assertIsNotBrowser();
    __name(assertVersion, "assertVersion");
    __name(isVersionOrAbove, "isVersionOrAbove");
    __name(parseVersion, "parseVersion");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertNodeVersion.js
function assertNodeVersion() {
  if (!isNodeJS())
    return;
  const version2 = process.versions.node;
  assertVersion("Node.js", version2, "18.0.0");
}
var init_assertNodeVersion = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertNodeVersion.js"() {
    init_isNodeJS();
    init_assertVersion();
    __name(assertNodeVersion, "assertNodeVersion");
  }
});

// node_modules/.pnpm/@brillout+require-shim@0.1.2/node_modules/@brillout/require-shim/dist/utils.cjs
var require_utils = __commonJS({
  "node_modules/.pnpm/@brillout+require-shim@0.1.2/node_modules/@brillout/require-shim/dist/utils.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGlobalObject = exports.isVitest = exports.pathJoin = exports.assertIsNotBrowser = exports.assert = exports.assertPosixPath = exports.toPosixPath = void 0;
    function toPosixPath4(path) {
      const pathPosix = path.split("\\").join("/");
      assertPosixPath4(pathPosix);
      return pathPosix;
    }
    __name(toPosixPath4, "toPosixPath");
    exports.toPosixPath = toPosixPath4;
    function assertPosixPath4(path) {
      const errMsg = /* @__PURE__ */ __name((msg) => `Not a posix path: ${msg}`, "errMsg");
      assert5(path !== null, errMsg("null"));
      assert5(typeof path === "string", errMsg(`typeof path === '${typeof path}'`));
      assert5(path !== "", errMsg("(empty string)"));
      assert5(path);
      assert5(!path.includes("\\"), errMsg(path));
    }
    __name(assertPosixPath4, "assertPosixPath");
    exports.assertPosixPath = assertPosixPath4;
    function assert5(condition, debugInfo) {
      if (condition)
        return;
      const githubRepository = "https://github.com/brillout/require-shim";
      let errMsg = [
        "[@brillout/require-shim]",
        "You stumbled upon a bug.",
        `Go to ${githubRepository}/issues/new and copy-paste this error.`,
        "A maintainer will fix the bug.",
        debugInfo
      ].filter(Boolean).join(" ");
      throw new Error(errMsg);
    }
    __name(assert5, "assert");
    exports.assert = assert5;
    function assertIsNotBrowser3() {
      assert5(!isBrowser5());
    }
    __name(assertIsNotBrowser3, "assertIsNotBrowser");
    exports.assertIsNotBrowser = assertIsNotBrowser3;
    function isBrowser5() {
      return typeof window !== "undefined" && typeof window.scrollY === "number";
    }
    __name(isBrowser5, "isBrowser");
    function pathJoin(path1, path2) {
      assert5(!path1.includes("\\"));
      assert5(!path2.includes("\\"));
      let joined = [...path1.split("/"), ...path2.split("/")].filter(Boolean).join("/");
      if (path1.startsWith("/"))
        joined = "/" + joined;
      return joined;
    }
    __name(pathJoin, "pathJoin");
    exports.pathJoin = pathJoin;
    function isVitest2() {
      return typeof process !== "undefined" && typeof process.env !== "undefined" && "VITEST" in process.env;
    }
    __name(isVitest2, "isVitest");
    exports.isVitest = isVitest2;
    function getGlobalObject4(key, defaultValue) {
      const allGlobalObjects = globalThis.__brillout_require_shim = globalThis.__brillout_require_shim || {};
      const globalObject24 = allGlobalObjects[key] = allGlobalObjects[key] || defaultValue;
      return globalObject24;
    }
    __name(getGlobalObject4, "getGlobalObject");
    exports.getGlobalObject = getGlobalObject4;
  }
});

// node_modules/.pnpm/@brillout+require-shim@0.1.2/node_modules/@brillout/require-shim/dist/runtime-test.cjs
var require_runtime_test = __commonJS({
  "node_modules/.pnpm/@brillout+require-shim@0.1.2/node_modules/@brillout/require-shim/dist/runtime-test.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_cjs_1 = require_utils();
    testRequireShim();
    function testRequireShim() {
      let req;
      try {
        req = __require;
      } catch (_a2) {
      }
      if (!req)
        return;
      (0, utils_cjs_1.assert)(!("_is_brillout_require_shim" in __require));
    }
    __name(testRequireShim, "testRequireShim");
  }
});

// node_modules/.pnpm/@brillout+require-shim@0.1.2/node_modules/@brillout/require-shim/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/.pnpm/@brillout+require-shim@0.1.2/node_modules/@brillout/require-shim/dist/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.installRequireShim_setUserRootDir = exports.installRequireShim = void 0;
    var utils_cjs_1 = require_utils();
    var globalObject24 = (0, utils_cjs_1.getGlobalObject)("utils/require-shim.ts", {});
    (0, utils_cjs_1.assertIsNotBrowser)();
    function installRequireShim2() {
      if (globalObject24.alreadyCalled)
        return;
      globalObject24.alreadyCalled = true;
      let requireLocal;
      try {
        requireLocal = __require;
      } catch (_a2) {
      }
      if (!requireLocal)
        return;
      let module3;
      try {
        module3 = requireLocal("module");
      } catch (_b) {
        return;
      }
      if (globalThis.require === void 0) {
        install();
      }
      testShim();
      return;
      function install() {
        Object.defineProperty(globalThis, "require", {
          get() {
            let callsites;
            {
              const prepareStackTraceOrg = Error.prepareStackTrace;
              Error.prepareStackTrace = (_, stack) => stack;
              const err = new Error();
              callsites = err.stack;
              Error.prepareStackTrace = prepareStackTraceOrg;
            }
            const callerFile = getCallerFile(callsites);
            const callerFileFallback = __filename;
            const requireContextFile = callerFile || callerFileFallback;
            (0, utils_cjs_1.assert)(requireContextFile);
            const requireUserLand = module3.createRequire(requireContextFile);
            requireUserLand._is_brillout_require_shim = true;
            return requireUserLand;
          }
        });
      }
      __name(install, "install");
      function getCallerFile(callsites) {
        const caller = callsites[1];
        (0, utils_cjs_1.assert)(caller);
        if (!caller.getFileName)
          return null;
        {
          const filePath = caller.getFileName();
          (0, utils_cjs_1.assert)(typeof filePath === "string" && filePath || filePath === void 0);
          if (filePath)
            return filePath;
        }
        {
          const filePath = deriveFilePath(caller);
          if (filePath) {
            return filePath;
          }
        }
        return null;
      }
      __name(getCallerFile, "getCallerFile");
      function deriveFilePath(caller) {
        let filePath = caller.getEvalOrigin();
        if (!filePath)
          return null;
        if (doesPathExist(filePath)) {
          return filePath;
        }
        const { userRootDir } = globalObject24;
        if (!userRootDir)
          return null;
        let filePathAbsolute = (0, utils_cjs_1.toPosixPath)(filePath);
        (0, utils_cjs_1.assertPosixPath)(userRootDir);
        filePathAbsolute = (0, utils_cjs_1.pathJoin)(userRootDir, filePathAbsolute);
        if (doesPathExist(filePathAbsolute)) {
          return filePathAbsolute;
        }
        return null;
      }
      __name(deriveFilePath, "deriveFilePath");
      function doesPathExist(filePath) {
        (0, utils_cjs_1.assert)(requireLocal);
        try {
          requireLocal.resolve(filePath);
          return true;
        } catch (_a2) {
          return false;
        }
      }
      __name(doesPathExist, "doesPathExist");
    }
    __name(installRequireShim2, "installRequireShim");
    exports.installRequireShim = installRequireShim2;
    function testShim() {
      if ((0, utils_cjs_1.isVitest)())
        return;
      (0, utils_cjs_1.assert)(__require !== globalThis.require);
      (0, utils_cjs_1.assert)(!("_is_brillout_require_shim" in __require));
      Promise.resolve().then(() => __toESM(require_runtime_test()));
    }
    __name(testShim, "testShim");
    function installRequireShim_setUserRootDir(userRootDir) {
      globalObject24.userRootDir = userRootDir;
    }
    __name(installRequireShim_setUserRootDir, "installRequireShim_setUserRootDir");
    exports.installRequireShim_setUserRootDir = installRequireShim_setUserRootDir;
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getFileExtension.js
function getFileExtension(id) {
  id = id.split("?")[0];
  const fileName = slice(id.split("/"), -1, 0)[0];
  if (!fileName) {
    return null;
  }
  const fileExtension = slice(fileName.split("."), -1, 0)[0];
  if (!fileExtension) {
    return null;
  }
  return fileExtension;
}
var init_getFileExtension = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getFileExtension.js"() {
    init_slice();
    __name(getFileExtension, "getFileExtension");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/parseUrl-extras.js
function prependBase(url, baseServer2) {
  if (baseServer2.startsWith("http")) {
    const baseAssets = baseServer2;
    const baseAssetsNormalized = normalizeBaseAssets(baseAssets);
    assert(!baseAssetsNormalized.endsWith("/"));
    assert(url.startsWith("/"));
    return `${baseAssetsNormalized}${url}`;
  }
  assert(isBaseServer(baseServer2));
  const baseServerNormalized = normalizeBaseServer(baseServer2);
  if (baseServerNormalized === "/")
    return url;
  assert(!baseServerNormalized.endsWith("/"));
  assert(url.startsWith("/"));
  return `${baseServerNormalized}${url}`;
}
function removeBaseServer2(url, baseServer2) {
  const { isBaseMissing, origin, pathname, pathnameOriginal, searchOriginal, hashOriginal } = parseUrl(url, baseServer2);
  assert(!isBaseMissing);
  assertUrlComponents(url, origin, pathnameOriginal, searchOriginal, hashOriginal);
  const urlWithoutBase = createUrlFromComponents(origin, pathname, searchOriginal, hashOriginal);
  return urlWithoutBase;
}
function normalizeBaseAssets(baseAssets) {
  let baseAssetsNormalized = baseAssets;
  if (baseAssetsNormalized.endsWith("/")) {
    baseAssetsNormalized = slice(baseAssetsNormalized, 0, -1);
  }
  assert(!baseAssetsNormalized.endsWith("/"));
  return baseAssetsNormalized;
}
function normalizeBaseServer(baseServer2) {
  let baseServerNormalized = baseServer2;
  if (baseServerNormalized.endsWith("/") && baseServerNormalized !== "/") {
    baseServerNormalized = slice(baseServerNormalized, 0, -1);
  }
  assert(!baseServerNormalized.endsWith("/") || baseServerNormalized === "/");
  return baseServerNormalized;
}
function isBaseAssets(base) {
  return base.startsWith("/") || base.startsWith("http://") || base.startsWith("https://");
}
function normalizeUrlPathname(urlOriginal, trailingSlash, baseServer2) {
  const urlNormalized = modifyUrlPathname(urlOriginal, (urlPathname) => {
    assert(urlPathname.startsWith("/"));
    let urlPathnameNormalized = normalize(urlPathname);
    if (urlPathnameNormalized === "/") {
      return urlPathnameNormalized;
    }
    if (baseServer2.endsWith("/") && baseServer2 !== "/" && normalize(baseServer2) === urlPathnameNormalized) {
      trailingSlash = true;
    }
    assert(!urlPathnameNormalized.endsWith("/"));
    if (trailingSlash) {
      urlPathnameNormalized = urlPathnameNormalized + "/";
    }
    return urlPathnameNormalized;
  });
  if (urlNormalized === urlOriginal)
    return null;
  return urlNormalized;
}
function normalize(urlPathname) {
  assert(urlPathname.startsWith("/"));
  return "/" + urlPathname.split("/").filter(Boolean).join("/");
}
function modifyUrlPathname(url, modifier) {
  const { origin, pathnameOriginal, searchOriginal, hashOriginal } = parseUrl(url, "/");
  const pathnameModified = modifier(pathnameOriginal);
  if (pathnameModified === null)
    return url;
  assertUrlComponents(url, origin, pathnameOriginal, searchOriginal, hashOriginal);
  const urlModified = createUrlFromComponents(origin, pathnameModified, searchOriginal, hashOriginal);
  assert(pathnameOriginal === pathnameModified === (url === urlModified));
  return urlModified;
}
function removeUrlOrigin(url) {
  const { origin, pathnameOriginal, searchOriginal, hashOriginal } = parseUrl(url, "/");
  const urlModified = createUrlFromComponents(null, pathnameOriginal, searchOriginal, hashOriginal);
  return { urlModified, origin };
}
function setUrlOrigin(url, origin) {
  const { origin: originCurrent, pathnameOriginal, searchOriginal, hashOriginal } = parseUrl(url, "/");
  if (origin === originCurrent)
    return false;
  assert(origin === null || origin.startsWith("http"));
  const urlModified = createUrlFromComponents(origin, pathnameOriginal, searchOriginal, hashOriginal);
  return urlModified;
}
function getUrlPretty(url) {
  const { urlModified } = removeUrlOrigin(url);
  return urlModified;
}
var init_parseUrl_extras = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/parseUrl-extras.js"() {
    init_parseUrl();
    init_assert();
    init_slice();
    init_assertIsNotBrowser();
    assertIsNotBrowser();
    __name(prependBase, "prependBase");
    __name(removeBaseServer2, "removeBaseServer");
    __name(normalizeBaseAssets, "normalizeBaseAssets");
    __name(normalizeBaseServer, "normalizeBaseServer");
    __name(isBaseAssets, "isBaseAssets");
    __name(normalizeUrlPathname, "normalizeUrlPathname");
    __name(normalize, "normalize");
    __name(modifyUrlPathname, "modifyUrlPathname");
    __name(removeUrlOrigin, "removeUrlOrigin");
    __name(setUrlOrigin, "setUrlOrigin");
    __name(getUrlPretty, "getUrlPretty");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/virtualFileId.js
function removeVirtualFileIdPrefix(id) {
  if (id.startsWith(prefix)) {
    id = id.slice(prefix.length);
  }
  assert(!id.startsWith(prefix));
  return id;
}
var prefix;
var init_virtualFileId = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/virtualFileId.js"() {
    init_picocolors();
    init_assert();
    init_assertIsNotBrowser();
    assertIsNotBrowser();
    prefix = "\0";
    __name(removeVirtualFileIdPrefix, "removeVirtualFileIdPrefix");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/utils.js
var init_utils2 = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/utils.js"() {
    init_assertIsNotBrowser();
    init_assert();
    init_getFileExtension();
    init_getGlobalObject();
    init_isPlainObject();
    init_checkType();
    init_hasProp();
    init_objectAssign();
    init_checkType();
    init_hasProp();
    init_parseUrl();
    init_parseUrl_extras();
    init_isObject();
    init_assertIsNotBrowser();
    init_isNullish();
    init_unique();
    init_debug2();
    init_virtualFileId();
    assertIsNotBrowser();
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/isErrorDebug.js
function isErrorDebug() {
  return isDebugActivated("vike:error");
}
var init_isErrorDebug = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/isErrorDebug.js"() {
    init_utils2();
    __name(isErrorDebug, "isErrorDebug");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/onLoad.js
function onLoad() {
  assertIsNotBrowser();
  assertNodeVersion();
  if (isErrorDebug())
    setAlwaysShowStackTrace();
  addEcosystemStamp();
  (0, import_require_shim.installRequireShim)();
}
function addEcosystemStamp() {
  const g2 = globalThis;
  g2._isVikeApp = /* Don't set to true so that consumers do `!!globalThis._isVikeApp` instead of `globalThis._isVikeApp === true`.
  true
  */
  // We use an object so that we can eventually, in the future, add helpful information as needed. (E.g. the Vike version, or global settings.)
  {};
  g2._isVitePluginSsr = true;
}
var import_require_shim;
var init_onLoad = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/onLoad.js"() {
    init_assertIsNotBrowser();
    init_assertNodeVersion();
    init_assert();
    import_require_shim = __toESM(require_dist(), 1);
    init_isErrorDebug();
    __name(onLoad, "onLoad");
    __name(addEcosystemStamp, "addEcosystemStamp");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectAssignSafe.js
var init_objectAssignSafe = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectAssignSafe.js"() {
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/PromiseType.js
var init_PromiseType = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/PromiseType.js"() {
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isObjectWithKeys.js
function isObjectWithKeys(obj, keys) {
  if (!isPlainObject(obj)) {
    return false;
  }
  for (const key of Object.keys(obj)) {
    if (!keys.includes(key)) {
      return false;
    }
  }
  return true;
}
var init_isObjectWithKeys = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isObjectWithKeys.js"() {
    init_isPlainObject();
    __name(isObjectWithKeys, "isObjectWithKeys");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/capitalizeFirstLetter.js
function capitalizeFirstLetter(word) {
  if (!word[0]) {
    return word;
  }
  return word[0].toUpperCase() + word.slice(1);
}
var init_capitalizeFirstLetter = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/capitalizeFirstLetter.js"() {
    __name(capitalizeFirstLetter, "capitalizeFirstLetter");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/debugGlob.js
var debugGlob;
var init_debugGlob = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/debugGlob.js"() {
    init_debug2();
    debugGlob = createDebugger("vike:glob");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isSameErrorMessage.js
function isSameErrorMessage(err1, err2) {
  if (!isObject(err1) || !isObject(err2))
    return false;
  return err1.message === err2.message;
}
var init_isSameErrorMessage = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isSameErrorMessage.js"() {
    init_isObject();
    __name(isSameErrorMessage, "isSameErrorMessage");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/styleFileRE.js
var styleFileRE;
var init_styleFileRE = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/styleFileRE.js"() {
    styleFileRE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss)($|\?)/;
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/urlToFile.js
var baseServer;
var init_urlToFile = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/urlToFile.js"() {
    init_assert();
    init_parseUrl();
    init_slice();
    baseServer = "/";
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/freezePartial.js
function freezePartial(obj, allowList) {
  Object.entries(obj).forEach(([key, val]) => {
    Object.defineProperty(obj, key, {
      get() {
        return val;
      },
      set(newVal) {
        if (key in allowList) {
          const isAllowed = allowList[key](newVal);
          if (isAllowed) {
            val = newVal;
            return;
          } else {
            throw new Error(`Setting wrong value ${picocolors_default.cyan(JSON.stringify(newVal))} for property ${picocolors_default.cyan(key)}`);
          }
        }
        throw new Error(`You aren't allowed to mutate property ${picocolors_default.cyan(key)}`);
      },
      configurable: false,
      enumerable: true
    });
  });
  Object.preventExtensions(obj);
}
var init_freezePartial = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/freezePartial.js"() {
    init_picocolors();
    init_assertIsNotBrowser();
    assertIsNotBrowser();
    __name(freezePartial, "freezePartial");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/parseNpmPackage.js
function isImportPathNpmPackage(str, { cannotBePathAlias }) {
  assert(cannotBePathAlias);
  return isImportPathNpmPackageOrPathAlias(str);
}
function isImportPathNpmPackageOrPathAlias(str) {
  const res = parseNpmPackage(str);
  return res !== null;
}
function assertIsImportPathNpmPackage(str) {
  assert(isImportPathNpmPackage(str, {
    // If `str` is a path alias that looks like an npm package => assertIsImportPathNpmPackage() is erroneous but that's okay because the assertion will eventually fail for some other user using a disambiguated path alias.
    cannotBePathAlias: true
  }), str);
}
function parseNpmPackage(str) {
  if (!str)
    return null;
  let scope = null;
  if (str.startsWith("@")) {
    if (!str.includes("/"))
      return null;
    const [scope_, ...rest] = str.split("/");
    scope = scope_;
    str = rest.join("/");
    if (!str)
      return null;
    if (scope === "@" || invalid(scope.slice(1)))
      return null;
  }
  const [name, ...importPathParts] = str.split("/");
  if (!name || invalid(name))
    return null;
  const importPath = importPathParts.length === 0 ? null : importPathParts.join("/");
  return {
    pkgName: scope ? `${scope}/${name}` : name,
    importPath
  };
}
function invalid(s) {
  const firstLetter = s[0];
  if (!firstLetter || !/[a-z0-9]/.test(firstLetter))
    return true;
  if (/[^a-z0-9_\-\.]/.test(s))
    return true;
  return false;
}
var init_parseNpmPackage = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/parseNpmPackage.js"() {
    init_assert();
    init_assertIsNotBrowser();
    assertIsNotBrowser();
    __name(isImportPathNpmPackage, "isImportPathNpmPackage");
    __name(isImportPathNpmPackageOrPathAlias, "isImportPathNpmPackageOrPathAlias");
    __name(assertIsImportPathNpmPackage, "assertIsImportPathNpmPackage");
    __name(parseNpmPackage, "parseNpmPackage");
    __name(invalid, "invalid");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/removeFileExtension.js
var init_removeFileExtension = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/removeFileExtension.js"() {
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectKeys.js
var init_objectKeys = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectKeys.js"() {
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectEntries.js
var init_objectEntries = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectEntries.js"() {
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectFromEntries.js
var init_objectFromEntries = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/objectFromEntries.js"() {
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isNonRunnableDev.js
function isNonRunnableDev() {
  if (typeof __VIKE__IS_NON_RUNNABLE_DEV === "undefined")
    return false;
  assert(__VIKE__IS_NON_RUNNABLE_DEV === true);
  return true;
}
var init_isNonRunnableDev = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isNonRunnableDev.js"() {
    init_assert();
    init_assertIsNotBrowser();
    assertIsNotBrowser();
    __name(isNonRunnableDev, "isNonRunnableDev");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isVitest.js
function isVitest() {
  return typeof process !== "undefined" && typeof process.env !== "undefined" && "VITEST" in process.env;
}
var init_isVitest = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isVitest.js"() {
    __name(isVitest, "isVitest");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertSetup.js
function onSetupRuntime() {
  if (debug2.isActivated)
    debug2("assertSetup()", new Error().stack);
  if (isTest())
    return;
  assertNodeEnvIsNotUndefinedString();
  if (!setup.viteDevServer && setup.isViteDev === void 0) {
    assertWarning2(!isNodeEnvDev() || isNonRunnableDev(), `The ${getEnvDescription()}, which is contradictory because the environment seems to be a production environment (Vite isn't loaded), see ${picocolors_default.underline("https://vike.dev/NODE_ENV")} and ${picocolors_default.underline("https://vike.dev/warning/setup")}`, { onlyOnce: true });
    assertUsage(!setup.vikeVitePlugin, `Vike's Vite plugin (the ${picocolors_default.cyan("vike/plugin")} module) shouldn't be loaded in production, see ${picocolors_default.underline("https://vike.dev/warning/setup")}`);
    assert(!setup.shouldNotBeProduction);
  } else {
    if (!setup.isPreview && !setup.vitePreviewServer && !setup.isPrerendering) {
      assertWarning2(isNodeEnvDev(), `The ${getEnvDescription()} while Vite is loaded, but Vite shouldn't be loaded in production, see ${picocolors_default.underline("https://vike.dev/warning/setup")}`, { onlyOnce: true });
    }
    assert(setup.vikeVitePlugin);
    assert(setup.shouldNotBeProduction);
  }
}
function isTest() {
  return isVitest() || isNodeEnv("test");
}
function getEnvDescription() {
  const envType = `${isNodeEnvDev() ? "development" : "production"} environment`;
  const nodeEnvDesc = `environment is set to be a ${picocolors_default.bold(envType)} by ${picocolors_default.cyan(`process.env.NODE_ENV===${JSON.stringify(getNodeEnv())}`)}`;
  return nodeEnvDesc;
}
function assertNodeEnvIsNotUndefinedString() {
  const nodeEnv = getNodeEnv();
  assertWarning2(nodeEnv !== "undefined", `${picocolors_default.cyan('process.env.NODE_ENV==="undefined"')} which is unexpected: ${picocolors_default.cyan("process.env.NODE_ENV")} is allowed to be the *value* ${picocolors_default.cyan("undefined")} (i.e. ${picocolors_default.cyan("process.env.NODE_ENV===undefined")}) but it shouldn't be the *string* ${picocolors_default.cyan('"undefined"')} \u2014 see ${picocolors_default.underline("https://vike.dev/NODE_ENV")}`, { onlyOnce: true });
}
function isNodeEnvDev() {
  const nodeEnv = getNodeEnv();
  return nodeEnv === void 0 || isNodeEnv(["development", "dev", ""]);
}
function isNodeEnv(value) {
  const values = Array.isArray(value) ? value : [value];
  const nodeEnv = getNodeEnv();
  return nodeEnv !== void 0 && values.includes(nodeEnv.toLowerCase());
}
function getNodeEnv() {
  let val;
  try {
    val = "undefined";
  } catch {
    return void 0;
  }
  return val;
}
var debug2, setup;
var init_assertSetup = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertSetup.js"() {
    init_assert();
    init_assertIsNotBrowser();
    init_debug2();
    init_getGlobalObject();
    init_isNonRunnableDev();
    init_isVitest();
    init_picocolors();
    assertIsNotBrowser();
    debug2 = createDebugger("vike:setup");
    setup = getGlobalObject("utils/assertSetup.ts", {});
    __name(onSetupRuntime, "onSetupRuntime");
    __name(isTest, "isTest");
    __name(getEnvDescription, "getEnvDescription");
    __name(assertNodeEnvIsNotUndefinedString, "assertNodeEnvIsNotUndefinedString");
    __name(isNodeEnvDev, "isNodeEnvDev");
    __name(isNodeEnv, "isNodeEnv");
    __name(getNodeEnv, "getNodeEnv");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/path.js
function toPosixPath(path) {
  const pathPosix = path.split("\\").join("/");
  assertPosixPath(pathPosix);
  return pathPosix;
}
function assertPosixPath(path) {
  const errMsg = /* @__PURE__ */ __name((msg) => `Not a posix path: ${msg}`, "errMsg");
  assert(path !== null, errMsg("null"));
  assert(typeof path === "string", errMsg(`typeof path === ${JSON.stringify(typeof path)}`));
  assert(path !== "", errMsg("(empty string)"));
  assert(path);
  assert(!path.includes("\\"), errMsg(path));
}
var init_path = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/path.js"() {
    init_assert();
    init_assertIsNotBrowser();
    assertIsNotBrowser();
    __name(toPosixPath, "toPosixPath");
    __name(assertPosixPath, "assertPosixPath");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isHtml.js
function isHtml(str) {
  const re = /(<\/[^<]+>)|(<[^<]+\/>)/;
  return re.test(str);
}
var init_isHtml = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isHtml.js"() {
    __name(isHtml, "isHtml");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/warnIfErrorIsNotObject.js
function warnIfErrorIsNotObject(err) {
  if (!isObject(err)) {
    console.warn("[vike] The thrown value is:");
    console.warn(err);
    assertWarning2(false, `One of your hooks threw an error ${picocolors_default.cyan("throw someValue")} but ${picocolors_default.cyan("someValue")} isn't an object (it's ${picocolors_default.cyan(`typeof someValue === ${typeof err}`)} instead). Make sure thrown values are always wrapped with ${picocolors_default.cyan("new Error()")}, in other words: ${picocolors_default.cyan("throw someValue")} should be replaced with ${picocolors_default.cyan("throw new Error(someValue)")}. The thrown value is printed above.`, { onlyOnce: false });
  }
}
var init_warnIfErrorIsNotObject = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/warnIfErrorIsNotObject.js"() {
    init_assert();
    init_assertIsNotBrowser();
    init_isObject();
    init_picocolors();
    assertIsNotBrowser();
    __name(warnIfErrorIsNotObject, "warnIfErrorIsNotObject");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/stripAnsi.js
function stripAnsi2(string) {
  return string.replace(ansiRegex2, "");
}
function getAnsiRegex2() {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(pattern, "g");
}
var ansiRegex2;
var init_stripAnsi = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/stripAnsi.js"() {
    init_assertIsNotBrowser();
    assertIsNotBrowser();
    ansiRegex2 = getAnsiRegex2();
    __name(stripAnsi2, "stripAnsi");
    __name(getAnsiRegex2, "getAnsiRegex");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/truncateString.js
function truncateString(str, lenMax) {
  const lenMaxReal = lenMax - 3;
  assert(lenMaxReal >= 1);
  if (str.length < lenMax) {
    return str;
  } else {
    str = str.substring(0, lenMaxReal);
    const ellipsis = picocolors_default.dim("...");
    str = str + ellipsis;
    return str;
  }
}
var init_truncateString = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/truncateString.js"() {
    init_picocolors();
    init_assert();
    __name(truncateString, "truncateString");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/formatHintLog.js
function formatHintLog(msg) {
  assert(msg.length > 0);
  const msgLength = stripAnsi2(msg).length;
  const sep = "\u2500".repeat(msgLength);
  return [
    // prettier-ignore
    // biome-ignore format:
    `\u250C\u2500${sep}\u2500\u2510`,
    `\u2502 ${msg} \u2502`,
    `\u2514\u2500${sep}\u2500\u2518`
  ].join("\n");
}
var init_formatHintLog = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/formatHintLog.js"() {
    init_assert();
    init_stripAnsi();
    __name(formatHintLog, "formatHintLog");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/joinEnglish.js
function joinEnglish(arr, conjunction, colorizer = (s) => s) {
  assert(arr.length > 0);
  if (arr.length === 1)
    return colorizer(arr[0]);
  const firsts = arr.slice(0, arr.length - 1);
  const last2 = arr[arr.length - 1];
  return firsts.map(colorizer).join(", ") + `, ${conjunction} ` + colorizer(last2);
}
var init_joinEnglish = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/joinEnglish.js"() {
    init_assert();
    __name(joinEnglish, "joinEnglish");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/escapeHtml.js
function escapeHtml(unsafeString) {
  const safe = unsafeString.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  return safe;
}
var init_escapeHtml = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/escapeHtml.js"() {
    __name(escapeHtml, "escapeHtml");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/normalizeHeaders.js
function normalizeHeaders(headersOriginal) {
  let headersCleaned = headersOriginal;
  if (isObject(headersCleaned) && headersCleaned[":method"])
    headersCleaned = Object.fromEntries(Object.entries(headersCleaned).filter(([key]) => !key.startsWith(":")));
  const headersStandard = new Headers(headersCleaned);
  const headers = Object.fromEntries(headersStandard.entries());
  return headers;
}
var init_normalizeHeaders = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/normalizeHeaders.js"() {
    init_isObject();
    __name(normalizeHeaders, "normalizeHeaders");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isVikeReactApp.js
function isVikeReactApp() {
  const g2 = globalThis;
  return !!g2._isVikeReactApp;
}
var init_isVikeReactApp = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isVikeReactApp.js"() {
    __name(isVikeReactApp, "isVikeReactApp");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/updateType.js
function updateType(thing, clone) {
  assert(thing === clone);
}
var init_updateType = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/updateType.js"() {
    init_assert();
    __name(updateType, "updateType");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getRandomId.js
function getRandomId(length = 12) {
  let randomId = "";
  while (randomId.length < length) {
    randomId += Math.random().toString(36).slice(2);
  }
  randomId = randomId.slice(0, length);
  assert(/^[a-z0-9]+$/.test(randomId) && randomId.length === length);
  return randomId;
}
var init_getRandomId = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getRandomId.js"() {
    init_assert();
    __name(getRandomId, "getRandomId");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getViteRPC.js
function getViteRPC() {
  globalObject4.rpc ?? (globalObject4.rpc = createRpcClient());
  return globalObject4.rpc;
}
function createRpcClient() {
  const hot = import.meta.hot;
  assert(hot);
  const listeners = [];
  hot.on(`vike:rpc:response`, (dataResponse) => {
    if (debug3.isActivated)
      debug3("Response received", dataResponse);
    const { callId, functionReturn } = dataResponse;
    listeners.forEach((l) => {
      if (callId !== l.callId)
        return;
      l.cb(functionReturn);
      listeners.splice(listeners.indexOf(l), 1);
    });
  });
  const rpc = new Proxy({}, {
    get(_, functionName) {
      return async (...functionArgs) => {
        const hot2 = import.meta.hot;
        assert(hot2);
        const callId = getRandomId();
        const { promise, resolve } = genPromise({ timeout: 3 * 1e3 });
        listeners.push({
          callId,
          cb: /* @__PURE__ */ __name((functionReturn2) => {
            resolve(functionReturn2);
          }, "cb")
        });
        const dataRequest = { callId, functionName, functionArgs };
        if (debug3.isActivated)
          debug3("Request sent", dataRequest);
        await hot2.send("vike:rpc:request", dataRequest);
        const functionReturn = await promise;
        return functionReturn;
      };
    }
  });
  return rpc;
}
var globalObject4, debug3;
var init_getViteRPC = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/getViteRPC.js"() {
    init_assert();
    init_genPromise();
    init_getRandomId();
    init_getGlobalObject();
    init_debug2();
    init_assertIsNotBrowser();
    assertIsNotBrowser();
    globalObject4 = getGlobalObject("utils/getViteRPC.ts", {
      rpc: null
    });
    debug3 = createDebugger("vike:vite-rpc");
    __name(getViteRPC, "getViteRPC");
    __name(createRpcClient, "createRpcClient");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isRunnableDevEnvironment.js
function isRunnableDevEnvironment(environment) {
  return !!environment && "runner" in environment && !!environment.runner;
}
var init_isRunnableDevEnvironment = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/isRunnableDevEnvironment.js"() {
    __name(isRunnableDevEnvironment, "isRunnableDevEnvironment");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/utils.js
var init_utils3 = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/utils.js"() {
    init_trackLogs();
    init_onLoad();
    init_assert();
    init_cast();
    init_checkType();
    init_isCallable();
    init_isBrowser();
    init_isPlainObject();
    init_isPromise();
    init_hasProp();
    init_parseUrl();
    init_parseUrl_extras();
    init_slice();
    init_sorter();
    init_isArray();
    init_isObject();
    init_objectAssign();
    init_objectAssignSafe();
    init_objectReplace();
    init_PromiseType();
    init_compareString();
    init_isObjectWithKeys();
    init_stringifyStringArray();
    init_unique();
    init_capitalizeFirstLetter();
    init_debugGlob();
    init_isSameErrorMessage();
    init_styleFileRE();
    init_isPropertyGetter();
    init_debug2();
    init_urlToFile();
    init_getGlobalObject();
    init_freezePartial();
    init_parseNpmPackage();
    init_isNullish();
    init_isScriptFile();
    init_removeFileExtension();
    init_objectKeys();
    init_objectEntries();
    init_objectFromEntries();
    init_getFileExtension();
    init_assertSetup();
    init_path();
    init_isHtml();
    init_warnIfErrorIsNotObject();
    init_virtualFileId();
    init_stripAnsi();
    init_getTerminalWidth();
    init_truncateString();
    init_formatHintLog();
    init_joinEnglish();
    init_isArrayOfStrings();
    init_escapeHtml();
    init_normalizeHeaders();
    init_isVikeReactApp();
    init_getPropAccessNotation();
    init_PROJECT_VERSION();
    init_genPromise();
    init_updateType();
    init_changeEnumerable();
    init_getViteRPC();
    init_isRunnableDevEnvironment();
    init_assertIsNotBrowser();
    init_isNonRunnableDev();
    onLoad();
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/assertPageContextProvidedByUser.js
function assertPageContextProvidedByUser(pageContextProvidedByUser, { hookName, hookFilePath }) {
  if (pageContextProvidedByUser === void 0 || pageContextProvidedByUser === null)
    return;
  assert(!hookName.endsWith(")"));
  const errPrefix = `The ${picocolors_default.cyan("pageContext")} object provided by the ${hookName}() hook defined by ${hookFilePath}`;
  assertUsage(isObject(pageContextProvidedByUser), `${errPrefix} should be an object (but it's ${picocolors_default.cyan(`typeof pageContext === ${JSON.stringify(typeof pageContextProvidedByUser)}`)} instead)`);
  assertUsage(!("isPageContext" in pageContextProvidedByUser), `${errPrefix} shouldn't be the whole ${picocolors_default.cyan("pageContext")} object, see https://vike.dev/pageContext-manipulation#do-not-return-entire-pagecontext`);
  assertWarning2(!("pageId" in pageContextProvidedByUser), `${errPrefix} sets ${picocolors_default.cyan("pageContext.pageId")} which means that Vike's routing is overridden. This is an experimental feature: make sure to contact a vike maintainer before using this.`, { onlyOnce: true });
  assertUsage(!("is404" in pageContextProvidedByUser), `${errPrefix} sets ${picocolors_default.cyan("pageContext.is404")} which is forbidden, use ${picocolors_default.cyan("throw render()")} instead, see https://vike.dev/render`);
}
var init_assertPageContextProvidedByUser = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/assertPageContextProvidedByUser.js"() {
    init_utils();
    init_picocolors();
    __name(assertPageContextProvidedByUser, "assertPageContextProvidedByUser");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/injectHtmlTags.js
function injectHtmlTags(htmlString, htmlTags, position) {
  const htmlFragment = joinHtmlTags(htmlTags.filter((h) => h.position === position));
  if (htmlFragment) {
    htmlString = injectHtmlFragment(position, htmlFragment, htmlString);
  }
  return htmlString;
}
function injectHtmlTagsUsingStream(htmlTags, streamFromReactStreamingPackage) {
  const htmlFragment = joinHtmlTags(htmlTags.filter((h) => h.position === "HTML_STREAM"));
  if (htmlFragment) {
    assert(!streamFromReactStreamingPackage.hasStreamEnded());
    streamFromReactStreamingPackage.injectToStream(htmlFragment, { flush: true });
  }
}
function joinHtmlTags(htmlTags) {
  const htmlFragment = htmlTags.map((h) => resolveHtmlTag(h.htmlTag)).join("");
  return htmlFragment;
}
function injectHtmlFragment(position, htmlFragment, htmlString) {
  if (position === "HTML_BEGIN") {
    {
      const res = injectAtPlaceholder(htmlFragment, htmlString, true);
      if (res)
        return res;
    }
    assert(tagOpeningExists("head", htmlString));
    htmlString = injectAtOpeningTag("head", htmlString, htmlFragment);
    return htmlString;
  }
  if (position === "HTML_END") {
    {
      const res = injectAtPlaceholder(htmlFragment, htmlString, false);
      if (res)
        return res;
    }
    if (tagClosingExists("body", htmlString)) {
      return injectAtClosingTag("body", htmlString, htmlFragment);
    }
    if (tagClosingExists("html", htmlString)) {
      return injectAtClosingTag("html", htmlString, htmlFragment);
    }
    return htmlString + "\n" + htmlFragment;
  }
  assert(false);
}
function resolveHtmlTag(htmlTag) {
  return typeof htmlTag !== "string" ? htmlTag() : htmlTag;
}
function injectAtOpeningTag(tag, htmlString, htmlFragment) {
  const openingTag = getTagOpening(tag);
  const matches = htmlString.match(openingTag);
  assert(matches && matches.length >= 1);
  const tagInstance = matches[0];
  assert(tagInstance);
  const htmlParts = htmlString.split(tagInstance);
  assert(htmlParts.length >= 2);
  const before = slice(htmlParts, 0, 1)[0] + tagInstance;
  const after = slice(htmlParts, 1, 0).join(tagInstance);
  htmlFragment = injectBreakLines(htmlFragment, before, after);
  return before + htmlFragment + after;
}
function injectAtClosingTag(tag, htmlString, htmlFragment) {
  const tagClosing = getTagClosing(tag);
  const matches = htmlString.match(tagClosing);
  assert(matches && matches.length >= 1);
  const tagInstance = matches[0];
  assert(tagInstance);
  const htmlParts = htmlString.split(tagInstance);
  assert(htmlParts.length >= 2);
  const before = slice(htmlParts, 0, -1).join(tagInstance);
  const after = tagInstance + slice(htmlParts, -1, 0);
  htmlFragment = injectBreakLines(htmlFragment, before, after);
  return before + htmlFragment + after;
}
function injectBreakLines(htmlFragment, before, after) {
  assert(htmlFragment.trim() === htmlFragment);
  const currentLineBefore = before.split("\n").slice(-1)[0];
  let paddingParent = currentLineBefore.match(/\s*$/)[0];
  let isBlankLine = !!paddingParent;
  if (!paddingParent) {
    paddingParent = currentLineBefore.match(/^\s*/)[0];
  }
  if (!paddingParent)
    return htmlFragment;
  const whitespaceExtra = paddingParent ? "  " : "";
  const whitespace = `${paddingParent}${whitespaceExtra}`;
  const padding = `
${whitespace}`;
  htmlFragment = htmlFragment.replace(/<[^\/]/g, (match) => `${padding}${match}`);
  if (isBlankLine) {
    assert(htmlFragment.startsWith(padding), { htmlFragment });
    htmlFragment = whitespaceExtra + htmlFragment.slice(padding.length);
  }
  const currentLineAfter = after.split("\n")[0];
  if (currentLineAfter.trim().length > 0) {
    htmlFragment += "\n" + paddingParent;
  }
  return htmlFragment;
}
function createHtmlHeadIfMissing(htmlString) {
  const assertion = /* @__PURE__ */ __name(() => assert(tagOpeningExists("head", htmlString) && tagClosingExists("head", htmlString)), "assertion");
  if (tagOpeningExists("head", htmlString) && tagClosingExists("head", htmlString)) {
    assertion();
    return htmlString;
  }
  const htmlFragment = "<head></head>";
  if (tagOpeningExists("html", htmlString)) {
    htmlString = injectAtOpeningTag("html", htmlString, htmlFragment);
    assertion();
    return htmlString;
  }
  if (tagOpeningExists("!doctype", htmlString)) {
    htmlString = injectAtOpeningTag("!doctype", htmlString, htmlFragment);
    assertion();
    return htmlString;
  }
  htmlString = htmlFragment + "\n" + htmlString;
  assertion();
  return htmlString;
}
function tagOpeningExists(tag, htmlString) {
  const tagOpeningRE = getTagOpening(tag);
  return tagOpeningRE.test(htmlString);
}
function tagClosingExists(tag, htmlString) {
  const tagClosingRE = getTagClosing(tag);
  return tagClosingRE.test(htmlString);
}
function getTagOpening(tag) {
  const tagOpening = new RegExp(`<${tag}(>| [^>]*>)`, "i");
  return tagOpening;
}
function getTagClosing(tag) {
  const tagClosing = new RegExp(`</${tag}>`, "i");
  return tagClosing;
}
function injectAtPlaceholder(htmlFragment, htmlString, isFirst) {
  const placeholder = isFirst ? "__VITE_PLUGIN_SSR__ASSETS_FIRST__" : "__VITE_PLUGIN__SSR_ASSETS_LAST__";
  const parts = htmlString.split(placeholder);
  if (parts.length === 1)
    return null;
  assertUsage(parts.length === 2, "You're inserting assets twice into your HTML", { showStackTrace: true });
  return [parts[0], htmlFragment, parts[1]].join("");
}
var init_injectHtmlTags = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/injectHtmlTags.js"() {
    init_utils3();
    __name(injectHtmlTags, "injectHtmlTags");
    __name(injectHtmlTagsUsingStream, "injectHtmlTagsUsingStream");
    __name(joinHtmlTags, "joinHtmlTags");
    __name(injectHtmlFragment, "injectHtmlFragment");
    __name(resolveHtmlTag, "resolveHtmlTag");
    __name(injectAtOpeningTag, "injectAtOpeningTag");
    __name(injectAtClosingTag, "injectAtClosingTag");
    __name(injectBreakLines, "injectBreakLines");
    __name(createHtmlHeadIfMissing, "createHtmlHeadIfMissing");
    __name(tagOpeningExists, "tagOpeningExists");
    __name(tagClosingExists, "tagClosingExists");
    __name(getTagOpening, "getTagOpening");
    __name(getTagClosing, "getTagClosing");
    __name(injectAtPlaceholder, "injectAtPlaceholder");
  }
});

// node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/types.js
function ts(t) {
  return t;
}
var types;
var init_types = __esm({
  "node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/types.js"() {
    types = [
      ts({
        is: /* @__PURE__ */ __name((val) => val === void 0, "is"),
        match: /* @__PURE__ */ __name((str) => str === "!undefined", "match"),
        serialize: /* @__PURE__ */ __name(() => "!undefined", "serialize"),
        deserialize: /* @__PURE__ */ __name(() => void 0, "deserialize")
      }),
      ts({
        is: /* @__PURE__ */ __name((val) => val === Infinity, "is"),
        match: /* @__PURE__ */ __name((str) => str === "!Infinity", "match"),
        serialize: /* @__PURE__ */ __name(() => "!Infinity", "serialize"),
        deserialize: /* @__PURE__ */ __name(() => Infinity, "deserialize")
      }),
      ts({
        is: /* @__PURE__ */ __name((val) => val === -Infinity, "is"),
        match: /* @__PURE__ */ __name((str) => str === "!-Infinity", "match"),
        serialize: /* @__PURE__ */ __name(() => "!-Infinity", "serialize"),
        deserialize: /* @__PURE__ */ __name(() => -Infinity, "deserialize")
      }),
      ts({
        is: /* @__PURE__ */ __name((val) => typeof val === "number" && isNaN(val), "is"),
        match: /* @__PURE__ */ __name((str) => str === "!NaN", "match"),
        serialize: /* @__PURE__ */ __name(() => "!NaN", "serialize"),
        deserialize: /* @__PURE__ */ __name(() => NaN, "deserialize")
      }),
      ts({
        is: /* @__PURE__ */ __name((val) => val instanceof Date, "is"),
        match: /* @__PURE__ */ __name((str) => str.startsWith("!Date:"), "match"),
        serialize: /* @__PURE__ */ __name((val) => "!Date:" + val.toISOString(), "serialize"),
        deserialize: /* @__PURE__ */ __name((str) => new Date(str.slice("!Date:".length)), "deserialize")
      }),
      ts({
        is: /* @__PURE__ */ __name((val) => typeof val === "bigint", "is"),
        match: /* @__PURE__ */ __name((str) => str.startsWith("!BigInt:"), "match"),
        serialize: /* @__PURE__ */ __name((val) => "!BigInt:" + val.toString(), "serialize"),
        deserialize: /* @__PURE__ */ __name((str) => {
          if (typeof BigInt === "undefined") {
            throw new Error("Your JavaScript environement does not support BigInt. Consider adding a polyfill.");
          }
          return BigInt(str.slice("!BigInt:".length));
        }, "deserialize")
      }),
      ts({
        is: /* @__PURE__ */ __name((val) => val instanceof RegExp, "is"),
        match: /* @__PURE__ */ __name((str) => str.startsWith("!RegExp:"), "match"),
        serialize: /* @__PURE__ */ __name((val) => "!RegExp:" + val.toString(), "serialize"),
        deserialize: /* @__PURE__ */ __name((str) => {
          str = str.slice("!RegExp:".length);
          const args = str.match(/\/(.*)\/(.*)?/);
          const pattern = args[1];
          const flags2 = args[2];
          return new RegExp(pattern, flags2);
        }, "deserialize")
      }),
      ts({
        is: /* @__PURE__ */ __name((val) => val instanceof Map, "is"),
        match: /* @__PURE__ */ __name((str) => str.startsWith("!Map:"), "match"),
        serialize: /* @__PURE__ */ __name((val, serializer) => "!Map:" + serializer(Array.from(val.entries())), "serialize"),
        deserialize: /* @__PURE__ */ __name((str, parser) => new Map(parser(str.slice("!Map:".length))), "deserialize")
      }),
      ts({
        is: /* @__PURE__ */ __name((val) => val instanceof Set, "is"),
        match: /* @__PURE__ */ __name((str) => str.startsWith("!Set:"), "match"),
        serialize: /* @__PURE__ */ __name((val, serializer) => "!Set:" + serializer(Array.from(val.values())), "serialize"),
        deserialize: /* @__PURE__ */ __name((str, parser) => new Set(parser(str.slice("!Set:".length))), "deserialize")
      }),
      // Avoid collisions with the special strings defined above
      ts({
        is: /* @__PURE__ */ __name((val) => typeof val === "string" && val.startsWith("!"), "is"),
        match: /* @__PURE__ */ __name((str) => str.startsWith("!"), "match"),
        serialize: /* @__PURE__ */ __name((val) => "!" + val, "serialize"),
        deserialize: /* @__PURE__ */ __name((str) => str.slice(1), "deserialize")
      })
    ];
    __name(ts, "ts");
  }
});

// node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/utils/isReactElement.js
function isReactElement(value) {
  return typeof value === "object" && value !== null && String(value["$$typeof"]) === "Symbol(react.element)";
}
var init_isReactElement = __esm({
  "node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/utils/isReactElement.js"() {
    __name(isReactElement, "isReactElement");
  }
});

// node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/utils/isCallable.js
function isCallable2(thing) {
  return thing instanceof Function || typeof thing === "function";
}
var init_isCallable2 = __esm({
  "node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/utils/isCallable.js"() {
    __name(isCallable2, "isCallable");
  }
});

// node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/utils/isObject.js
function isObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (Array.isArray(value)) {
    return false;
  }
  return true;
}
var init_isObject2 = __esm({
  "node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/utils/isObject.js"() {
    __name(isObject2, "isObject");
  }
});

// node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/utils/replacerWithPath.js
function replacerWithPath(replacer) {
  const pathMap = /* @__PURE__ */ new WeakMap();
  return function(key, value) {
    const pathPrevious = pathMap.get(this) ?? [];
    const path = [...pathPrevious];
    if (key !== "") {
      const pathEntry = !Array.isArray(this) ? key : parseInt(key, 10);
      path.push(pathEntry);
    }
    if (isIterable(value))
      pathMap.set(value, path);
    return replacer.call(this, key, value, path);
  };
}
function isIterable(value) {
  return value === Object(value);
}
var init_replacerWithPath = __esm({
  "node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/utils/replacerWithPath.js"() {
    __name(replacerWithPath, "replacerWithPath");
    __name(isIterable, "isIterable");
  }
});

// node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/stringify.js
function stringify(value, { forbidReactElements, space, valueName, sortObjectKeys, replacer: replacerUserProvided } = {}) {
  const serializer = /* @__PURE__ */ __name((val) => JSON.stringify(val, replacerWithPath(replacer), space), "serializer");
  return serializer(value);
  function replacer(key, valueAfterJSON, path) {
    const valueOriginal = this[key];
    let value2 = valueOriginal;
    {
      const ret = replacerUserProvided?.call(this, key, valueAfterJSON, serializer);
      if (ret) {
        value2 = ret.replacement;
        if (ret.resolved !== false)
          return value2;
      }
    }
    if (forbidReactElements && isReactElement(value2)) {
      throw genErr({
        value: value2,
        valueType: "React element",
        path,
        rootValueName: valueName
      });
    }
    if (isCallable2(value2)) {
      const functionName = value2.name;
      throw genErr({
        value: value2,
        valueType: "function",
        path,
        rootValueName: valueName,
        problematicValueName: path.length === 0 ? functionName : void 0
      });
    }
    for (const { is, serialize } of types.slice().reverse()) {
      if (is(value2)) {
        return serialize(value2, serializer);
      }
    }
    if (sortObjectKeys && isObject2(value2)) {
      const copy2 = {};
      Object.keys(value2).sort().forEach((key2) => {
        copy2[key2] = value2[key2];
      });
      value2 = copy2;
    }
    return value2;
  }
  __name(replacer, "replacer");
}
function genErr({ value, valueType, path, rootValueName, problematicValueName }) {
  const subjectName = getSubjectName({ path, rootValueName, problematicValueName });
  const messageCore = `cannot serialize ${subjectName} because it's a ${valueType}`;
  const err = new Error(`[@brillout/json-serializer](https://github.com/brillout/json-serializer) ${messageCore}.`);
  const pathString = getPathString(path, true);
  const errAddendum = {
    [stamp]: true,
    messageCore,
    value,
    path,
    pathString,
    subjectName
  };
  Object.assign(err, errAddendum);
  return err;
}
function isJsonSerializerError(thing) {
  return isObject2(thing) && thing[stamp] === true;
}
function getSubjectName({ path, rootValueName, problematicValueName }) {
  const pathString = getPathString(path, !rootValueName);
  let subjectName;
  if (!pathString) {
    subjectName = rootValueName || problematicValueName || "value";
  } else {
    if (problematicValueName) {
      subjectName = problematicValueName + " at ";
    } else {
      subjectName = "";
    }
    subjectName = subjectName + (rootValueName || "") + pathString;
  }
  return subjectName;
}
function getPathString(path, canBeFirstKey) {
  const pathString = path.map((key, i) => {
    if (typeof key === "number") {
      return `[${key}]`;
    }
    if (i === 0 && canBeFirstKey && isKeyDotNotationCompatible2(key)) {
      return key;
    }
    return getPropAccessNotation2(key);
  }).join("");
  return pathString;
}
function getPropAccessNotation2(key) {
  return typeof key === "string" && isKeyDotNotationCompatible2(key) ? `.${key}` : `[${JSON.stringify(key)}]`;
}
function isKeyDotNotationCompatible2(key) {
  return /^[a-z0-9\$_]+$/i.test(key);
}
var stamp;
var init_stringify = __esm({
  "node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/stringify.js"() {
    init_types();
    init_isReactElement();
    init_isCallable2();
    init_isObject2();
    init_replacerWithPath();
    __name(stringify, "stringify");
    __name(genErr, "genErr");
    stamp = "_isJsonSerializerError";
    __name(isJsonSerializerError, "isJsonSerializerError");
    __name(getSubjectName, "getSubjectName");
    __name(getPathString, "getPathString");
    __name(getPropAccessNotation2, "getPropAccessNotation");
    __name(isKeyDotNotationCompatible2, "isKeyDotNotationCompatible");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/addIs404ToPageProps.js
function addIs404ToPageProps(pageContext) {
  addIs404(pageContext);
}
function addIs404(pageContext) {
  if (pageContext.is404 === void 0 || pageContext.is404 === null)
    return;
  const pageProps = pageContext.pageProps || {};
  if (!isObject(pageProps)) {
    assertWarning2(false, "pageContext.pageProps should be an object", { showStackTrace: true, onlyOnce: true });
    return;
  }
  pageProps.is404 = pageProps.is404 || pageContext.is404;
  pageContext.pageProps = pageProps;
}
var init_addIs404ToPageProps = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/addIs404ToPageProps.js"() {
    init_utils();
    __name(addIs404ToPageProps, "addIs404ToPageProps");
    __name(addIs404, "addIs404");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/NOT_SERIALIZABLE.js
var NOT_SERIALIZABLE;
var init_NOT_SERIALIZABLE = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/NOT_SERIALIZABLE.js"() {
    NOT_SERIALIZABLE = "__VIKE__NOT_SERIALIZABLE__";
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/misc/pageContextInitIsPassedToClient.js
var pageContextInitIsPassedToClient;
var init_pageContextInitIsPassedToClient = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/misc/pageContextInitIsPassedToClient.js"() {
    pageContextInitIsPassedToClient = "_pageContextInitIsPassedToClient";
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/misc/isServerSideError.js
var isServerSideError;
var init_isServerSideError = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/misc/isServerSideError.js"() {
    isServerSideError = "_isServerSideError";
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/propKeys.js
function getPropVal(obj, prop) {
  const keys = getPropKeys(prop);
  let value = obj;
  for (const key of keys) {
    if (isObject(value) && key in value) {
      value = value[key];
    } else {
      return null;
    }
  }
  return { value };
}
function setPropVal(obj, prop, val) {
  const keys = getPropKeys(prop);
  let currentObj = obj;
  for (let i = 0; i <= keys.length - 2; i++) {
    const key = keys[i];
    if (!(key in currentObj)) {
      currentObj[key] = {};
    }
    if (!isObject(currentObj[key])) {
      return;
    }
    currentObj = currentObj[key];
  }
  const finalKey = keys[keys.length - 1];
  currentObj[finalKey] = val;
}
function getPropKeys(prop) {
  return prop.split(/(?<!\\)\./).map((key) => key.replace(/\\\./g, "."));
}
var init_propKeys = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/propKeys.js"() {
    init_utils3();
    __name(getPropVal, "getPropVal");
    __name(setPropVal, "setPropVal");
    __name(getPropKeys, "getPropKeys");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/serializeContext.js
function getPageContextClientSerialized(pageContext, isHtmlJsonScript) {
  const passToClientPageContext = getPassToClientPageContext(pageContext);
  const res = applyPassToClient(passToClientPageContext, pageContext);
  const pageContextClient = res.objClient;
  const pageContextClientProps = res.objClientProps;
  if (pageContextClientProps.some((prop) => getPropVal(pageContext._pageContextInit, prop))) {
    pageContextClient[pageContextInitIsPassedToClient] = true;
  }
  const pageContextClientSerialized = serializeObject(pageContextClient, passToClientPageContext, "pageContext", isHtmlJsonScript);
  return pageContextClientSerialized;
}
function getGlobalContextClientSerialized(pageContext, isHtmlJsonScript) {
  const passToClient = pageContext._passToClient;
  const globalContext = pageContext._globalContext;
  const res = applyPassToClient(passToClient, globalContext);
  const globalContextClient = res.objClient;
  const globalContextClientSerialized = serializeObject(globalContextClient, passToClient, "globalContext", isHtmlJsonScript);
  return globalContextClientSerialized;
}
function serializeObject(obj, passToClient, objName, isHtmlJsonScript) {
  let serialized;
  try {
    serialized = serializeValue(obj, isHtmlJsonScript);
  } catch (err) {
    const h = /* @__PURE__ */ __name((s) => picocolors_default.cyan(s), "h");
    let hasWarned = false;
    const propsNonSerializable = [];
    passToClient.forEach((prop) => {
      const res = getPropVal(obj, prop);
      if (!res)
        return;
      const { value } = res;
      const varName = `${objName}${getPropKeys(prop).map(getPropAccessNotation).join("")}`;
      try {
        serializeValue(value, isHtmlJsonScript, varName);
      } catch (err2) {
        propsNonSerializable.push(prop);
        if (prop === "_configFromHook") {
          let pathString = "";
          if (isJsonSerializerError(err2)) {
            pathString = err2.pathString;
          }
          assertUsage(false, `Cannot serialize config value ${h(pathString)} set by useConfig()`);
        }
        let msg = [
          `${h(varName)} can't be serialized and, therefore, can't be passed to the client side.`,
          `Make sure ${h(varName)} is serializable, or remove ${h(JSON.stringify(prop))} from ${h("passToClient")}.`
        ].join(" ");
        if (isJsonSerializerError(err2)) {
          msg = `${msg} Serialization error: ${err2.messageCore}.`;
        } else {
          console.warn("Serialization error:");
          console.warn(err2);
          msg = `${msg} The serialization failed because of the error printed above.`;
        }
        assertWarning2(false, msg, { onlyOnce: false });
        hasWarned = true;
      }
    });
    assert(hasWarned);
    propsNonSerializable.forEach((prop) => {
      obj[getPropKeys(prop)[0]] = NOT_SERIALIZABLE;
    });
    try {
      serialized = serializeValue(obj, isHtmlJsonScript);
    } catch (err2) {
      assert(false);
    }
  }
  return serialized;
}
function serializeValue(value, isHtmlJsonScript, varName) {
  return stringify(value, {
    forbidReactElements: true,
    valueName: varName,
    // Prevent Google from crawling URLs in JSON:
    // - https://github.com/vikejs/vike/pull/2603
    // - https://github.com/brillout/json-serializer/blob/38edbb9945de4938da1e65d6285ce1dd123a45ef/test/main.spec.ts#L44-L95
    replacer: !isHtmlJsonScript ? void 0 : (_key, value2) => {
      if (typeof value2 === "string") {
        return { replacement: value2.replaceAll("/", "\\/"), resolved: false };
      }
    }
  });
}
function getPassToClientPageContext(pageContext) {
  let passToClient = [...pageContext._passToClient, ...passToClientBuiltInPageContext];
  if (isErrorPage(pageContext.pageId, pageContext._globalContext._pageConfigs)) {
    assert(hasProp(pageContext, "is404", "boolean"));
    addIs404ToPageProps(pageContext);
    passToClient.push(...pageToClientBuiltInPageContextError);
  }
  passToClient = unique(passToClient);
  return passToClient;
}
function getPageContextClientSerializedAbort(pageContext, isHtmlJsonScript) {
  assert(pageContext._urlRedirect || pageContext._urlRewrite || pageContext.abortStatusCode);
  assert(pageContext._abortCall);
  assert(pageContext._abortCaller);
  delete pageContext._abortCaller;
  const unknownProps = Object.keys(pageContext).filter((prop) => ![
    // prettier-ignore
    // biome-ignore format:
    "_abortCall",
    /* Not needed on the client-side
    '_abortCaller',
    */
    "_urlRedirect",
    "_urlRewrite",
    "abortStatusCode",
    "abortReason",
    "is404",
    "pageProps"
  ].includes(prop));
  if (!pageContext._isLegacyRenderErrorPage) {
    assert(unknownProps.length === 0);
  } else {
    assertWarning2(unknownProps.length === 0, [
      "The following pageContext values won't be available on the client-side:",
      unknownProps.map((p2) => `  pageContext[${JSON.stringify(p2)}]`),
      "Use `throw render()` instead of `throw RenderErrorPage()`"
    ].join("\n"), {
      onlyOnce: false
    });
  }
  return serializeValue(pageContext, isHtmlJsonScript);
}
function applyPassToClient(passToClient, obj) {
  const objClient = {};
  const objClientProps = [];
  passToClient.forEach((prop) => {
    const res = getPropVal(obj, prop);
    if (!res)
      return;
    const { value } = res;
    setPropVal(objClient, prop, value);
    objClientProps.push(prop);
  });
  return { objClient, objClientProps };
}
var passToClientBuiltInPageContext, pageToClientBuiltInPageContextError;
var init_serializeContext = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/serializeContext.js"() {
    init_stringify();
    init_utils3();
    init_error_page();
    init_addIs404ToPageProps();
    init_picocolors();
    init_NOT_SERIALIZABLE();
    init_pageContextInitIsPassedToClient();
    init_isServerSideError();
    init_propKeys();
    passToClientBuiltInPageContext = [
      "abortReason",
      "_urlRewrite",
      "_urlRedirect",
      "abortStatusCode",
      "_abortCall",
      /* Not needed on the client-side
      '_abortCaller',
      */
      pageContextInitIsPassedToClient,
      "pageId",
      "routeParams",
      "data"
      // for data() hook
    ];
    pageToClientBuiltInPageContextError = ["pageProps", "is404", isServerSideError];
    __name(getPageContextClientSerialized, "getPageContextClientSerialized");
    __name(getGlobalContextClientSerialized, "getGlobalContextClientSerialized");
    __name(serializeObject, "serializeObject");
    __name(serializeValue, "serializeValue");
    __name(getPassToClientPageContext, "getPassToClientPageContext");
    __name(getPageContextClientSerializedAbort, "getPageContextClientSerializedAbort");
    __name(applyPassToClient, "applyPassToClient");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/sanitizeJson.js
function sanitizeJson(unsafe) {
  const safe = unsafe.replace(/</g, "\\u003c");
  return safe;
}
var init_sanitizeJson = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/sanitizeJson.js"() {
    __name(sanitizeJson, "sanitizeJson");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/inferHtmlTags.js
function inferPreloadTag(pageAsset) {
  const { src, assetType, mediaType } = pageAsset;
  const rel = getRel(pageAsset);
  const attributes = [
    `rel="${rel}"`,
    `href="${src}"`,
    !assetType ? null : `as="${assetType}"`,
    !mediaType ? null : `type="${mediaType}"`,
    // `crossorigin` is needed for fonts, see https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload#cors-enabled_fetches
    !isCrossOrigin(pageAsset) ? null : "crossorigin"
  ].filter(Boolean).join(" ");
  return `<link ${attributes}>`;
}
function inferAssetTag(pageAsset) {
  const { src, assetType, mediaType } = pageAsset;
  if (assetType === "script") {
    assert(mediaType === "text/javascript");
    return `<script src="${src}" ${scriptAttrs}><\/script>`;
  }
  if (assetType === "style") {
    return `<link rel="stylesheet" type="text/css" href="${src}">`;
  }
  assert(false, { pageAsset });
}
function inferEarlyHintLink(pageAsset) {
  const { src, assetType } = pageAsset;
  const rel = getRel(pageAsset);
  return [`<${src}>`, `rel=${rel}`, !assetType ? null : `as=${assetType}`].filter(Boolean).join("; ");
}
function getRel({ assetType }) {
  if (assetType === "script") {
    return "modulepreload";
  }
  return "preload";
}
function isCrossOrigin({ src, assetType }) {
  return assetType === "font" || src.startsWith("http://") || src.startsWith("https://");
}
var scriptAttrs;
var init_inferHtmlTags = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/inferHtmlTags.js"() {
    init_utils3();
    scriptAttrs = 'type="module" async';
    __name(inferPreloadTag, "inferPreloadTag");
    __name(inferAssetTag, "inferAssetTag");
    __name(inferEarlyHintLink, "inferEarlyHintLink");
    __name(getRel, "getRel");
    __name(isCrossOrigin, "isCrossOrigin");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/mergeScriptTags.js
function mergeScriptTags(scriptTagsHtml) {
  let scriptTag = "";
  const scripts = parseScripts(scriptTagsHtml);
  {
    const scriptsModule = scripts.filter(({ isModule }) => isModule);
    if (scriptsModule.length === 1) {
      scriptTag += scriptsModule[0].outerHtml;
    } else {
      const contents = [];
      scriptsModule.forEach(({ src, innerHtml }) => {
        const hasInnerHtml = !!innerHtml.trim();
        if (src) {
          assert(!hasInnerHtml);
          contents.push(`import(${JSON.stringify(src)});`);
        } else if (hasInnerHtml) {
          innerHtml = innerHtml.split("\n").filter(Boolean).join("\n");
          contents.push(innerHtml);
        }
      });
      if (contents.length > 0) {
        scriptTag += `<script ${scriptAttrs}>
${contents.join("\n")}
<\/script>`;
      }
    }
  }
  {
    const scriptsES5 = scripts.filter(({ isModule }) => !isModule);
    scriptsES5.forEach(({ outerHtml }) => {
      scriptTag += outerHtml;
    });
  }
  return scriptTag;
}
function parseScripts(htmlString) {
  const scripts = [];
  let match;
  while (match = scriptRE.exec(htmlString)) {
    const [outerHtml, openTag, innerHtml] = match;
    assert(outerHtml && openTag && innerHtml !== void 0);
    let isModule = false;
    {
      const typeMatch = openTag.match(typeRE);
      const type2 = typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3]);
      isModule = type2 === "module";
    }
    let src = null;
    {
      const srcMatch = openTag.match(srcRE);
      src = srcMatch && (srcMatch[1] || srcMatch[2] || srcMatch[3]) || "";
    }
    scripts.push({ isModule, src, innerHtml, outerHtml });
  }
  return scripts;
}
var scriptRE, srcRE, typeRE;
var init_mergeScriptTags = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/mergeScriptTags.js"() {
    init_utils3();
    init_inferHtmlTags();
    scriptRE = /(<script\b(?:\s[^>]*>|>))(.*?)<\/script>/gims;
    srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
    typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
    __name(mergeScriptTags, "mergeScriptTags");
    __name(parseScripts, "parseScripts");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/helpers.js
function getPageConfig(pageId, pageConfigs) {
  const pageConfig = pageConfigs.find((p2) => p2.pageId === pageId);
  assert(pageConfigs.length > 0);
  assert(pageConfig);
  return pageConfig;
}
function getConfigValueFilePathToShowToUser(definedAtData) {
  if (!definedAtData || isArray(definedAtData) || definedAtData.definedBy)
    return null;
  const { filePathToShowToUser } = definedAtData;
  assert(filePathToShowToUser);
  return filePathToShowToUser;
}
function getHookFilePathToShowToUser(definedAtData) {
  const filePathToShowToUser = getConfigValueFilePathToShowToUser(definedAtData);
  assert(filePathToShowToUser);
  return filePathToShowToUser;
}
var init_helpers = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/helpers.js"() {
    init_utils();
    __name(getPageConfig, "getPageConfig");
    __name(getConfigValueFilePathToShowToUser, "getConfigValueFilePathToShowToUser");
    __name(getHookFilePathToShowToUser, "getHookFilePathToShowToUser");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/getExportPath.js
function getExportPath(fileExportPathToShowToUser, configName) {
  if (!fileExportPathToShowToUser)
    return null;
  let [exportName, ...exportObjectPath] = fileExportPathToShowToUser;
  if (!exportName)
    return null;
  if (exportObjectPath.length === 0 && ["*", "default", configName].includes(exportName))
    return null;
  assert(exportName !== "*");
  let prefix3 = "";
  let suffix = "";
  if (exportName === "default") {
    prefix3 = "export default";
  } else {
    prefix3 = "export";
    exportObjectPath = [exportName, ...exportObjectPath];
  }
  exportObjectPath.forEach((prop) => {
    prefix3 = `${prefix3} { ${prop}`;
    suffix = ` }${suffix}`;
  });
  const exportPath = prefix3 + suffix;
  return exportPath;
}
var init_getExportPath = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/getExportPath.js"() {
    init_utils();
    __name(getExportPath, "getExportPath");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/getConfigDefinedAt.js
function getConfigDefinedAt(sentenceBegin, configName, definedAtData) {
  return `${begin(sentenceBegin, configName)} at ${getDefinedAtString(definedAtData, configName)}`;
}
function getConfigDefinedAtOptional(sentenceBegin, configName, definedAtData) {
  if (!definedAtData) {
    return `${begin(sentenceBegin, configName)} internally`;
  } else {
    return `${begin(sentenceBegin, configName)} at ${getDefinedAtString(definedAtData, configName)}`;
  }
}
function begin(sentenceBegin, configName) {
  return `${sentenceBegin} ${picocolors_default.cyan(configName)} defined`;
}
function getDefinedAtString(definedAtData, configName) {
  let files;
  if (isArray(definedAtData)) {
    files = definedAtData;
  } else {
    files = [definedAtData];
  }
  assert(files.length >= 1);
  const definedAtString = files.map((definedAt) => {
    if (definedAt.definedBy)
      return getDefinedByString(definedAt, configName);
    const { filePathToShowToUser, fileExportPathToShowToUser } = definedAt;
    const exportPath = getExportPath(fileExportPathToShowToUser, configName);
    if (exportPath) {
      return `${filePathToShowToUser} > ${picocolors_default.cyan(exportPath)}`;
    } else {
      return filePathToShowToUser;
    }
  }).join(" / ");
  return definedAtString;
}
function getDefinedByString(definedAt, configName) {
  if (definedAt.definedBy === "api") {
    return `API call ${picocolors_default.cyan(`${definedAt.operation}({ vikeConfig: { ${configName} } })`)}`;
  }
  const { definedBy } = definedAt;
  if (definedBy === "cli") {
    return `CLI option ${picocolors_default.cyan(`--${configName}`)}`;
  }
  if (definedBy === "env") {
    return `environment variable ${picocolors_default.cyan(`VIKE_CONFIG="{${configName}}"`)}`;
  }
  checkType(definedBy);
  assert(false);
}
var init_getConfigDefinedAt = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/getConfigDefinedAt.js"() {
    init_utils();
    init_picocolors();
    init_getExportPath();
    __name(getConfigDefinedAt, "getConfigDefinedAt");
    __name(getConfigDefinedAtOptional, "getConfigDefinedAtOptional");
    __name(begin, "begin");
    __name(getDefinedAtString, "getDefinedAtString");
    __name(getDefinedByString, "getDefinedByString");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/getConfigValueTyped.js
function getConfigValueTyped(configValue, configName, type2) {
  const { value, definedAtData } = configValue;
  if (type2)
    assertConfigValueType(value, type2, configName, definedAtData);
  return configValue;
}
function assertConfigValueType(value, type2, configName, definedAtData) {
  assert(value !== null);
  const typeActual = typeof value;
  if (typeActual === type2)
    return;
  const valuePrintable = getValuePrintable(value);
  const problem = valuePrintable !== null ? `value ${picocolors_default.cyan(valuePrintable)}` : `type ${picocolors_default.cyan(typeActual)}`;
  const configDefinedAt = getConfigDefinedAtOptional("Config", configName, definedAtData);
  const errMsg = `${configDefinedAt} has an invalid ${problem}: it should be a ${picocolors_default.cyan(type2)} instead`;
  assertUsage(false, errMsg);
}
var init_getConfigValueTyped = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/getConfigValueTyped.js"() {
    init_utils();
    init_picocolors();
    init_getConfigDefinedAt();
    __name(getConfigValueTyped, "getConfigValueTyped");
    __name(assertConfigValueType, "assertConfigValueType");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/getConfigValueRuntime.js
function getConfigValueRuntime(pageConfig, configName, type2) {
  const configValue = pageConfig.configValues[configName];
  if (!configValue)
    return null;
  return getConfigValueTyped(configValue, configName, type2);
}
var init_getConfigValueRuntime = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/getConfigValueRuntime.js"() {
    init_getConfigValueTyped();
    __name(getConfigValueRuntime, "getConfigValueRuntime");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/htmlElementIds.js
var htmlElementId_pageContext, htmlElementId_globalContext;
var init_htmlElementIds = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/htmlElementIds.js"() {
    htmlElementId_pageContext = "vike_pageContext";
    htmlElementId_globalContext = "vike_globalContext";
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/isFontFallback.js
function isFontFallback(asset, pageAssets) {
  if (asset.assetType !== "font") {
    return false;
  }
  const fontUrlBase = removeFileExtensionAndHash(asset.src);
  return pageAssets.some((assetOther) => {
    return assetOther.assetType === "font" && removeFileExtensionAndHash(assetOther.src) === fontUrlBase;
  });
}
function removeFileExtensionAndHash(assetUrl) {
  assert(!assetUrl.includes("\\"));
  assert(!assetUrl.endsWith(".js"));
  const paths2 = assetUrl.split("/");
  {
    const filename = paths2[paths2.length - 1];
    const filenameParts = filename.split(".");
    assert(filenameParts.length >= 2);
    const filenameBase = filenameParts.slice(0, filenameParts.length === 2 ? -1 : -2);
    assert(filenameBase.length >= 1);
    paths2[paths2.length - 1] = filenameBase.join(".");
  }
  return paths2.join("/");
}
var init_isFontFallback = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/isFontFallback.js"() {
    init_assert();
    __name(isFontFallback, "isFontFallback");
    __name(removeFileExtensionAndHash, "removeFileExtensionAndHash");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/getHtmlTags.js
async function getHtmlTags(pageContext, streamFromReactStreamingPackage, injectFilter, pageAssets, viteDevScript, isStream2) {
  assert([true, false].includes(pageContext._isHtmlOnly));
  const isHtmlOnly = pageContext._isHtmlOnly;
  const { _isProduction: isProduction2 } = pageContext._globalContext;
  const injectScriptsAt = getInjectScriptsAt(pageContext.pageId, pageContext._globalContext._pageConfigs);
  const injectFilterEntries = [];
  pageAssets.filter((asset) => {
    if (asset.isEntry && asset.assetType === "script") {
      return false;
    }
    return true;
  }).forEach((asset) => {
    const inject = (() => {
      if (!isProduction2) {
        return "HTML_BEGIN";
      }
      if (asset.assetType === "style") {
        return "HTML_BEGIN";
      }
      if (asset.assetType === "font") {
        return !isFontFallback(asset, injectFilterEntries) ? "HTML_BEGIN" : false;
      }
      if (asset.assetType === "script") {
        if (isHtmlOnly)
          return false;
        return "HTML_END";
      }
      return false;
    })();
    const entry = {
      ...asset,
      inject,
      // @ts-ignore
      [stamp2]: true
    };
    injectFilterEntries.push(entry);
  });
  assertInjectFilterEntries(injectFilterEntries);
  if (injectFilter && isProduction2) {
    Object.seal(injectFilterEntries);
    Object.values(injectFilterEntries).forEach((entry) => freezePartial(entry, { inject: /* @__PURE__ */ __name((val) => val === false || val === "HTML_BEGIN" || val === "HTML_END", "inject") }));
    const res = injectFilter(injectFilterEntries);
    assertUsage(res === void 0, `injectFilter() should return ${picocolors_default.cyan("undefined")}, see https://vike.dev/injectFilter`);
    assertInjectFilterUsage(injectFilterEntries);
  }
  const htmlTags = [];
  injectFilterEntries.filter((asset) => asset.assetType !== "script" && asset.inject).forEach((asset) => {
    if (!asset.inject)
      return;
    const htmlTag = asset.isEntry ? inferAssetTag(asset) : inferPreloadTag(asset);
    htmlTags.push({ htmlTag, position: asset.inject });
  });
  const positionJavaScriptDefault = "HTML_END";
  const positionJavaScriptEntry = (() => {
    if (injectScriptsAt !== null) {
      if (pageContext._pageContextPromise) {
        assertWarning2(injectScriptsAt === "HTML_END" || !isStream2, `You're setting injectScriptsAt to ${picocolors_default.code(JSON.stringify(injectScriptsAt))} while using HTML streaming with a pageContext promise (https://vike.dev/streaming#initial-data-after-stream-end) which is contradictory: the pageContext promise is skipped.`, { onlyOnce: true });
      }
      if (injectScriptsAt === "HTML_STREAM" && !isStream2) {
        return positionJavaScriptDefault;
      }
      return injectScriptsAt;
    }
    if (pageContext._pageContextPromise) {
      return positionJavaScriptDefault;
    }
    if (streamFromReactStreamingPackage && !streamFromReactStreamingPackage.hasStreamEnded()) {
      return "HTML_STREAM";
    }
    return positionJavaScriptDefault;
  })();
  if (pageContext._pageContextPromise && streamFromReactStreamingPackage) {
    assertWarning2(false, "We recommend against using HTML streaming and a pageContext promise (https://vike.dev/streaming#initial-data-after-stream-end) at the same time, because progressive hydration (https://vike.dev/streaming#progressive-rendering) won't work.", { onlyOnce: true });
  }
  if (!isHtmlOnly) {
    htmlTags.push({
      htmlTag: /* @__PURE__ */ __name(() => (
        // Needs to be called after resolvePageContextPromise()
        getPageContextJsonScriptTag(pageContext)
      ), "htmlTag"),
      position: positionJavaScriptEntry
    });
    htmlTags.push({
      htmlTag: /* @__PURE__ */ __name(() => (
        // Needs to be called after resolvePageContextPromise()
        getGlobalContextJsonScriptTag(pageContext)
      ), "htmlTag"),
      position: positionJavaScriptEntry
    });
  }
  const scriptEntry = mergeScriptEntries(pageAssets, viteDevScript);
  if (scriptEntry) {
    htmlTags.push({
      htmlTag: scriptEntry,
      position: positionJavaScriptEntry
    });
  }
  injectFilterEntries.filter((asset) => asset.assetType === "script").forEach((asset) => {
    assert(!asset.isEntry);
    const htmlTag = inferPreloadTag(asset);
    if (!asset.inject)
      return;
    const position = asset.inject === "HTML_END" ? positionJavaScriptEntry : asset.inject;
    htmlTags.push({ htmlTag, position });
  });
  return htmlTags;
}
function mergeScriptEntries(pageAssets, viteDevScript) {
  const scriptEntries = pageAssets.filter((pageAsset) => pageAsset.isEntry && pageAsset.assetType === "script");
  let scriptEntry = `${viteDevScript}${scriptEntries.map((asset) => inferAssetTag(asset)).join("")}`;
  scriptEntry = mergeScriptTags(scriptEntry);
  return scriptEntry;
}
function getPageContextJsonScriptTag(pageContext) {
  const pageContextClientSerialized = sanitizeJson(getPageContextClientSerialized(pageContext, true));
  const htmlTag = `<script id="${htmlElementId_pageContext}" type="application/json">${pageContextClientSerialized}<\/script>`;
  pageContext._pageContextHtmlTag = htmlTag;
  return htmlTag;
}
function getGlobalContextJsonScriptTag(pageContext) {
  const globalContextClientSerialized = sanitizeJson(getGlobalContextClientSerialized(pageContext, true));
  const htmlTag = `<script id="${htmlElementId_globalContext}" type="application/json">${globalContextClientSerialized}<\/script>`;
  return htmlTag;
}
function assertInjectFilterEntries(injectFilterEntries) {
  try {
    checkForWrongUsage(injectFilterEntries);
  } catch (err) {
    if (err?.message.includes("[Wrong Usage]")) {
      assert(false);
    }
    throw err;
  }
}
function assertInjectFilterUsage(injectFilterEntries) {
  checkForWrongUsage(injectFilterEntries);
  checkForWarnings(injectFilterEntries);
}
function checkForWrongUsage(injectFilterEntries) {
  injectFilterEntries.forEach((entry, i) => {
    assertUsage(isObject(entry), `[injectFilter()] Entry ${i} isn't an object`);
    assertUsage(typeof entry.src === "string", `[injectFilter()] Entry ${i} is missing property ${picocolors_default.cyan("src")}`);
    assertUsage(entry[stamp2] === true, `[injectFilter()] Entry ${i} (${entry.src}) isn't the original object, see https://vike.dev/injectFilter`);
    assert([false, "HTML_BEGIN", "HTML_END"].includes(entry.inject));
    assert(entry.assetType === null || typeof entry.assetType === "string");
    assert(entry.mediaType === null || typeof entry.mediaType === "string");
    assert(typeof entry.isEntry === "boolean");
    assert(Object.keys(entry).length === 6);
  });
}
function checkForWarnings(injectFilterEntries) {
  injectFilterEntries.forEach((a) => {
    if (a.assetType === "style" && a.isEntry) {
      assertWarning2(a.inject, `[injectFilter()] We recommend against not injecting ${a.src}`, {
        onlyOnce: true
      });
    }
    if (a.assetType === "script") {
      assertWarning2(a.inject, `[injectFilter()] We recommend against not preloading JavaScript (${a.src})`, {
        onlyOnce: true
      });
    }
  });
}
function getInjectScriptsAt(pageId, pageConfigs) {
  if (pageConfigs.length === 0)
    return null;
  const pageConfig = getPageConfig(pageId, pageConfigs);
  const configValue = getConfigValueRuntime(pageConfig, "injectScriptsAt");
  if (!configValue)
    return null;
  const injectScriptsAt = configValue.value;
  assert(configValue.definedAtData);
  const configDefinedAt = getConfigDefinedAt("Config", "injectScriptsAt", configValue.definedAtData);
  assertUsage(injectScriptsAt === null || injectScriptsAt === "HTML_BEGIN" || injectScriptsAt === "HTML_END" || injectScriptsAt === "HTML_STREAM", `${configDefinedAt} has an invalid value`);
  return injectScriptsAt;
}
var stamp2;
var init_getHtmlTags = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/getHtmlTags.js"() {
    init_utils3();
    init_serializeContext();
    init_sanitizeJson();
    init_inferHtmlTags();
    init_mergeScriptTags();
    init_helpers();
    init_getConfigValueRuntime();
    init_picocolors();
    init_getConfigDefinedAt();
    init_htmlElementIds();
    init_isFontFallback();
    stamp2 = "__injectFilterEntry";
    __name(getHtmlTags, "getHtmlTags");
    __name(mergeScriptEntries, "mergeScriptEntries");
    __name(getPageContextJsonScriptTag, "getPageContextJsonScriptTag");
    __name(getGlobalContextJsonScriptTag, "getGlobalContextJsonScriptTag");
    __name(assertInjectFilterEntries, "assertInjectFilterEntries");
    __name(assertInjectFilterUsage, "assertInjectFilterUsage");
    __name(checkForWrongUsage, "checkForWrongUsage");
    __name(checkForWarnings, "checkForWarnings");
    __name(getInjectScriptsAt, "getInjectScriptsAt");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/getViteDevScript.js
async function getViteDevScript(pageContext) {
  const globalContext = pageContext._globalContext;
  if (globalContext._isProduction) {
    return "";
  }
  const { _viteDevServer: viteDevServer } = globalContext;
  const fakeHtmlBegin = "<html> <head>";
  const fakeHtmlEnd = "</head><body></body></html>";
  let fakeHtml = fakeHtmlBegin + fakeHtmlEnd;
  fakeHtml = viteDevServer ? await viteDevServer.transformIndexHtml("/", fakeHtml) : await getViteRPC().transformIndexHtmlRPC(fakeHtml);
  assertUsage(!fakeHtml.includes("vite-plugin-pwa"), `The HTML transformer of ${picocolors_default.cyan("vite-plugin-pwa")} cannot be applied, see workaround at https://github.com/vikejs/vike/issues/388#issuecomment-1199280084`);
  assertUsage(!fakeHtml.startsWith(fakeHtmlBegin.replace(" ", "")), `Vite plugins that minify the HTML cannot be applied, see https://github.com/vikejs/vike/issues/224`);
  assertUsage(fakeHtml.startsWith(fakeHtmlBegin) && fakeHtml.endsWith(fakeHtmlEnd), `You are using a Vite Plugin that transforms the HTML in a way that conflicts with Vike. ${reachOutCTA}`);
  const viteInjection = fakeHtml.slice(fakeHtmlBegin.length, -1 * fakeHtmlEnd.length);
  assert(viteInjection.includes("script"));
  assertWarning2(!viteInjection.includes("import("), `Unexpected Vite injected HMR code. ${reachOutCTA}`, {
    onlyOnce: true
  });
  const viteDevScript = viteInjection;
  return viteDevScript;
}
var reachOutCTA;
var init_getViteDevScript = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/getViteDevScript.js"() {
    init_utils3();
    init_picocolors();
    reachOutCTA = "Create a new GitHub issue to discuss a solution.";
    __name(getViteDevScript, "getViteDevScript");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets.js
async function injectHtmlTagsToString(htmlParts, pageContext, injectFilter) {
  const pageAssets = await pageContext.__getPageAssets();
  const viteDevScript = await getViteDevScript(pageContext);
  const htmlTags = await getHtmlTags(pageContext, null, injectFilter, pageAssets, viteDevScript, false);
  let htmlString = htmlPartsToString(htmlParts, pageAssets);
  htmlString = injectToHtmlBegin(htmlString, htmlTags);
  htmlString = injectToHtmlEnd(htmlString, htmlTags);
  assert(htmlTags.filter((snippet) => snippet.position === "HTML_STREAM").length === 0);
  return htmlString;
}
function injectHtmlTagsToStream(pageContext, streamFromReactStreamingPackage, injectFilter) {
  let htmlTags;
  return {
    injectAtStreamBegin,
    injectAtStreamAfterFirstChunk,
    injectAtStreamEnd
  };
  async function injectAtStreamBegin(htmlPartsBegin) {
    const pageAssets = await pageContext.__getPageAssets();
    const viteDevScript = await getViteDevScript(pageContext);
    htmlTags = await getHtmlTags(pageContext, streamFromReactStreamingPackage, injectFilter, pageAssets, viteDevScript, true);
    let htmlBegin = htmlPartsToString(htmlPartsBegin, pageAssets);
    htmlBegin = injectToHtmlBegin(htmlBegin, htmlTags);
    if (streamFromReactStreamingPackage) {
      injectHtmlTagsUsingStream(htmlTags, streamFromReactStreamingPackage);
    }
    return htmlBegin;
  }
  __name(injectAtStreamBegin, "injectAtStreamBegin");
  function injectAtStreamAfterFirstChunk() {
    if (streamFromReactStreamingPackage)
      return null;
    assert(htmlTags);
    const tags = htmlTags.filter((h) => h.position === "HTML_STREAM");
    if (tags.length === 0)
      return null;
    const htmlFragment = joinHtmlTags(tags);
    return htmlFragment;
  }
  __name(injectAtStreamAfterFirstChunk, "injectAtStreamAfterFirstChunk");
  async function injectAtStreamEnd(htmlPartsEnd) {
    assert(htmlTags);
    await resolvePageContextPromise(pageContext);
    const pageAssets = await pageContext.__getPageAssets();
    let htmlEnd = htmlPartsToString(htmlPartsEnd, pageAssets);
    htmlEnd = injectToHtmlEnd(htmlEnd, htmlTags);
    return htmlEnd;
  }
  __name(injectAtStreamEnd, "injectAtStreamEnd");
}
function injectToHtmlBegin(htmlBegin, htmlTags) {
  htmlBegin = createHtmlHeadIfMissing(htmlBegin);
  htmlBegin = injectHtmlTags(htmlBegin, htmlTags, "HTML_BEGIN");
  return htmlBegin;
}
function injectToHtmlEnd(htmlEnd, htmlTags) {
  htmlEnd = injectHtmlTags(htmlEnd, htmlTags, "HTML_END");
  return htmlEnd;
}
async function resolvePageContextPromise(pageContext) {
  const pageContextPromise = pageContext._pageContextPromise;
  if (!pageContextPromise) {
    return;
  }
  let pageContextProvidedByUser;
  if (isCallable(pageContextPromise)) {
    pageContextProvidedByUser = await pageContextPromise();
  } else if (isPromise(pageContextPromise)) {
    pageContextProvidedByUser = await pageContextPromise;
  } else {
    assert(false);
  }
  assertPageContextProvidedByUser(pageContextProvidedByUser, pageContext._renderHook);
  Object.assign(pageContext, pageContextProvidedByUser);
}
function htmlPartsToString(htmlParts, pageAssets) {
  let htmlString = "";
  htmlParts.forEach((p2) => {
    htmlString += typeof p2 === "string" ? p2 : p2(pageAssets);
  });
  return htmlString;
}
var init_injectAssets = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets.js"() {
    init_utils3();
    init_assertPageContextProvidedByUser();
    init_injectHtmlTags();
    init_getHtmlTags();
    init_getViteDevScript();
    __name(injectHtmlTagsToString, "injectHtmlTagsToString");
    __name(injectHtmlTagsToStream, "injectHtmlTagsToStream");
    __name(injectToHtmlBegin, "injectToHtmlBegin");
    __name(injectToHtmlEnd, "injectToHtmlEnd");
    __name(resolvePageContextPromise, "resolvePageContextPromise");
    __name(htmlPartsToString, "htmlPartsToString");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/stream/react-streaming.js
function streamFromReactStreamingPackageToString(stream) {
  if (stream.pipe) {
    return streamPipeNodeToString(stream.pipe);
  }
  if (stream.readable) {
    return streamReadableWebToString(stream.readable);
  }
  assert(false);
}
function isStreamFromReactStreamingPackage(thing) {
  if (hasProp(thing, "injectToStream", "function")) {
    assertUsage(hasProp(thing, "hasStreamEnded", "function"), isVikeReactApp() ? (
      //
      "Update vike-react to its latest version"
    ) : "Update react-streaming to its latest version");
    return true;
  }
  return false;
}
function getStreamOfReactStreamingPackage(stream) {
  if (stream.pipe) {
    return { __streamPipeNode: stream.pipe };
  }
  if (stream.readable) {
    return stream.readable;
  }
  assert(false);
}
var init_react_streaming = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/stream/react-streaming.js"() {
    init_utils3();
    init_stream();
    __name(streamFromReactStreamingPackageToString, "streamFromReactStreamingPackageToString");
    __name(isStreamFromReactStreamingPackage, "isStreamFromReactStreamingPackage");
    __name(getStreamOfReactStreamingPackage, "getStreamOfReactStreamingPackage");
  }
});

// node_modules/.pnpm/@brillout+import@0.2.6/node_modules/@brillout/import/dist/esm/index.js
function import_(id) {
  id = fixWindowsBug(id);
  return import(
    /*webpackIgnore: true*/
    id
  );
}
function fixWindowsBug(id) {
  if (process.platform === "win32" && isAbsolute(id) && !id.startsWith(prefix2)) {
    return prefix2 + id;
  } else {
    return id;
  }
}
function isAbsolute(path) {
  return /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/.test(path);
}
var prefix2;
var init_esm = __esm({
  "node_modules/.pnpm/@brillout+import@0.2.6/node_modules/@brillout/import/dist/esm/index.js"() {
    __name(import_, "import_");
    prefix2 = "file://";
    __name(fixWindowsBug, "fixWindowsBug");
    __name(isAbsolute, "isAbsolute");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/stream.js
function isStreamReadableWeb(thing) {
  return typeof ReadableStream !== "undefined" && thing instanceof ReadableStream;
}
function isStreamWritableWeb(thing) {
  return typeof WritableStream !== "undefined" && thing instanceof WritableStream;
}
function isStreamReadableNode(thing) {
  if (isStreamReadableWeb(thing)) {
    return false;
  }
  return hasProp(thing, "read", "function");
}
function isStreamWritableNode(thing) {
  if (isStreamWritableWeb(thing)) {
    return false;
  }
  return hasProp(thing, "write", "function");
}
async function streamReadableNodeToString(readableNode) {
  const chunks = [];
  return new Promise((resolve, reject) => {
    readableNode.on("data", (chunk3) => chunks.push(Buffer.from(chunk3)));
    readableNode.on("error", (err) => reject(err));
    readableNode.on("end", () => resolve(Buffer.concat(chunks).toString("utf8")));
  });
}
async function streamReadableWebToString(readableWeb) {
  const reader = readableWeb.getReader();
  const { decode, getClosingChunk } = decodeChunks();
  let str = "";
  while (true) {
    const { done, value } = await reader.read();
    if (done)
      break;
    str += decode(value);
  }
  str += getClosingChunk();
  return str;
}
async function stringToStreamReadableNode(str) {
  const { Readable } = await loadStreamNodeModule();
  return Readable.from(str);
}
function stringToStreamReadableWeb(str) {
  assertReadableStreamConstructor();
  const readableStream = new ReadableStream({
    start(controller) {
      controller.enqueue(encodeForWebStream(str));
      controller.close();
    }
  });
  return readableStream;
}
function stringToStreamPipeNode(str) {
  return (writable) => {
    writable.write(str);
    writable.end();
  };
}
function stringToStreamPipeWeb(str) {
  return (writable) => {
    const writer = writable.getWriter();
    writer.write(encodeForWebStream(str));
    writer.close();
  };
}
async function streamPipeNodeToString(streamPipeNode) {
  let str = "";
  let resolve;
  let reject;
  const promise = new Promise((resolve_, reject_) => {
    resolve = /* @__PURE__ */ __name(() => resolve_(str), "resolve");
    reject = reject_;
  });
  const { Writable } = await loadStreamNodeModule();
  const writable = new Writable({
    write(chunk3, _encoding, callback) {
      const s = chunk3.toString();
      assert(typeof s === "string");
      str += s;
      callback();
    },
    final(callback) {
      resolve();
      callback();
    },
    destroy(err) {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    }
  });
  streamPipeNode(writable);
  return promise;
}
function streamPipeWebToString(streamPipeWeb) {
  const { decode, getClosingChunk } = decodeChunks();
  let str = "";
  let resolve;
  const promise = new Promise((r) => resolve = r);
  const writable = new WritableStream({
    write(chunk3) {
      str += decode(chunk3);
    },
    close() {
      str += getClosingChunk();
      resolve(str);
    }
  });
  streamPipeWeb(writable);
  return promise;
}
async function getStreamReadableNode(htmlRender) {
  if (typeof htmlRender === "string") {
    return stringToStreamReadableNode(htmlRender);
  }
  if (isStreamReadableNode(htmlRender)) {
    return htmlRender;
  }
  return null;
}
function getStreamReadableWeb(htmlRender) {
  if (typeof htmlRender === "string") {
    return stringToStreamReadableWeb(htmlRender);
  }
  if (isStreamReadableWeb(htmlRender)) {
    return htmlRender;
  }
  if (isStreamPipeWeb(htmlRender)) {
    const streamPipeWeb = getStreamPipeWeb(htmlRender);
    assert(streamPipeWeb);
    const { readable, writable } = new TransformStream();
    streamPipeWeb(writable);
    return readable;
  }
  return null;
}
function pipeToStreamWritableWeb(htmlRender, writable) {
  if (typeof htmlRender === "string") {
    const streamPipeWeb = stringToStreamPipeWeb(htmlRender);
    streamPipeWeb(writable);
    return true;
  }
  if (isStreamReadableWeb(htmlRender)) {
    htmlRender.pipeTo(writable);
    return true;
  }
  if (isStreamPipeWeb(htmlRender)) {
    const streamPipeWeb = getStreamPipeWeb(htmlRender);
    assert(streamPipeWeb);
    streamPipeWeb(writable);
    return true;
  }
  if (isStreamReadableNode(htmlRender) || isStreamPipeNode(htmlRender)) {
    return false;
  }
  checkType(htmlRender);
  assert(false);
}
function pipeToStreamWritableNode(htmlRender, writable) {
  if (typeof htmlRender === "string") {
    const streamPipeNode = stringToStreamPipeNode(htmlRender);
    streamPipeNode(writable);
    return true;
  }
  if (isStreamReadableNode(htmlRender)) {
    htmlRender.pipe(writable);
    return true;
  }
  if (isStreamPipeNode(htmlRender)) {
    const streamPipeNode = getStreamPipeNode(htmlRender);
    assert(streamPipeNode);
    streamPipeNode(writable);
    return true;
  }
  if (isStreamReadableWeb(htmlRender) || isStreamPipeWeb(htmlRender)) {
    return false;
  }
  checkType(htmlRender);
  assert(false);
}
async function processStream(streamOriginal, { injectStringAtBegin, injectStringAfterFirstChunk, injectStringAtEnd, onErrorWhileStreaming, enableEagerStreaming }) {
  const buffer = [];
  let streamOriginalHasStartedEmitting = false;
  let streamOriginalEnded = false;
  let streamClosed = false;
  let onEndWasCalled = false;
  let isReadyToWrite = false;
  let wrapperCreated = false;
  let shouldFlushStream = false;
  let resolve;
  let reject;
  let promiseHasResolved = false;
  let injectStringAfterFirstChunk_done = false;
  const streamWrapperPromise = new Promise((resolve_, reject_) => {
    resolve = /* @__PURE__ */ __name((streamWrapper2) => {
      promiseHasResolved = true;
      resolve_(streamWrapper2);
    }, "resolve");
    reject = /* @__PURE__ */ __name((err) => {
      promiseHasResolved = true;
      reject_(err);
    }, "reject");
  });
  let resolveReadyToWrite;
  const promiseReadyToWrite = new Promise((r) => resolveReadyToWrite = r);
  if (injectStringAtBegin) {
    const injectedChunk = await injectStringAtBegin();
    writeStream(injectedChunk);
    flushStream();
  }
  const onStreamDataOrEnd = /* @__PURE__ */ __name((cb) => {
    assert(streamOriginalEnded === false);
    streamOriginalHasStartedEmitting = true;
    cb();
    if (wrapperCreated)
      resolvePromise();
  }, "onStreamDataOrEnd");
  const { streamWrapper, streamWrapperOperations } = await createStreamWrapper({
    streamOriginal,
    onReadyToWrite() {
      debug4("stream begin");
      isReadyToWrite = true;
      flushBuffer();
      resolveReadyToWrite();
    },
    onError(err) {
      if (!promiseHasResolved) {
        reject(err);
      } else {
        onErrorWhileStreaming(err);
      }
    },
    onData(chunk3) {
      onStreamDataOrEnd(() => {
        writeStream(chunk3);
        if (injectStringAfterFirstChunk && !injectStringAfterFirstChunk_done) {
          const injectedChunk = injectStringAfterFirstChunk();
          if (injectedChunk !== null)
            writeStream(injectedChunk);
          injectStringAfterFirstChunk_done = true;
        }
      });
    },
    async onEnd(isCancel) {
      try {
        assert(!onEndWasCalled);
        onEndWasCalled = true;
        debug4("stream end");
        onStreamDataOrEnd(() => {
          streamOriginalEnded = true;
        });
        if (injectStringAtEnd) {
          const injectedChunk = await injectStringAtEnd();
          writeStream(injectedChunk);
        }
        await promiseReadyToWrite;
        assert(isReady());
        flushBuffer();
        streamClosed = true;
        debug4("stream ended");
      } catch (err) {
        if (!isBug(err)) {
          console.error(err);
          assert(false);
        }
        throw err;
      }
    },
    onFlush() {
      flushStream();
    }
  });
  wrapperCreated = true;
  flushBuffer();
  if (!delayStreamStart())
    resolvePromise();
  return streamWrapperPromise;
  function writeStream(chunk3) {
    buffer.push(chunk3);
    flushBuffer();
  }
  __name(writeStream, "writeStream");
  function flushBuffer() {
    if (!isReady())
      return;
    assert(!streamClosed);
    buffer.forEach((chunk3) => {
      streamWrapperOperations.writeChunk(chunk3);
    });
    buffer.length = 0;
    if (shouldFlushStream)
      flushStream();
  }
  __name(flushBuffer, "flushBuffer");
  function resolvePromise() {
    assert(!delayStreamStart());
    assert(wrapperCreated);
    debug4("stream promise resolved");
    resolve(streamWrapper);
  }
  __name(resolvePromise, "resolvePromise");
  function flushStream() {
    if (!isReady()) {
      shouldFlushStream = true;
      return;
    }
    if (streamWrapperOperations.flushStream === null)
      return;
    streamWrapperOperations.flushStream();
    shouldFlushStream = false;
    debug4("stream flushed");
  }
  __name(flushStream, "flushStream");
  function isReady() {
    return isReadyToWrite && // We can't use streamWrapperOperations.writeChunk() if it isn't defined yet
    wrapperCreated && // See comment below
    !delayStreamStart();
  }
  __name(isReady, "isReady");
  function delayStreamStart() {
    return !enableEagerStreaming && !streamOriginalHasStartedEmitting;
  }
  __name(delayStreamStart, "delayStreamStart");
}
async function createStreamWrapper({ streamOriginal, onError, onData, onEnd, onFlush, onReadyToWrite }) {
  if (isStreamFromReactStreamingPackage(streamOriginal)) {
    debug4(`onRenderHtml() hook returned ${picocolors_default.cyan("react-streaming")} result`);
    const stream = getStreamOfReactStreamingPackage(streamOriginal);
    streamOriginal = stream;
  }
  if (isStreamPipeNode(streamOriginal)) {
    debug4("onRenderHtml() hook returned Node.js Stream Pipe");
    let writableOriginal = null;
    const pipeProxy = /* @__PURE__ */ __name((writable_) => {
      writableOriginal = writable_;
      debug4("original Node.js Writable received");
      onReadyToWrite();
      if (hasEnded) {
        writableOriginal.end();
      }
    }, "pipeProxy");
    stampPipe(pipeProxy, "node-stream");
    const writeChunk = /* @__PURE__ */ __name((chunk3) => {
      assert(writableOriginal);
      writableOriginal.write(chunk3);
      debugWithChunk("data written (Node.js Writable)", chunk3);
    }, "writeChunk");
    const flushStream = /* @__PURE__ */ __name(() => {
      assert(writableOriginal);
      if (typeof writableOriginal.flush === "function") {
        writableOriginal.flush();
        debug4("stream flush() performed (Node.js Writable)");
      }
    }, "flushStream");
    let hasEnded = false;
    const endStream = /* @__PURE__ */ __name(() => {
      hasEnded = true;
      if (writableOriginal) {
        writableOriginal.end();
      }
    }, "endStream");
    const { Writable } = await loadStreamNodeModule();
    const writableProxy = new Writable({
      async write(chunk3, _encoding, callback) {
        onData(chunk3);
        callback();
      },
      async destroy(err, callback) {
        if (err) {
          onError(err);
        } else {
          await onEnd();
        }
        callback(err);
        endStream();
      }
    });
    objectAssign(writableProxy, {
      flush: /* @__PURE__ */ __name(() => {
        onFlush();
      }, "flush")
    });
    assert(typeof writableProxy.flush === "function");
    const pipeOriginal = getStreamPipeNode(streamOriginal);
    pipeOriginal(writableProxy);
    return { streamWrapper: pipeProxy, streamWrapperOperations: { writeChunk, flushStream } };
  }
  if (isStreamPipeWeb(streamOriginal)) {
    debug4("onRenderHtml() hook returned Web Stream Pipe");
    let writerOriginal = null;
    const pipeProxy = /* @__PURE__ */ __name((writableOriginal) => {
      writerOriginal = writableOriginal.getWriter();
      debug4("original Web Writable received");
      (async () => {
        try {
          await writerOriginal.ready;
        } catch (e2) {
        }
        onReadyToWrite();
        if (hasEnded) {
          writerOriginal.close();
        }
      })();
    }, "pipeProxy");
    stampPipe(pipeProxy, "web-stream");
    const writeChunk = /* @__PURE__ */ __name((chunk3) => {
      assert(writerOriginal);
      writerOriginal.write(encodeForWebStream(chunk3));
      debugWithChunk("data written (Web Writable)", chunk3);
    }, "writeChunk");
    const flushStream = null;
    let hasEnded = false;
    const endStream = /* @__PURE__ */ __name(() => {
      hasEnded = true;
      if (writerOriginal) {
        writerOriginal.close();
      }
    }, "endStream");
    let writableProxy;
    if (typeof ReadableStream !== "function") {
      writableProxy = new WritableStream({
        write(chunk3) {
          onData(chunk3);
        },
        async close() {
          await onEnd();
          endStream();
        },
        abort(err) {
          onError(err);
          endStream();
        }
      });
    } else {
      const { readable, writable } = new TransformStream();
      writableProxy = writable;
      handleReadableWeb(readable, {
        onData,
        onError(err) {
          onError(err);
          endStream();
        },
        async onEnd() {
          await onEnd();
          endStream();
        }
      });
    }
    const pipeOriginal = getStreamPipeWeb(streamOriginal);
    pipeOriginal(writableProxy);
    return { streamWrapper: pipeProxy, streamWrapperOperations: { writeChunk, flushStream } };
  }
  if (isStreamReadableWeb(streamOriginal)) {
    debug4("onRenderHtml() hook returned Web Readable");
    const readableOriginal = streamOriginal;
    let isClosed = false;
    let isCancel = false;
    const closeStream = /* @__PURE__ */ __name(async () => {
      if (isClosed)
        return;
      await onEnd(isCancel);
      isClosed = true;
      controllerProxy.close();
    }, "closeStream");
    let controllerProxy;
    assertReadableStreamConstructor();
    const readableProxy = new ReadableStream({
      start(controller) {
        controllerProxy = controller;
        onReadyToWrite();
        handleReadableWeb(readableOriginal, {
          onData,
          onError(err) {
            onError(err);
            controllerProxy.close();
          },
          async onEnd() {
            await closeStream();
          }
        });
      },
      async cancel(...args) {
        isCancel = true;
        await readableOriginal.cancel(...args);
        await closeStream();
      }
    });
    const writeChunk = /* @__PURE__ */ __name((chunk3) => {
      if (
        // If readableOriginal doesn't implement readableOriginal.cancel() then it may still emit data after we close the stream. We therefore need to check whether the steam is closed.
        !isClosed
      ) {
        controllerProxy.enqueue(encodeForWebStream(chunk3));
        debugWithChunk("data written (Web Readable)", chunk3);
      } else {
        debugWithChunk("data emitted but not written (Web Readable)", chunk3);
      }
    }, "writeChunk");
    const flushStream = null;
    return {
      streamWrapper: readableProxy,
      streamWrapperOperations: { writeChunk, flushStream }
    };
  }
  if (isStreamReadableNode(streamOriginal)) {
    debug4("onRenderHtml() hook returned Node.js Readable");
    const readableOriginal = streamOriginal;
    const { Readable } = await loadStreamNodeModule();
    if (readableOriginal._read === Readable.prototype._read) {
      readableOriginal._read = function() {
      };
    }
    const writeChunk = /* @__PURE__ */ __name((chunk3) => {
      readableProxy.push(chunk3);
      debugWithChunk("data written (Node.js Readable)", chunk3);
    }, "writeChunk");
    const flushStream = null;
    const closeProxy = /* @__PURE__ */ __name(() => {
      readableProxy.push(null);
    }, "closeProxy");
    const readableProxy = new Readable({ read() {
    } });
    onReadyToWrite();
    readableOriginal.on("data", (chunk3) => {
      onData(chunk3);
    });
    readableOriginal.on("error", (err) => {
      onError(err);
      closeProxy();
    });
    readableOriginal.on("end", async () => {
      await onEnd();
      closeProxy();
    });
    return {
      streamWrapper: readableProxy,
      streamWrapperOperations: { writeChunk, flushStream }
    };
  }
  assert(false);
}
async function handleReadableWeb(readable, { onData, onError, onEnd }) {
  const reader = readable.getReader();
  while (true) {
    let result;
    try {
      result = await reader.read();
    } catch (err) {
      onError(err);
      return;
    }
    const { value, done } = result;
    if (done) {
      break;
    }
    onData(value);
  }
  await onEnd();
}
function isStream(something) {
  if (isStreamReadableWeb(something) || isStreamReadableNode(something) || isStreamPipeNode(something) || isStreamPipeWeb(something) || isStreamFromReactStreamingPackage(something)) {
    checkType(something);
    return true;
  }
  return false;
}
function getStreamPipeWeb(thing) {
  if (!isStreamPipeWeb(thing)) {
    return null;
  }
  if (isObject(thing)) {
    assert(__streamPipeWeb && thing);
    return thing[__streamPipeWeb];
  } else {
    assert(isCallable(thing) && "isWebStreamPipe" in thing);
    return thing;
  }
}
function isStreamPipeWeb(thing) {
  if (isObject(thing) && __streamPipeWeb in thing) {
    return true;
  }
  if (isCallable(thing) && "isWebStreamPipe" in thing) {
    return true;
  }
  return false;
}
function getStreamPipeNode(thing) {
  if (!isStreamPipeNode(thing)) {
    return null;
  }
  if (isObject(thing)) {
    assert(__streamPipeNode in thing);
    return thing[__streamPipeNode];
  } else {
    assert(isCallable(thing) && "isNodeStreamPipe" in thing);
    return thing;
  }
}
function isStreamPipeNode(thing) {
  if (isObject(thing) && __streamPipeNode in thing) {
    return true;
  }
  if (isCallable(thing) && "isNodeStreamPipe" in thing) {
    return true;
  }
  return false;
}
function stampPipe(pipe, pipeType) {
  assertUsage(pipeType, `stampPipe(pipe, pipeType): argument ${picocolors_default.cyan("pipeType")} is missing.)`, {
    showStackTrace: true
  });
  assertUsage(["web-stream", "node-stream"].includes(pipeType), `stampPipe(pipe, pipeType): argument ${picocolors_default.cyan("pipeType")} should be either ${picocolors_default.cyan("'web-stream'")} or ${picocolors_default.cyan("'node-stream'")}.`, { showStackTrace: true });
  if (pipeType === "node-stream") {
    Object.assign(pipe, { isNodeStreamPipe: true });
  } else {
    Object.assign(pipe, { isWebStreamPipe: true });
  }
}
async function streamToString(stream) {
  if (isStreamReadableWeb(stream)) {
    return await streamReadableWebToString(stream);
  }
  if (isStreamReadableNode(stream)) {
    return await streamReadableNodeToString(stream);
  }
  if (isStreamPipeNode(stream)) {
    return await streamPipeNodeToString(getStreamPipeNode(stream));
  }
  if (isStreamPipeWeb(stream)) {
    return await streamPipeWebToString(getStreamPipeWeb(stream));
  }
  if (isStreamFromReactStreamingPackage(stream)) {
    return await streamFromReactStreamingPackageToString(stream);
  }
  assert(false);
}
function assertReadableStreamConstructor() {
  assertUsage(
    typeof ReadableStream === "function",
    // Error message copied from vue's renderToWebStream() implementation
    "ReadableStream constructor isn't available in the global scope. If the target environment does support web streams, consider using pipeToWebWritable() with an existing WritableStream instance instead."
  );
}
function encodeForWebStream(thing) {
  if (!encoder) {
    encoder = new TextEncoder();
  }
  if (typeof thing === "string") {
    return encoder.encode(thing);
  }
  return thing;
}
async function loadStreamNodeModule() {
  const streamModule = (await import_("stream")).default;
  const { Readable, Writable } = streamModule;
  return { Readable, Writable };
}
function getStreamName(kind, type2) {
  let typeName = capitalizeFirstLetter(type2);
  if (typeName === "Node") {
    typeName = "Node.js";
  }
  const kindName = capitalizeFirstLetter(kind);
  if (kind !== "pipe") {
    return `a ${kindName} ${typeName} Stream`;
  }
  if (kind === "pipe") {
    return `a ${typeName} Stream Pipe`;
  }
  assert(false);
}
function inferStreamName(stream) {
  if (isStreamReadableWeb(stream)) {
    return getStreamName("readable", "web");
  }
  if (isStreamReadableNode(stream)) {
    return getStreamName("readable", "node");
  }
  if (isStreamPipeNode(stream)) {
    return getStreamName("pipe", "node");
  }
  if (isStreamPipeWeb(stream)) {
    return getStreamName("pipe", "web");
  }
  assert(false);
}
function decodeChunks() {
  const decoder = new TextDecoder();
  const decode = /* @__PURE__ */ __name((chunk3) => {
    if (typeof chunk3 === "string") {
      return chunk3;
    } else if (chunk3 instanceof Uint8Array) {
      return decoder.decode(chunk3, { stream: true });
    } else {
      assert(false);
    }
  }, "decode");
  const getClosingChunk = /* @__PURE__ */ __name(() => {
    return decoder.decode();
  }, "getClosingChunk");
  return { decode, getClosingChunk };
}
function debugWithChunk(msg, chunk3) {
  if (!debug4.isActivated)
    return;
  let chunkStr;
  try {
    chunkStr = new TextDecoder().decode(chunk3);
  } catch (err) {
    chunkStr = String(chunk3);
  }
  debug4(msg, chunkStr);
}
var debug4, __streamPipeWeb, __streamPipeNode, encoder;
var init_stream = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/stream.js"() {
    init_utils3();
    init_react_streaming();
    init_esm();
    init_picocolors();
    debug4 = createDebugger("vike:stream");
    __name(isStreamReadableWeb, "isStreamReadableWeb");
    __name(isStreamWritableWeb, "isStreamWritableWeb");
    __name(isStreamReadableNode, "isStreamReadableNode");
    __name(isStreamWritableNode, "isStreamWritableNode");
    __name(streamReadableNodeToString, "streamReadableNodeToString");
    __name(streamReadableWebToString, "streamReadableWebToString");
    __name(stringToStreamReadableNode, "stringToStreamReadableNode");
    __name(stringToStreamReadableWeb, "stringToStreamReadableWeb");
    __name(stringToStreamPipeNode, "stringToStreamPipeNode");
    __name(stringToStreamPipeWeb, "stringToStreamPipeWeb");
    __name(streamPipeNodeToString, "streamPipeNodeToString");
    __name(streamPipeWebToString, "streamPipeWebToString");
    __name(getStreamReadableNode, "getStreamReadableNode");
    __name(getStreamReadableWeb, "getStreamReadableWeb");
    __name(pipeToStreamWritableWeb, "pipeToStreamWritableWeb");
    __name(pipeToStreamWritableNode, "pipeToStreamWritableNode");
    __name(processStream, "processStream");
    __name(createStreamWrapper, "createStreamWrapper");
    __name(handleReadableWeb, "handleReadableWeb");
    __name(isStream, "isStream");
    __streamPipeWeb = "__streamPipeWeb";
    __name(getStreamPipeWeb, "getStreamPipeWeb");
    __name(isStreamPipeWeb, "isStreamPipeWeb");
    __streamPipeNode = "__streamPipeNode";
    __name(getStreamPipeNode, "getStreamPipeNode");
    __name(isStreamPipeNode, "isStreamPipeNode");
    __name(stampPipe, "stampPipe");
    __name(streamToString, "streamToString");
    __name(assertReadableStreamConstructor, "assertReadableStreamConstructor");
    __name(encodeForWebStream, "encodeForWebStream");
    __name(loadStreamNodeModule, "loadStreamNodeModule");
    __name(getStreamName, "getStreamName");
    __name(inferStreamName, "inferStreamName");
    __name(decodeChunks, "decodeChunks");
    __name(debugWithChunk, "debugWithChunk");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/renderHtml.js
function isDocumentHtml(something) {
  if (isTemplateWrapped(something) || isEscapedString(something) || isStream(something)) {
    checkType(something);
    return true;
  }
  return false;
}
async function renderDocumentHtml(documentHtml, pageContext, onErrorWhileStreaming, injectFilter) {
  if (isEscapedString(documentHtml)) {
    objectAssign(pageContext, { _isStream: false });
    let htmlString = getEscapedString(documentHtml);
    htmlString = await injectHtmlTagsToString([htmlString], pageContext, injectFilter);
    return htmlString;
  }
  if (isStream(documentHtml)) {
    objectAssign(pageContext, { _isStream: true });
    const stream = documentHtml;
    const streamWrapper = await renderHtmlStream(stream, null, pageContext, onErrorWhileStreaming, injectFilter);
    return streamWrapper;
  }
  if (isTemplateWrapped(documentHtml)) {
    const templateContent = documentHtml._template;
    const render = renderTemplate(templateContent, pageContext);
    if (!("htmlStream" in render)) {
      objectAssign(pageContext, { _isStream: false });
      const { htmlPartsAll } = render;
      const htmlString = await injectHtmlTagsToString(htmlPartsAll, pageContext, injectFilter);
      return htmlString;
    } else {
      objectAssign(pageContext, { _isStream: true });
      const { htmlStream } = render;
      const streamWrapper = await renderHtmlStream(htmlStream, {
        htmlPartsBegin: render.htmlPartsBegin,
        htmlPartsEnd: render.htmlPartsEnd
      }, pageContext, onErrorWhileStreaming, injectFilter);
      return streamWrapper;
    }
  }
  checkType(documentHtml);
  assert(false);
}
async function renderHtmlStream(streamOriginal, injectString, pageContext, onErrorWhileStreaming, injectFilter) {
  const processStreamOptions = {
    onErrorWhileStreaming,
    enableEagerStreaming: pageContext.enableEagerStreaming
  };
  if (injectString) {
    let streamFromReactStreamingPackage = null;
    if (isStreamFromReactStreamingPackage(streamOriginal) && !streamOriginal.disabled) {
      streamFromReactStreamingPackage = streamOriginal;
    }
    const { injectAtStreamBegin, injectAtStreamAfterFirstChunk, injectAtStreamEnd } = injectHtmlTagsToStream(pageContext, streamFromReactStreamingPackage, injectFilter);
    processStreamOptions.injectStringAtBegin = async () => {
      return await injectAtStreamBegin(injectString.htmlPartsBegin);
    };
    processStreamOptions.injectStringAtEnd = async () => {
      return await injectAtStreamEnd(injectString.htmlPartsEnd);
    };
    processStreamOptions.injectStringAfterFirstChunk = () => {
      return injectAtStreamAfterFirstChunk();
    };
  }
  let makeClosableAgain = /* @__PURE__ */ __name(() => {
  }, "makeClosableAgain");
  if (isStreamFromReactStreamingPackage(streamOriginal)) {
    makeClosableAgain = streamOriginal.doNotClose();
  }
  try {
    const streamWrapper = await processStream(streamOriginal, processStreamOptions);
    return streamWrapper;
  } finally {
    makeClosableAgain();
  }
}
function isTemplateWrapped(something) {
  return hasProp(something, "_template");
}
function isEscapedString(something) {
  const result = hasProp(something, "_escaped");
  if (result) {
    assert(hasProp(something, "_escaped", "string"));
    checkType(something);
  }
  return result;
}
function getEscapedString(escapedString) {
  let htmlString;
  assert(hasProp(escapedString, "_escaped"));
  htmlString = escapedString._escaped;
  assert(typeof htmlString === "string");
  return htmlString;
}
function escapeInject(templateStrings, ...templateVariables) {
  assertUsage(templateStrings.length === templateVariables.length + 1 && templateStrings.every((str) => typeof str === "string"), `You're using ${picocolors_default.cyan("escapeInject")} as a function, but ${picocolors_default.cyan("escapeInject")} is a string template tag, see https://vike.dev/escapeInject`, { showStackTrace: true });
  return {
    _template: {
      templateStrings,
      templateVariables
    }
  };
}
function dangerouslySkipEscape(alreadyEscapedString) {
  return _dangerouslySkipEscape(alreadyEscapedString);
}
function _dangerouslySkipEscape(arg) {
  if (hasProp(arg, "_escaped")) {
    assert(isEscapedString(arg));
    return arg;
  }
  assertUsage(!isPromise(arg), `[dangerouslySkipEscape(${picocolors_default.cyan("str")})] Argument ${picocolors_default.cyan("str")} is a promise. It should be a string instead (or a stream). Make sure to ${picocolors_default.cyan("await str")}.`, { showStackTrace: true });
  if (typeof arg === "string") {
    return { _escaped: arg };
  }
  assertWarning2(false, `[dangerouslySkipEscape(${picocolors_default.cyan("str")})] Argument ${picocolors_default.cyan("str")} should be a string but we got ${picocolors_default.cyan(`typeof str === "${typeof arg}"`)}.`, {
    onlyOnce: false,
    showStackTrace: true
  });
  return { _escaped: String(arg) };
}
function renderTemplate(templateContent, pageContext) {
  const htmlPartsBegin = [];
  const htmlPartsEnd = [];
  let htmlStream = null;
  const addHtmlPart = /* @__PURE__ */ __name((htmlPart) => {
    if (htmlStream === null) {
      htmlPartsBegin.push(htmlPart);
    } else {
      htmlPartsEnd.push(htmlPart);
    }
  }, "addHtmlPart");
  const setStream = /* @__PURE__ */ __name((stream) => {
    const { hookName, hookFilePath } = pageContext._renderHook;
    assertUsage(!htmlStream, `Injecting two streams in ${picocolors_default.cyan("escapeInject")} template tag of ${hookName}() hook defined by ${hookFilePath}. Inject only one stream instead.`);
    htmlStream = stream;
  }, "setStream");
  const { templateStrings, templateVariables } = templateContent;
  for (let i = 0; i < templateVariables.length; i++) {
    addHtmlPart(templateStrings[i]);
    let templateVar = templateVariables[i];
    if (isEscapedString(templateVar)) {
      const htmlString = getEscapedString(templateVar);
      addHtmlPart(htmlString);
      continue;
    }
    if (isTemplateWrapped(templateVar)) {
      const templateContentInner = templateVar._template;
      const result = renderTemplate(templateContentInner, pageContext);
      if (!("htmlStream" in result)) {
        result.htmlPartsAll.forEach(addHtmlPart);
      } else {
        result.htmlPartsBegin.forEach(addHtmlPart);
        setStream(result.htmlStream);
        result.htmlPartsEnd.forEach(addHtmlPart);
      }
      continue;
    }
    if (isStream(templateVar)) {
      setStream(templateVar);
      continue;
    }
    const getErrMsg2 = /* @__PURE__ */ __name((msg) => {
      const { hookName, hookFilePath } = pageContext._renderHook;
      const nth = i === 0 && "1st" || i === 1 && "2nd" || i === 2 && "3rd" || `${i}-th`;
      return [
        `The ${nth} HTML variable is ${msg}`,
        `The HTML was provided by the ${hookName}() hook at ${hookFilePath}.`
      ].filter(Boolean).join(" ");
    }, "getErrMsg");
    assertUsage(!isPromise(templateVar), getErrMsg2(`a promise, did you forget to ${picocolors_default.cyan("await")} the promise?`));
    if (templateVar === void 0 || templateVar === null) {
      const msgVal = picocolors_default.cyan(String(templateVar));
      const msgEmptyString = picocolors_default.cyan("''");
      const msg = `${msgVal} which will be converted to an empty string. Pass the empty string ${msgEmptyString} instead of ${msgVal} to remove this warning.`;
      assertWarning2(false, getErrMsg2(msg), { onlyOnce: false });
      templateVar = "";
    }
    {
      const varType = typeof templateVar;
      if (varType !== "string") {
        const msgType = picocolors_default.cyan(`typeof htmlVariable === "${varType}"`);
        const msg = `${msgType} but a string or stream (https://vike.dev/streaming) is expected instead.`;
        assertUsage(false, getErrMsg2(msg));
      }
    }
    {
      const { _isProduction: isProduction2 } = pageContext._globalContext;
      if (isHtml(templateVar) && // We don't show this warning in production because it's expected that some users may (un)willingly do some XSS injection: we avoid flooding the production logs.
      !isProduction2) {
        const msgVal = picocolors_default.cyan(String(templateVar));
        const msg = `${msgVal} which seems to be HTML code. Did you forget to wrap the value with dangerouslySkipEscape()?`;
        assertWarning2(false, getErrMsg2(msg), { onlyOnce: false });
      }
    }
    addHtmlPart(escapeHtml(templateVar));
  }
  assert(templateStrings.length === templateVariables.length + 1);
  addHtmlPart(templateStrings[templateStrings.length - 1]);
  if (htmlStream === null) {
    assert(htmlPartsEnd.length === 0);
    return {
      htmlPartsAll: htmlPartsBegin
    };
  }
  return {
    htmlStream,
    htmlPartsBegin,
    htmlPartsEnd
  };
}
async function getHtmlString(htmlRender) {
  if (typeof htmlRender === "string") {
    return htmlRender;
  }
  if (isStream(htmlRender)) {
    return streamToString(htmlRender);
  }
  checkType(htmlRender);
  assert(false);
}
var init_renderHtml = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/renderHtml.js"() {
    init_utils3();
    init_injectAssets();
    init_stream();
    init_react_streaming();
    init_picocolors();
    __name(isDocumentHtml, "isDocumentHtml");
    __name(renderDocumentHtml, "renderDocumentHtml");
    __name(renderHtmlStream, "renderHtmlStream");
    __name(isTemplateWrapped, "isTemplateWrapped");
    __name(isEscapedString, "isEscapedString");
    __name(getEscapedString, "getEscapedString");
    __name(escapeInject, "escapeInject");
    __name(dangerouslySkipEscape, "dangerouslySkipEscape");
    __name(_dangerouslySkipEscape, "_dangerouslySkipEscape");
    __name(renderTemplate, "renderTemplate");
    __name(getHtmlString, "getHtmlString");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getHttpResponseBody.js
function getHttpResponseBody(htmlRender, renderHook) {
  if (typeof htmlRender !== "string") {
    assertUsage(false, getErrMsg(htmlRender, renderHook, "body", `Use ${picocolors_default.cyan("pageContext.httpResponse.pipe()")} instead`));
  }
  const body = htmlRender;
  return body;
}
function getHttpResponseBodyStreamHandlers(htmlRender, renderHook) {
  return {
    pipe(writable) {
      const getErrMsgMixingStreamTypes = /* @__PURE__ */ __name((writableType) => `The ${getErrMsgBody(htmlRender, renderHook)} while a ${writableType} was passed to pageContext.httpResponse.pipe() which is contradictory. You cannot mix a Web Stream with a Node.js Stream.`, "getErrMsgMixingStreamTypes");
      if (isStreamWritableWeb(writable)) {
        const success = pipeToStreamWritableWeb(htmlRender, writable);
        if (success) {
          return;
        } else {
          assert(isStreamReadableNode(htmlRender) || isStreamPipeNode(htmlRender));
          assertUsage(false, getErrMsgMixingStreamTypes("Web Writable"));
        }
      }
      if (isStreamWritableNode(writable)) {
        const success = pipeToStreamWritableNode(htmlRender, writable);
        if (success) {
          return;
        } else {
          assert(isStreamReadableWeb(htmlRender) || isStreamPipeWeb(htmlRender));
          assertUsage(false, getErrMsgMixingStreamTypes("Node.js Writable"));
        }
      }
      assertUsage(false, `The argument ${picocolors_default.cyan("writable")} passed to ${picocolors_default.cyan("pageContext.httpResponse.pipe(writable)")} doesn't seem to be ${getStreamName("writable", "web")} nor ${getStreamName("writable", "node")}.`);
    },
    getReadableWebStream() {
      const webStream = getStreamReadableWeb(htmlRender);
      if (webStream === null) {
        assertUsage(false, getErrMsg(htmlRender, renderHook, "getReadableWebStream()", getFixMsg("readable", "web")));
      }
      return webStream;
    },
    async getReadableNodeStream() {
      const nodeStream = await getStreamReadableNode(htmlRender);
      if (nodeStream === null) {
        assertUsage(false, getErrMsg(htmlRender, renderHook, "getReadableNodeStream()", getFixMsg("readable", "node")));
      }
      return nodeStream;
    },
    async getBody() {
      const body = await getHtmlString(htmlRender);
      return body;
    },
    // TO-DO/next-major-release: remove
    async getNodeStream() {
      assertWarning2(false, "`pageContext.httpResponse.getNodeStream()` is outdated, use `pageContext.httpResponse.getReadableNodeStream()` instead. " + streamDocs, { onlyOnce: true, showStackTrace: true });
      const nodeStream = await getStreamReadableNode(htmlRender);
      if (nodeStream === null) {
        assertUsage(false, getErrMsg(htmlRender, renderHook, "getNodeStream()", getFixMsg("readable", "node")));
      }
      return nodeStream;
    },
    // TO-DO/next-major-release: remove
    getWebStream() {
      assertWarning2(false, "`pageContext.httpResponse.getWebStream(res)` is outdated, use `pageContext.httpResponse.getReadableWebStream(res)` instead. " + streamDocs, { onlyOnce: true, showStackTrace: true });
      const webStream = getStreamReadableWeb(htmlRender);
      if (webStream === null) {
        assertUsage(false, getErrMsg(htmlRender, renderHook, "getWebStream()", getFixMsg("readable", "web")));
      }
      return webStream;
    },
    // TO-DO/next-major-release: remove
    pipeToWebWritable(writable) {
      assertWarning2(false, "`pageContext.httpResponse.pipeToWebWritable(res)` is outdated, use `pageContext.httpResponse.pipe(res)` instead. " + streamDocs, { onlyOnce: true, showStackTrace: true });
      const success = pipeToStreamWritableWeb(htmlRender, writable);
      if (!success) {
        assertUsage(false, getErrMsg(htmlRender, renderHook, "pipeToWebWritable()"));
      }
    },
    // TO-DO/next-major-release: remove
    pipeToNodeWritable(writable) {
      assertWarning2(false, "`pageContext.httpResponse.pipeToNodeWritable(res)` is outdated, use `pageContext.httpResponse.pipe(res)` instead. " + streamDocs, { onlyOnce: true, showStackTrace: true });
      const success = pipeToStreamWritableNode(htmlRender, writable);
      if (!success) {
        assertUsage(false, getErrMsg(htmlRender, renderHook, "pipeToNodeWritable()"));
      }
    }
  };
  function getFixMsg(kind, type2) {
    const streamName = getStreamName(kind, type2);
    assert(["a ", "an ", "the "].some((s) => streamName.startsWith(s)));
    assert(renderHook);
    const { hookFilePath, hookName } = renderHook;
    return `Make sure the ${hookName}() hook defined by ${hookFilePath} provides ${streamName} instead`;
  }
  __name(getFixMsg, "getFixMsg");
}
function getErrMsg(htmlRender, renderHook, method, msgAddendum) {
  assert(!msgAddendum || !msgAddendum.endsWith("."));
  const errMsgBody = getErrMsgBody(htmlRender, renderHook);
  return [`pageContext.httpResponse.${method} can't be used because the ${errMsgBody}`, msgAddendum, streamDocs].filter(Boolean).join(". ");
}
function getErrMsgBody(htmlRender, renderHook) {
  assert(renderHook);
  const { hookFilePath, hookName } = renderHook;
  const hookReturnType = getHookReturnType(htmlRender);
  assert(["a ", "an ", "the "].some((s) => hookReturnType.startsWith(s)));
  const errMsgBody = `${hookName}() hook defined by ${hookFilePath} provides ${hookReturnType}`;
  assert(!errMsgBody.endsWith(" "));
  return errMsgBody;
}
function getHookReturnType(htmlRender) {
  if (typeof htmlRender === "string") {
    return "an HTML string";
  } else if (isStream(htmlRender)) {
    return inferStreamName(htmlRender);
  } else {
    assert(false);
  }
}
var streamDocs;
var init_getHttpResponseBody = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getHttpResponseBody.js"() {
    init_stream();
    init_utils3();
    init_renderHtml();
    init_picocolors();
    streamDocs = "See https://vike.dev/streaming for more information.";
    __name(getHttpResponseBody, "getHttpResponseBody");
    __name(getHttpResponseBodyStreamHandlers, "getHttpResponseBodyStreamHandlers");
    __name(getErrMsg, "getErrMsg");
    __name(getErrMsgBody, "getErrMsgBody");
    __name(getHookReturnType, "getHookReturnType");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getEarlyHints.js
function getEarlyHints(assets) {
  const earlyHints = [];
  {
    assets.forEach((asset) => {
      if (isFontFallback(asset, earlyHints))
        return;
      earlyHints.push({
        ...asset,
        earlyHintLink: inferEarlyHintLink(asset)
      });
    });
  }
  return earlyHints;
}
var init_getEarlyHints = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getEarlyHints.js"() {
    init_isFontFallback();
    init_inferHtmlTags();
    __name(getEarlyHints, "getEarlyHints");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/createHttpResponse/assertNoInfiniteHttpRedirect.js
function assertNoInfiniteHttpRedirect(urlRedirectTarget, pageContextInit) {
  if (true)
    return "DISABLED";
  if (!urlRedirectTarget.startsWith("/")) {
    return;
  }
  const urlOriginalNormalized = removeUrlOrigin(pageContextInit.urlOriginal).urlModified;
  assert(urlOriginalNormalized.startsWith("/"));
  const graph = copy(globalObject5.redirectGraph);
  graph[urlRedirectTarget] ?? (graph[urlRedirectTarget] = /* @__PURE__ */ new Set());
  graph[urlRedirectTarget].add(urlOriginalNormalized);
  validate(graph);
  globalObject5.redirectGraph = graph;
}
function copy(G) {
  return Object.fromEntries(Object.entries(G).map(([key, val]) => [key, new Set(val)]));
}
function validate(G) {
  Object.keys(G).forEach((n) => check(G, n, []));
}
function check(G, n, path) {
  if (path.includes(n)) {
    const cycle = path.slice(path.indexOf(n)).concat(n);
    assertUsage(false, `Infinite loop of HTTP URL redirects: ${cycle.map(picocolors_default.cyan).join(" -> ")}`);
  }
  G[n]?.forEach((node) => check(G, node, [...path, n]));
}
var globalObject5;
var init_assertNoInfiniteHttpRedirect = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/createHttpResponse/assertNoInfiniteHttpRedirect.js"() {
    init_utils3();
    init_picocolors();
    globalObject5 = getGlobalObject("createHttpResponse/assertNoInfiniteHttpRedirect.ts", {
      redirectGraph: {}
    });
    __name(assertNoInfiniteHttpRedirect, "assertNoInfiniteHttpRedirect");
    __name(copy, "copy");
    __name(validate, "validate");
    __name(check, "check");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getCacheControl.js
function getCacheControl(pageId, pageConfigs) {
  if (pageConfigs.length === 0)
    return cacheControlDisable;
  if (pageId) {
    const pageConfig = getPageConfig(pageId, pageConfigs);
    const configValue = getConfigValueRuntime(pageConfig, "cacheControl", "string");
    const value = configValue?.value;
    if (value)
      return value;
  }
  return cacheControlDisable;
}
var cacheControlDisable;
var init_getCacheControl = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getCacheControl.js"() {
    init_helpers();
    init_getConfigValueRuntime();
    cacheControlDisable = "no-store, max-age=0";
    __name(getCacheControl, "getCacheControl");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/createHttpResponse.js
async function createHttpResponsePage(htmlRender, renderHook, pageContext) {
  let statusCode = pageContext.abortStatusCode;
  if (!statusCode) {
    const isError = !pageContext.pageId || isErrorPage(pageContext.pageId, pageContext._globalContext._pageConfigs);
    if (pageContext.errorWhileRendering) {
      assert(isError);
    }
    if (!isError) {
      assert(pageContext.is404 === null);
      statusCode = 200;
    } else {
      assert(pageContext.is404 === true || pageContext.is404 === false);
      statusCode = pageContext.is404 ? 404 : 500;
    }
  }
  const earlyHints = getEarlyHints(await pageContext.__getPageAssets());
  const headers = [];
  const headersResponse = pageContext.headersResponse || new Headers();
  headersResponse.forEach((value, key) => {
    headers.push([key, value]);
  });
  if (statusCode >= 500)
    headersResponse.set("Cache-Control", cacheControlDisable);
  return createHttpResponse(statusCode, "text/html;charset=utf-8", headers, htmlRender, earlyHints, renderHook);
}
function createHttpResponse404(errMsg404) {
  const httpResponse = createHttpResponse(404, "text/html;charset=utf-8", [], `<p>${errMsg404}.</p><script>console.log('This HTML was generated by Vike.')<\/script>`);
  return httpResponse;
}
function createHttpResponseBaseIsMissing(urlOriginal, baseServer2) {
  const httpResponse = createHttpResponse(
    // We use the error code `500` to signal a failing state because this HTTP response should never be used, see https://vike.dev/base-url#setup
    // In other words: this HTTP response is expected to be generated but isn't expected to be actually used.
    500,
    "text/html;charset=utf-8",
    [],
    `
<h1>Error: Base URL is missing</h1>
<p>
  <a href="https://vike.dev/renderPage"><code>renderPage(pageContextInit)</code></a> called with <code>pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}</code> which doesn't start with the Base URL <code>${baseServer2}</code>.
</p>
<p>
  See <a href="https://vike.dev/base-url#setup">vike.dev/base-url#setup</a> for how to properly setup your server while using a Base URL.
</p>
<style>
  code {
    font-family: monospace;
    background-color: #eaeaea;
    padding: 3px 5px;
    border-radius: 4px;
  }
</style>
`
  );
  return httpResponse;
}
function createHttpResponseError(pageContext) {
  const reason = (() => {
    const errorPageId = getErrorPageId(pageContext._globalContext._pageFilesAll, pageContext._globalContext._pageConfigs);
    if (errorPageId) {
      return "the error page (https://vike.dev/error-page) couldn't be rendered (for example if an error occurred while rendering the error page)";
    } else {
      return "no error page (https://vike.dev/error-page) is defined, make sure to create one";
    }
  })();
  return createHttpResponseError_(reason);
}
function createHttpResponseErrorWithoutGlobalContext() {
  return createHttpResponseError_("no error page (https://vike.dev/error-page) could be rendered");
}
function createHttpResponseError_(reason) {
  const httpResponse = createHttpResponse(500, "text/html;charset=utf-8", [], `<p>An error occurred.</p><script>console.log(${JSON.stringify(`This HTML was generated by Vike. Vike returned this HTML because ${reason}.`)})<\/script>`);
  return httpResponse;
}
async function createHttpResponsePageContextJson(pageContextSerialized) {
  const httpResponse = createHttpResponse(200, "application/json", [], pageContextSerialized, [], null);
  return httpResponse;
}
function createHttpResponseRedirect({ url, statusCode }, pageContextInit) {
  assertNoInfiniteHttpRedirect(url, pageContextInit);
  assert(url);
  assert(statusCode);
  assert(300 <= statusCode && statusCode <= 399);
  const headers = [["Location", url]];
  return createHttpResponse(
    statusCode,
    "text/html;charset=utf-8",
    headers,
    // For bots / programmatic crawlig: show what's going on.
    // For users: showing a blank page is probably better than a flickering text.
    `<p style="display: none">Redirecting to ${escapeHtml(url)}</p><script>console.log('This HTML was generated by Vike.')<\/script>`
  );
}
function createHttpResponse(statusCode, contentType, headers, htmlRender, earlyHints = [], renderHook = null) {
  headers.push(["Content-Type", contentType]);
  assert(renderHook || typeof htmlRender === "string");
  return {
    statusCode,
    headers,
    // TO-DO/next-major-release: remove
    get contentType() {
      assertWarning2(false, "pageContext.httpResponse.contentType is deprecated and will be removed in the next major release. Use pageContext.httpResponse.headers instead, see https://vike.dev/migration/0.4.134", { onlyOnce: true });
      return contentType;
    },
    earlyHints,
    get body() {
      return getHttpResponseBody(htmlRender, renderHook);
    },
    ...getHttpResponseBodyStreamHandlers(htmlRender, renderHook)
  };
}
var init_createHttpResponse = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/createHttpResponse.js"() {
    init_utils3();
    init_error_page();
    init_getHttpResponseBody();
    init_getEarlyHints();
    init_assertNoInfiniteHttpRedirect();
    init_getCacheControl();
    __name(createHttpResponsePage, "createHttpResponsePage");
    __name(createHttpResponse404, "createHttpResponse404");
    __name(createHttpResponseBaseIsMissing, "createHttpResponseBaseIsMissing");
    __name(createHttpResponseError, "createHttpResponseError");
    __name(createHttpResponseErrorWithoutGlobalContext, "createHttpResponseErrorWithoutGlobalContext");
    __name(createHttpResponseError_, "createHttpResponseError_");
    __name(createHttpResponsePageContextJson, "createHttpResponsePageContextJson");
    __name(createHttpResponseRedirect, "createHttpResponseRedirect");
    __name(createHttpResponse, "createHttpResponse");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/getAllPageIdFiles.js
function getPageFilesClientSide(pageFilesAll, pageId) {
  return determine(pageFilesAll, pageId, true);
}
function getPageFilesServerSide(pageFilesAll, pageId) {
  return determine(pageFilesAll, pageId, false);
}
function determine(pageFilesAll, pageId, envIsClient) {
  const env2 = envIsClient ? "CLIENT_ONLY" : "SERVER_ONLY";
  const pageFilesRelevant = pageFilesAll.filter((p2) => p2.isRelevant(pageId) && p2.fileType !== ".page.route").sort(getPageFilesSorter(envIsClient, pageId));
  const getPageIdFile = /* @__PURE__ */ __name((iso) => {
    const files = pageFilesRelevant.filter((p2) => p2.pageId === pageId && p2.isEnv(iso ? "CLIENT_AND_SERVER" : env2));
    assertUsage(files.length <= 1, `Merge the following files into a single file: ${files.map((p2) => p2.filePath).join(" ")}`);
    const pageIdFile = files[0];
    assert(pageIdFile === void 0 || !pageIdFile.isDefaultPageFile);
    return pageIdFile;
  }, "getPageIdFile");
  const pageIdFileEnv = getPageIdFile(false);
  const pageIdFileIso = getPageIdFile(true);
  const getRendererFile = /* @__PURE__ */ __name((iso) => pageFilesRelevant.filter((p2) => p2.isRendererPageFile && p2.isEnv(iso ? "CLIENT_AND_SERVER" : env2))[0], "getRendererFile");
  const rendererFileEnv = getRendererFile(false);
  const rendererFileIso = getRendererFile(true);
  const defaultFilesNonRenderer = pageFilesRelevant.filter((p2) => p2.isDefaultPageFile && !p2.isRendererPageFile && (p2.isEnv(env2) || p2.isEnv("CLIENT_AND_SERVER")));
  const pageFiles = [pageIdFileEnv, pageIdFileIso, ...defaultFilesNonRenderer, rendererFileEnv, rendererFileIso].filter(isNotNullish);
  return pageFiles;
}
function getPageFilesSorter(envIsClient, pageId) {
  const env2 = envIsClient ? "CLIENT_ONLY" : "SERVER_ONLY";
  const e1First = -1;
  const e2First = 1;
  const noOrder = 0;
  return (e1, e2) => {
    if (!e1.isDefaultPageFile && e2.isDefaultPageFile) {
      return e1First;
    }
    if (!e2.isDefaultPageFile && e1.isDefaultPageFile) {
      return e2First;
    }
    {
      const e1_isRenderer = e1.isRendererPageFile;
      const e2_isRenderer = e2.isRendererPageFile;
      if (!e1_isRenderer && e2_isRenderer) {
        return e1First;
      }
      if (!e2_isRenderer && e1_isRenderer) {
        return e2First;
      }
      assert(e1_isRenderer === e2_isRenderer);
    }
    {
      const e1_distance = getPathDistance(pageId, e1.filePath);
      const e2_distance = getPathDistance(pageId, e2.filePath);
      if (e1_distance < e2_distance) {
        return e1First;
      }
      if (e2_distance < e1_distance) {
        return e2First;
      }
      assert(e1_distance === e2_distance);
    }
    {
      if (e1.isEnv(env2) && e2.isEnv("CLIENT_AND_SERVER")) {
        return e1First;
      }
      if (e2.isEnv(env2) && e1.isEnv("CLIENT_AND_SERVER")) {
        return e2First;
      }
    }
    return noOrder;
  };
}
function getPathDistance(pathA, pathB) {
  let idx = 0;
  for (; idx < pathA.length && idx < pathB.length; idx++) {
    if (pathA[idx] !== pathB[idx])
      break;
  }
  const pathAWithoutCommon = pathA.slice(idx);
  const pathBWithoutCommon = pathB.slice(idx);
  const distanceA = pathAWithoutCommon.split("/").length;
  const distanceB = pathBWithoutCommon.split("/").length;
  const distance = distanceA + distanceB;
  return distance;
}
var init_getAllPageIdFiles = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/getAllPageIdFiles.js"() {
    init_utils();
    __name(getPageFilesClientSide, "getPageFilesClientSide");
    __name(getPageFilesServerSide, "getPageFilesServerSide");
    __name(determine, "determine");
    __name(getPageFilesSorter, "getPageFilesSorter");
    __name(getPathDistance, "getPathDistance");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles.js
var init_getPageFiles = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles.js"() {
    init_getAllPageIdFiles();
    init_getAllPageIdFiles();
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/assert_exports_old_design.js
function assertExportValues(pageFile) {
  enforceTrue.forEach((exportName) => {
    assert(pageFile.fileExports);
    if (!(exportName in pageFile.fileExports))
      return;
    const explainer = `The value of \`${exportName}\` is only allowed to be \`true\`.`;
    assertUsage(pageFile.fileExports[exportName] !== false, `${pageFile.filePath} has \`export { ${exportName} }\` with the value \`false\` which is prohibited: remove \`export { ${exportName} }\` instead. (${explainer})`);
    assertUsage(pageFile.fileExports[exportName] === true, `${pageFile.filePath} has \`export { ${exportName} }\` with a forbidden value. ${explainer}`);
  });
}
function assertDefaultExports(defaultExportName, filePath) {
  assertUsage(!forbiddenDefaultExports.includes(defaultExportName), `${filePath} has \`export default { ${defaultExportName} }\` which is prohibited, use \`export { ${defaultExportName} }\` instead.`);
}
var enforceTrue, forbiddenDefaultExports;
var init_assert_exports_old_design = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/assert_exports_old_design.js"() {
    init_utils();
    enforceTrue = ["clientRouting"];
    __name(assertExportValues, "assertExportValues");
    forbiddenDefaultExports = ["render", "clientRouting", "prerender", "doNotPrerender"];
    __name(assertDefaultExports, "assertDefaultExports");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/resolveVikeConfigPublic.js
function resolveVikeConfigPublicPageEagerLoaded(pageConfigGlobalValues, pageConfig, pageConfigValues) {
  const vikeConfigPublicPage_ = resolveVikeConfigPublic_base({ pageConfigGlobalValues, pageConfigValues });
  const vikeConfigPublicPage = getPublicCopy(vikeConfigPublicPage_);
  let page;
  if (!pageConfig.isErrorPage) {
    const route2 = vikeConfigPublicPage.config.route ?? pageConfig.routeFilesystem.routeString;
    page = {
      ...vikeConfigPublicPage,
      route: route2
    };
  } else {
    page = {
      ...vikeConfigPublicPage,
      isErrorPage: true
    };
  }
  return [pageConfig.pageId, page];
}
function getPublicCopy(vikeConfigPublic) {
  return {
    config: vikeConfigPublic.config,
    _source: vikeConfigPublic.source,
    _sources: vikeConfigPublic.sources,
    _from: vikeConfigPublic.from
  };
}
function resolveVikeConfigPublic_base({ pageConfigGlobalValues, pageConfigValues }) {
  const configValues = { ...pageConfigGlobalValues, ...pageConfigValues };
  return resolveVikeConfigPublic_V1Design({ configValues });
}
function resolveVikeConfigPublicGlobal({ pageConfigGlobalValues }) {
  const vikeConfigPublicGlobal = resolveVikeConfigPublic_V1Design({ configValues: pageConfigGlobalValues });
  return getPublicCopy(vikeConfigPublicGlobal);
}
function resolveVikeConfigPublicPageLazyLoaded(pageFiles, pageConfig, pageConfigGlobal) {
  const config = {};
  const configEntries = {};
  const exportsAll = {};
  pageFiles.forEach((pageFile) => {
    const exportValues = getExportValues(pageFile);
    exportValues.forEach(({ exportName, exportValue, isFromDefaultExport }) => {
      assert(exportName !== "default");
      exportsAll[exportName] = exportsAll[exportName] ?? [];
      exportsAll[exportName].push({
        exportValue,
        exportSource: `${pageFile.filePath} > ${isFromDefaultExport ? `\`export default { ${exportName} }\`` : `\`export { ${exportName} }\``}`,
        filePath: pageFile.filePath,
        _filePath: pageFile.filePath,
        // TO-DO/next-major-release: remove
        _fileType: pageFile.fileType,
        _isFromDefaultExport: isFromDefaultExport
      });
    });
  });
  let source;
  let sources;
  let from2;
  if (pageConfig) {
    const res = resolveVikeConfigPublic_base({
      pageConfigGlobalValues: pageConfigGlobal.configValues,
      pageConfigValues: pageConfig.configValues
    });
    source = res.source;
    sources = res.sources;
    from2 = res.from;
    Object.assign(config, res.config);
    Object.assign(configEntries, res.configEntries);
    Object.assign(exportsAll, res.exportsAll);
  } else {
    source = {};
    sources = {};
    from2 = {
      configsStandard: {},
      configsCumulative: {},
      configsComputed: {}
    };
  }
  const pageExports = {};
  const exports = {};
  Object.entries(exportsAll).forEach(([exportName, values]) => {
    values.forEach(({ exportValue, _fileType, _isFromDefaultExport }) => {
      exports[exportName] = exports[exportName] ?? exportValue;
      if (_fileType === ".page" && !_isFromDefaultExport) {
        if (!(exportName in pageExports)) {
          pageExports[exportName] = exportValue;
        }
      }
    });
  });
  assert(!("default" in exports));
  assert(!("default" in exportsAll));
  const configPublicPageLazy = {
    config,
    from: from2,
    source,
    sources,
    // TO-DO/soon/flat-pageContext: deprecate every prop below
    configEntries,
    exports,
    exportsAll
  };
  objectDefineProperty(configPublicPageLazy, "pageExports", {
    get: /* @__PURE__ */ __name(() => {
      if (!isBrowser()) {
        assertWarning2(false, "pageContext.pageExports is outdated, use pageContext.exports instead", {
          onlyOnce: true,
          showStackTrace: true
        });
      }
      return pageExports;
    }, "get"),
    enumerable: false,
    configurable: true
  });
  return configPublicPageLazy;
}
function resolveVikeConfigPublic_V1Design(pageConfig) {
  const config = {};
  const configEntries = {};
  const exportsAll = {};
  const source = {};
  const sources = {};
  const from2 = {
    configsStandard: {},
    configsCumulative: {},
    configsComputed: {}
  };
  const addSrc = /* @__PURE__ */ __name((src, configName) => {
    source[configName] = src;
    sources[configName] ?? (sources[configName] = []);
    sources[configName].push(src);
  }, "addSrc");
  const addLegacy = /* @__PURE__ */ __name((configName, value, definedAtData) => {
    const configValueFilePathToShowToUser = getConfigValueFilePathToShowToUser(definedAtData);
    const configDefinedAt = getConfigDefinedAtOptional("Config", configName, definedAtData);
    configEntries[configName] = configEntries[configName] ?? [];
    configEntries[configName].push({
      configValue: value,
      configDefinedAt,
      configDefinedByFile: configValueFilePathToShowToUser
    });
    const exportName = configName;
    exportsAll[exportName] = exportsAll[exportName] ?? [];
    exportsAll[exportName].push({
      exportValue: value,
      exportSource: configDefinedAt,
      filePath: configValueFilePathToShowToUser,
      _filePath: configValueFilePathToShowToUser,
      _fileType: null,
      _isFromDefaultExport: null
    });
  }, "addLegacy");
  Object.entries(pageConfig.configValues).forEach(([configName, configValue]) => {
    const { value } = configValue;
    config[configName] = config[configName] ?? value;
    if (configValue.type === "standard") {
      const src = {
        type: "configsStandard",
        value: configValue.value,
        definedAt: getDefinedAtString(configValue.definedAtData, configName)
      };
      addSrc(src, configName);
      from2.configsStandard[configName] = src;
      addLegacy(configName, value, configValue.definedAtData);
    }
    if (configValue.type === "cumulative") {
      const src = {
        type: "configsCumulative",
        definedAt: getDefinedAtString(configValue.definedAtData, configName),
        values: configValue.value.map((value2, i) => {
          const definedAtFile = configValue.definedAtData[i];
          assert(definedAtFile);
          const definedAt = getDefinedAtString(definedAtFile, configName);
          addLegacy(configName, value2, definedAtFile);
          return {
            value: value2,
            definedAt
          };
        })
      };
      addSrc(src, configName);
      from2.configsCumulative[configName] = src;
    }
    if (configValue.type === "computed") {
      const src = {
        type: "configsComputed",
        definedAt: "Vike",
        // Vike currently doesn't support user-land computed configs => computed configs are always defined by Vike => there isn't any file path to show.
        value: configValue.value
      };
      addSrc(src, configName);
      from2.configsComputed[configName] = src;
      addLegacy(configName, value, configValue.definedAtData);
    }
  });
  return {
    config,
    configEntries,
    exportsAll,
    source,
    sources,
    from: from2
  };
}
function getExportValues(pageFile) {
  const { filePath, fileExports } = pageFile;
  assert(fileExports);
  assert(isScriptFile(filePath));
  const exportValues = [];
  Object.entries(fileExports).sort(makeLast(([exportName]) => exportName === "default")).forEach(([exportName, exportValue]) => {
    let isFromDefaultExport = exportName === "default";
    if (isFromDefaultExport) {
      if (isTemplateFile(filePath)) {
        exportName = "Page";
      } else {
        assertUsage(isObject(exportValue), `The ${picocolors_default.cyan("export default")} of ${filePath} should be an object.`);
        Object.entries(exportValue).forEach(([defaultExportName, defaultExportValue]) => {
          assertDefaultExports(defaultExportName, filePath);
          exportValues.push({
            exportName: defaultExportName,
            exportValue: defaultExportValue,
            isFromDefaultExport
          });
        });
        return;
      }
    }
    exportValues.push({
      exportName,
      exportValue,
      isFromDefaultExport
    });
  });
  exportValues.forEach(({ exportName, isFromDefaultExport }) => {
    assert(!(isFromDefaultExport && forbiddenDefaultExports.includes(exportName)));
  });
  return exportValues;
}
var init_resolveVikeConfigPublic = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/resolveVikeConfigPublic.js"() {
    init_assert_exports_old_design();
    init_getConfigDefinedAt();
    init_helpers();
    init_utils();
    init_picocolors();
    __name(resolveVikeConfigPublicPageEagerLoaded, "resolveVikeConfigPublicPageEagerLoaded");
    __name(getPublicCopy, "getPublicCopy");
    __name(resolveVikeConfigPublic_base, "resolveVikeConfigPublic_base");
    __name(resolveVikeConfigPublicGlobal, "resolveVikeConfigPublicGlobal");
    __name(resolveVikeConfigPublicPageLazyLoaded, "resolveVikeConfigPublicPageLazyLoaded");
    __name(resolveVikeConfigPublic_V1Design, "resolveVikeConfigPublic_V1Design");
    __name(getExportValues, "getExportValues");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide/getExportNames.js
function getExportNames(p2) {
  if (p2.fileType === ".css") {
    return [];
  }
  if (p2.exportNames) {
    return p2.exportNames;
  }
  assert(p2.fileExports, p2.filePath);
  const exportNames = Object.keys(p2.fileExports);
  return exportNames;
}
var init_getExportNames = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide/getExportNames.js"() {
    init_utils();
    __name(getExportNames, "getExportNames");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide/analyzeExports.js
function analyzeExports({ pageFilesClientSide, pageFilesServerSide, pageId }) {
  return { isHtmlOnly: isHtmlOnly(), isClientRouting: isClientRouting() };
  function isHtmlOnly() {
    {
      const hasPageIdIsmrphFile = pageFilesServerSide.some((p2) => p2.pageId === pageId && p2.fileType === ".page");
      if (hasPageIdIsmrphFile) {
        assertClientSideRenderHook();
        return false;
      }
    }
    {
      const hasPageIdServerFile = pageFilesServerSide.some((p2) => p2.pageId === pageId && p2.fileType === ".page.server");
      if (!hasPageIdServerFile) {
        return false;
      }
    }
    {
      const definesClientRenderer = pageFilesClientSide.some((p2) => p2.pageId === pageId && p2.fileType === ".page.client" && getExportNames(p2).includes("render"));
      if (definesClientRenderer) {
        return false;
      }
    }
    return true;
  }
  __name(isHtmlOnly, "isHtmlOnly");
  function assertClientSideRenderHook() {
    const hasClientSideRenderHook = pageFilesClientSide.some((p2) => {
      return getExportNames(p2).includes("render");
    });
    assertUsage(hasClientSideRenderHook, [
      "No client-side `render()` hook found.",
      "See https://vike.dev/render-modes for more information.",
      [
        "Loaded client-side page files (none of them `export { render }`):",
        ...pageFilesClientSide.map((p2, i) => ` (${i + 1}): ${p2.filePath}`)
      ].join("\n")
    ].join(" "));
  }
  __name(assertClientSideRenderHook, "assertClientSideRenderHook");
  function isClientRouting() {
    const hasClientRoutingExport = pageFilesClientSide.some((p2) => {
      return getExportNames(p2).includes("clientRouting");
    });
    return hasClientRoutingExport;
  }
  __name(isClientRouting, "isClientRouting");
}
var init_analyzeExports = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide/analyzeExports.js"() {
    init_getExportNames();
    init_utils();
    __name(analyzeExports, "analyzeExports");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide/determineClientEntry.js
function determineClientEntry({ pageFilesClientSide, pageFilesServerSide, isHtmlOnly, isClientRouting }) {
  let clientEntries = [];
  const pageFilesServerSideOnly = pageFilesServerSide.filter((p2) => !pageFilesClientSide.includes(p2));
  const clientDependencies = [];
  clientDependencies.push(...pageFilesClientSide.map((p2) => ({ id: p2.filePath, onlyAssets: false, eagerlyImported: false })));
  clientDependencies.push(...pageFilesServerSideOnly.map((p2) => ({ id: p2.filePath, onlyAssets: true, eagerlyImported: false })));
  if (isHtmlOnly) {
    clientEntries = pageFilesClientSide.map((p2) => p2.filePath);
  } else {
    const clientEntry = getVikeClientEntry(isClientRouting);
    clientDependencies.push({ id: clientEntry, onlyAssets: false, eagerlyImported: false });
    clientEntries = [clientEntry];
  }
  return { clientEntries, clientDependencies };
}
function getVikeClientEntry(isClientRouting) {
  return isClientRouting ? "@@vike/dist/esm/client/runtime-client-routing/entry.js" : "@@vike/dist/esm/client/runtime-server-routing/entry.js";
}
var init_determineClientEntry = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide/determineClientEntry.js"() {
    __name(determineClientEntry, "determineClientEntry");
    __name(getVikeClientEntry, "getVikeClientEntry");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide.js
function analyzePageClientSide(pageFilesAll, pageId) {
  let pageFilesClientSide = getPageFilesClientSide(pageFilesAll, pageId);
  const pageFilesServerSide = getPageFilesServerSide(pageFilesAll, pageId);
  const { isHtmlOnly, isClientRouting } = analyzeExports({ pageFilesClientSide, pageFilesServerSide, pageId });
  if (isHtmlOnly) {
    pageFilesClientSide = pageFilesClientSide.filter((p2) => p2.isEnv("CLIENT_ONLY") && !getExportNames(p2).includes("render"));
    pageFilesClientSide = removeOverriddenPageFiles(pageFilesClientSide);
  }
  const { clientEntries, clientDependencies } = determineClientEntry({
    pageFilesClientSide,
    pageFilesServerSide,
    isHtmlOnly,
    isClientRouting
  });
  return { isHtmlOnly, isClientRouting, clientEntries, clientDependencies, pageFilesClientSide, pageFilesServerSide };
}
async function analyzePageClientSideInit(pageFilesAll, pageId, { sharedPageFilesAlreadyLoaded }) {
  const pageFilesClientSide = getPageFilesClientSide(pageFilesAll, pageId);
  await Promise.all(pageFilesClientSide.map(async (p2) => {
    assert(p2.isEnv("CLIENT_ONLY") || p2.isEnv("CLIENT_AND_SERVER"));
    if (sharedPageFilesAlreadyLoaded && p2.isEnv("CLIENT_AND_SERVER")) {
      return;
    }
    await p2.loadExportNames?.();
  }));
}
function removeOverriddenPageFiles(pageFilesClientSide) {
  const pageFilesClientSide_ = [];
  for (const p2 of pageFilesClientSide) {
    pageFilesClientSide_.push(p2);
    if (getExportNames(p2).includes("overrideDefaultPages")) {
      break;
    }
  }
  return pageFilesClientSide_;
}
var init_analyzePageClientSide = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/analyzePageClientSide.js"() {
    init_analyzeExports();
    init_determineClientEntry();
    init_getAllPageIdFiles();
    init_getAllPageIdFiles();
    init_utils();
    init_getExportNames();
    __name(analyzePageClientSide, "analyzePageClientSide");
    __name(analyzePageClientSideInit, "analyzePageClientSideInit");
    __name(removeOverriddenPageFiles, "removeOverriddenPageFiles");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/extractAssetsQuery.js
function extractAssetsAddQuery(id) {
  const fileExtension = getFileExtension(id);
  if (!fileExtension || id.includes("virtual:vike:")) {
    return `${id}?${query}`;
  } else {
    if (!id.includes("?")) {
      return `${id}?${query}&lang.${fileExtension}`;
    } else {
      return id.replace("?", `?${query}&`);
    }
  }
}
function extractAssetsRemoveQuery(id) {
  if (!id.includes("?"))
    return id;
  const suffix = `?${query}`;
  assert(id.endsWith(query));
  return id.slice(0, -1 * suffix.length);
}
var query;
var init_extractAssetsQuery = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/extractAssetsQuery.js"() {
    init_utils2();
    query = "extractAssets";
    __name(extractAssetsAddQuery, "extractAssetsAddQuery");
    __name(extractAssetsRemoveQuery, "extractAssetsRemoveQuery");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/virtualFileId.js
function parseVirtualFileId(id) {
  id = removeVirtualFileIdPrefix(id);
  if (!id.startsWith(virtualFileIdGlobalEntryPrefix) && !id.startsWith(virtualFileIdPageEntryPrefix))
    return false;
  if (id.includes(virtualFileIdGlobalEntryPrefix)) {
    assert(virtualFileIdGlobalEntries.includes(id));
    const isForClientSide = id !== virtualFileIdGlobalEntryServer;
    const isClientRouting = id === virtualFileIdGlobalEntryClientCR;
    return {
      type: "global-entry",
      isForClientSide,
      isClientRouting
    };
  }
  if (id.includes(virtualFileIdPageEntryPrefix)) {
    assert(id.startsWith(virtualFileIdPageEntryPrefix));
    const idOriginal = id;
    id = extractAssetsRemoveQuery(id);
    const isExtractAssets = idOriginal !== id;
    if (id.startsWith(virtualFileIdPageEntryClient)) {
      assert(isExtractAssets === false);
      return {
        type: "page-entry",
        pageId: id.slice(virtualFileIdPageEntryClient.length),
        isForClientSide: true,
        isExtractAssets
      };
    }
    if (id.startsWith(virtualFileIdPageEntryServer)) {
      return {
        type: "page-entry",
        pageId: id.slice(virtualFileIdPageEntryServer.length),
        isForClientSide: false,
        isExtractAssets
      };
    }
    assert(false);
  }
  return false;
}
function generateVirtualFileId(args) {
  if (args.type === "global-entry") {
    const { isForClientSide, isClientRouting } = args;
    assert(typeof isClientRouting === "boolean");
    if (!isForClientSide) {
      return virtualFileIdGlobalEntryServer;
    } else if (isClientRouting) {
      return virtualFileIdGlobalEntryClientCR;
    } else {
      return virtualFileIdGlobalEntryClientSR;
    }
  }
  if (args.type === "page-entry") {
    const { pageId, isForClientSide } = args;
    assert(typeof pageId === "string");
    const id = `${isForClientSide ? virtualFileIdPageEntryClient : virtualFileIdPageEntryServer}${pageId}`;
    return id;
  }
  assert(false);
}
var virtualFileIdGlobalEntryServer, virtualFileIdGlobalEntryClientSR, virtualFileIdGlobalEntryClientCR, virtualFileIdPageEntryClient, virtualFileIdPageEntryServer, virtualFileIdPageEntryPrefix, virtualFileIdGlobalEntryPrefix, virtualFileIdGlobalEntries;
var init_virtualFileId2 = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/virtualFileId.js"() {
    init_extractAssetsQuery();
    init_utils2();
    assertIsNotBrowser();
    virtualFileIdGlobalEntryServer = //
    "virtual:vike:global-entry:server";
    virtualFileIdGlobalEntryClientSR = //
    "virtual:vike:global-entry:client:server-routing";
    virtualFileIdGlobalEntryClientCR = //
    "virtual:vike:global-entry:client:client-routing";
    virtualFileIdPageEntryClient = //
    "virtual:vike:page-entry:client:";
    virtualFileIdPageEntryServer = //
    "virtual:vike:page-entry:server:";
    virtualFileIdPageEntryPrefix = //
    "virtual:vike:page-entry:";
    virtualFileIdGlobalEntryPrefix = //
    "virtual:vike:global-entry:";
    virtualFileIdGlobalEntries = [
      virtualFileIdGlobalEntryServer,
      virtualFileIdGlobalEntryClientCR,
      virtualFileIdGlobalEntryClientSR
    ];
    assert(virtualFileIdGlobalEntries.every((v) => (
      //
      v.startsWith(virtualFileIdGlobalEntryPrefix)
    )));
    assert([virtualFileIdPageEntryClient, virtualFileIdPageEntryServer].every((v) => (
      //
      v.startsWith(virtualFileIdPageEntryPrefix)
    )));
    __name(parseVirtualFileId, "parseVirtualFileId");
    __name(generateVirtualFileId, "generateVirtualFileId");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/prependEntriesDir.js
function prependEntriesDir(entryName) {
  if (entryName.startsWith("/")) {
    entryName = entryName.slice(1);
  }
  assert(!entryName.startsWith("/"));
  assert(entryName);
  entryName = `entries/${entryName}`;
  return entryName;
}
var init_prependEntriesDir = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/prependEntriesDir.js"() {
    init_utils2();
    __name(prependEntriesDir, "prependEntriesDir");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getPageAssets/getManifestEntry.js
function getManifestEntry(id, assetsManifest) {
  const debugInfo = getDebugInfo(id, assetsManifest);
  if (id.startsWith("@@vike/")) {
    const manifestKeyEnd = slice(id, "@@vike".length, 0);
    const { manifestKey: manifestKey2, manifestEntry: manifestEntry2 } = findEntryWithKeyEnd(manifestKeyEnd, assetsManifest, id);
    assert(manifestEntry2 && manifestKey2, debugInfo);
    return { manifestEntry: manifestEntry2, manifestKey: manifestKey2 };
  }
  const virtualFile = parseVirtualFileId(id);
  if (virtualFile && virtualFile.type === "page-entry") {
    {
      const manifestKey3 = id;
      const manifestEntry3 = assetsManifest[manifestKey3];
      if (manifestEntry3) {
        return { manifestEntry: manifestEntry3, manifestKey: manifestKey3 };
      }
    }
    const manifestKeyEnd = id;
    const { manifestKey: manifestKey2, manifestEntry: manifestEntry2 } = getEntryWithKeyEnd(manifestKeyEnd, assetsManifest, id);
    assert(manifestEntry2, debugInfo);
    return { manifestEntry: manifestEntry2, manifestKey: manifestKey2 };
  }
  if (id.startsWith("/")) {
    const manifestKey2 = id.slice(1);
    let manifestEntry2 = assetsManifest[manifestKey2];
    assert(manifestEntry2, debugInfo);
    return { manifestEntry: manifestEntry2, manifestKey: manifestKey2 };
  }
  assertIsImportPathNpmPackage(id);
  const found = Object.entries(assetsManifest).find(([, e2]) => e2.name === prependEntriesDir(id));
  assert(found);
  const [manifestKey, manifestEntry] = found;
  return { manifestEntry, manifestKey };
}
function findEntryWithKeyEnd(manifestKeyEnd, assetsManifest, id) {
  const debugInfo = getDebugInfo(id, assetsManifest, manifestKeyEnd);
  assert(manifestKeyEnd.startsWith("/"), debugInfo);
  const manifestKeys = [];
  for (const manifestKey2 in assetsManifest) {
    if (manifestKey2.endsWith(manifestKeyEnd)) {
      manifestKeys.push(manifestKey2);
    }
  }
  const manifestKeysRelative = manifestKeys.filter((k) => k.startsWith("../"));
  assert(manifestKeysRelative.length <= 1, debugInfo);
  const manifestKey = manifestKeysRelative[0] ?? manifestKeys[0] ?? null;
  if (!manifestKey) {
    return { manifestEntry: null, manifestKey: null };
  }
  const manifestEntry = assetsManifest[manifestKey];
  return { manifestEntry, manifestKey };
}
function getEntryWithKeyEnd(manifestKeyEnd, assetsManifest, id) {
  const debugInfo = getDebugInfo(id, assetsManifest, manifestKeyEnd);
  const manifestKeys = [];
  for (const manifestKey2 in assetsManifest) {
    if (manifestKey2.endsWith(manifestKeyEnd)) {
      manifestKeys.push(manifestKey2);
    }
  }
  assert(manifestKeys.length <= 1, debugInfo);
  const manifestKey = manifestKeys[0];
  if (!manifestKey) {
    return { manifestEntry: null, manifestKey: null };
  }
  const manifestEntry = assetsManifest[manifestKey];
  return { manifestEntry, manifestKey };
}
function getDebugInfo(id, assetsManifest, manifestKeyEnd) {
  const manifestKeys = Object.keys(assetsManifest);
  if (manifestKeyEnd === void 0) {
    return { manifestKeys, id };
  } else {
    return { manifestKeys, manifestKeyEnd, id };
  }
}
var init_getManifestEntry = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getPageAssets/getManifestEntry.js"() {
    init_utils3();
    init_virtualFileId2();
    init_prependEntriesDir();
    __name(getManifestEntry, "getManifestEntry");
    __name(findEntryWithKeyEnd, "findEntryWithKeyEnd");
    __name(getEntryWithKeyEnd, "getEntryWithKeyEnd");
    __name(getDebugInfo, "getDebugInfo");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getPageAssets/retrievePageAssetsProd.js
function retrievePageAssetsProd(assetsManifest, clientDependencies, clientEntries, config) {
  const clientEntriesSrc = clientEntries.map((clientEntry) => getClientEntrySrcProd(clientEntry, assetsManifest));
  const assetUrls = getAssetsUrl(clientDependencies, assetsManifest, config);
  return { clientEntriesSrc, assetUrls };
}
function getClientEntrySrcProd(clientEntry, assetsManifest) {
  const { manifestEntry } = getManifestEntry(clientEntry, assetsManifest);
  assert(manifestEntry.isEntry || manifestEntry.isDynamicEntry || clientEntry.endsWith(".css"), { clientEntry });
  let { file } = manifestEntry;
  assert(!file.startsWith("/"));
  return "/" + file;
}
function getAssetsUrl(clientDependencies, assetsManifest, config) {
  const includeAssetsImportedByServer = resolveIncludeAssetsImportedByServer(config);
  let assetUrls = /* @__PURE__ */ new Set();
  assert(assetsManifest);
  const visistedAssets = /* @__PURE__ */ new Set();
  clientDependencies.forEach(({ id, onlyAssets, eagerlyImported }) => {
    if (eagerlyImported)
      return;
    if (includeAssetsImportedByServer && onlyAssets && id.includes(".page.server.") && // We assume that all npm packages have already built their files: bundlers (Rollup, esbuild, tsup, ...) extract the CSS out of JavaScript => we can assume JavaScript to not import any CSS/assets.
    !isImportPathNpmPackage(id, {
      // I presume Vite already resolves path aliases when Vite sets the module's id
      cannotBePathAlias: true
    })) {
      id = extractAssetsAddQuery(id);
    }
    const { manifestKey } = getManifestEntry(id, assetsManifest);
    collectAssets(manifestKey, assetUrls, visistedAssets, assetsManifest, onlyAssets);
  });
  collectSingleStyle(assetUrls, assetsManifest);
  return Array.from(assetUrls);
}
function collectAssets(manifestKey, assetUrls, visistedAssets, assetsManifest, onlyCollectStaticAssets) {
  if (visistedAssets.has(manifestKey))
    return;
  visistedAssets.add(manifestKey);
  const manifestEntry = assetsManifest[manifestKey];
  assert(manifestEntry, { manifestKey });
  const { file } = manifestEntry;
  if (!onlyCollectStaticAssets) {
    assetUrls.add(`/${file}`);
  }
  const { imports = [], assets = [], css = [] } = manifestEntry;
  for (const manifestKey2 of imports) {
    const importManifestEntry = assetsManifest[manifestKey2];
    assert(importManifestEntry);
    collectAssets(manifestKey2, assetUrls, visistedAssets, assetsManifest, onlyCollectStaticAssets);
  }
  for (const cssAsset of css) {
    assetUrls.add(`/${cssAsset}`);
  }
  for (const asset of assets) {
    assetUrls.add(`/${asset}`);
  }
}
function collectSingleStyle(assetUrls, assetsManifest) {
  const style = assetsManifest["style.css"];
  if (style && Object.values(assetsManifest).filter((asset) => asset.file.endsWith(".css")).length === 1) {
    assetUrls.add(`/${style.file}`);
  }
}
function resolveIncludeAssetsImportedByServer(config) {
  return config.includeAssetsImportedByServer ?? true;
}
var init_retrievePageAssetsProd = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getPageAssets/retrievePageAssetsProd.js"() {
    init_utils3();
    init_getManifestEntry();
    init_extractAssetsQuery();
    __name(retrievePageAssetsProd, "retrievePageAssetsProd");
    __name(getClientEntrySrcProd, "getClientEntrySrcProd");
    __name(getAssetsUrl, "getAssetsUrl");
    __name(collectAssets, "collectAssets");
    __name(collectSingleStyle, "collectSingleStyle");
    __name(resolveIncludeAssetsImportedByServer, "resolveIncludeAssetsImportedByServer");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getPageAssets/retrievePageAssetsDev.js
async function retrievePageAssetsDev(viteDevServer, clientDependencies, clientEntries) {
  const clientEntriesSrc = clientEntries.map((clientEntry) => globalObject6.getClientEntrySrcDev(clientEntry, viteDevServer));
  const assetUrls = await getAssetUrls(clientDependencies, viteDevServer);
  return { clientEntriesSrc, assetUrls };
}
async function getAssetUrls(clientDependencies, viteDevServer) {
  const assetUrls = /* @__PURE__ */ new Set();
  await Promise.all(clientDependencies.map(async ({ id }) => {
    if (id.startsWith("@@vike"))
      return;
    assert(id);
    const virtualFile = parseVirtualFileId(id);
    assert(!virtualFile || virtualFile.type !== "global-entry");
    const { moduleGraph } = viteDevServer;
    const [_, graphId] = await moduleGraph.resolveUrl(id);
    assert(graphId, { id });
    const mod = moduleGraph.getModuleById(graphId);
    if (!mod) {
      return;
    }
    assert(mod, { id });
    collectCss(mod, assetUrls, /* @__PURE__ */ new Set());
  }));
  return Array.from(assetUrls);
}
function collectCss(mod, styleUrls, visitedModules, importer) {
  assert(mod);
  if (!mod.url)
    return;
  if (visitedModules.has(mod.url))
    return;
  visitedModules.add(mod.url);
  const virtualFile = parseVirtualFileId(mod.id || mod.url);
  if (virtualFile && virtualFile.type === "global-entry")
    return;
  if (isStyle(mod) && (!importer || !isStyle(importer))) {
    if (mod.url.startsWith("/")) {
      styleUrls.add(mod.url);
    } else if (mod.url.startsWith("\0")) {
      styleUrls.add(`/@id/__x00__${mod.url.substring(1)}`);
    } else {
      styleUrls.add(`/@id/${mod.url}`);
    }
  }
  mod.importedModules.forEach((dep) => {
    collectCss(dep, styleUrls, visitedModules, mod);
  });
}
function isStyle(mod) {
  return (
    // CSS-in-JS libraries such as [wyw-in-js](https://github.com/vikejs/vike/issues/2039)
    mod.type === "css" || // .css, .less, ...
    styleFileRE.test(mod.url) || // CSS of .vue files
    mod.id && /\?vue&type=style/.test(mod.id)
  );
}
var globalObject6;
var init_retrievePageAssetsDev = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getPageAssets/retrievePageAssetsDev.js"() {
    init_utils3();
    init_virtualFileId2();
    globalObject6 = getGlobalObject("getPageAssets/retrievePageAssetsDev.ts", {
      // We cannot define getClientEntrySrcDev() in this file because it depends on utils/requireResolve.ts which isn't available in production
      getClientEntrySrcDev: null
    });
    __name(retrievePageAssetsDev, "retrievePageAssetsDev");
    __name(getAssetUrls, "getAssetUrls");
    __name(collectCss, "collectCss");
    __name(isStyle, "isStyle");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/inferMediaType.js
function inferMediaType(href) {
  if (styleFileRE.test(href)) {
    return { mediaType: "text/css", assetType: "style" };
  }
  if (isScriptFile(href)) {
    return { mediaType: "text/javascript", assetType: "script" };
  }
  if (href.endsWith(".png")) {
    return { assetType: "image", mediaType: "image/png" };
  }
  if (href.endsWith(".webp")) {
    return { assetType: "image", mediaType: "image/webp" };
  }
  if (href.endsWith(".jpg") || href.endsWith(".jpeg")) {
    return { assetType: "image", mediaType: "image/jpeg" };
  }
  if (href.endsWith(".gif")) {
    return { assetType: "image", mediaType: "image/gif" };
  }
  if (href.endsWith(".svg")) {
    return { assetType: "image", mediaType: "image/svg+xml" };
  }
  if (href.endsWith(".avif")) {
    return { assetType: "image", mediaType: "image/avif" };
  }
  if (href.endsWith(".ttf")) {
    return { assetType: "font", mediaType: "font/ttf" };
  }
  if (href.endsWith(".woff")) {
    return { assetType: "font", mediaType: "font/woff" };
  }
  if (href.endsWith(".woff2")) {
    return { assetType: "font", mediaType: "font/woff2" };
  }
  if (href.endsWith(".mp4")) {
    return { assetType: "video", mediaType: "video/mp4" };
  }
  if (href.endsWith(".webm")) {
    return { assetType: "video", mediaType: "video/webm" };
  }
  if (href.endsWith(".ogv")) {
    return { assetType: "video", mediaType: "video/ogg" };
  }
  if (href.endsWith(".mpeg") || href.endsWith(".mpg")) {
    return { assetType: "video", mediaType: "video/mpeg" };
  }
  if (href.endsWith(".avi")) {
    return { assetType: "video", mediaType: "video/x-msvideo" };
  }
  if (href.endsWith(".mov") || href.endsWith(".qt")) {
    return { assetType: "video", mediaType: "video/quicktime" };
  }
  if (href.endsWith(".mp3")) {
    return { assetType: "audio", mediaType: "audio/mpeg" };
  }
  if (href.endsWith(".wav")) {
    return { assetType: "audio", mediaType: "audio/wav" };
  }
  if (href.endsWith(".ogg")) {
    return { assetType: "audio", mediaType: "audio/ogg" };
  }
  if (href.endsWith(".m4a")) {
    return { assetType: "audio", mediaType: "audio/aac" };
  }
  if (href.endsWith("midi") || href.endsWith(".mid")) {
    return { assetType: "audio", mediaType: "audio/midi" };
  }
  if (href.endsWith(".flac")) {
    return { assetType: "audio", mediaType: "audio/flac" };
  }
  return null;
}
var init_inferMediaType = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/inferMediaType.js"() {
    init_utils3();
    __name(inferMediaType, "inferMediaType");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getPageAssets/sortPageAssetsForEarlyHintsHeader.js
async function sortPageAssetsForEarlyHintsHeader(pageAssets, isProduction2) {
  pageAssets.sort(higherFirst(({ assetType }) => {
    if (!isProduction2 && assetType === "script") {
      return 1;
    }
    let priority = 0;
    if (assetType === "style")
      return priority;
    priority--;
    if (assetType === "font")
      return priority;
    priority--;
    if (assetType === "image")
      return priority;
    priority--;
    if (assetType === "video")
      return priority;
    priority--;
    if (assetType === "audio")
      return priority;
    priority--;
    if (assetType !== "script")
      return priority;
    priority--;
    return priority;
  }));
}
var init_sortPageAssetsForEarlyHintsHeader = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getPageAssets/sortPageAssetsForEarlyHintsHeader.js"() {
    init_utils3();
    __name(sortPageAssetsForEarlyHintsHeader, "sortPageAssetsForEarlyHintsHeader");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getPageAssets.js
async function getPageAssets(pageContext, clientDependencies, clientEntries) {
  const globalContext = pageContext._globalContext;
  const { _isProduction: isProduction2 } = globalContext;
  const isDev = !isProduction2;
  const { assetUrls, clientEntriesSrc } = isDev ? !globalContext._viteDevServer ? await getViteRPC().retrievePageAssetsDevRPC(clientDependencies, clientEntries) : await retrievePageAssetsDev(globalContext._viteDevServer, clientDependencies, clientEntries) : retrievePageAssetsProd(globalContext.assetsManifest, clientDependencies, clientEntries, globalContext.config);
  let pageAssets = [];
  unique([...clientEntriesSrc, ...assetUrls]).forEach((src) => {
    const { mediaType = null, assetType = null } = inferMediaType(src) || {};
    if (isDev && assetType === "style") {
      if (src.endsWith("?inline")) {
        return;
      }
      src = src + "?direct";
    }
    const isEntry = clientEntriesSrc.includes(src) || // Vite automatically injects CSS, not only in development, but also in production (albeit with a FOUC). Therefore, strictly speaking, CSS aren't entries. We still, however, set `isEntry: true` for CSS, in order to denote page assets that should absolutely be injected in the HTML, regardless of preload strategy (not injecting CSS leads to FOUC).
    assetType === "style";
    pageAssets.push({
      src,
      assetType,
      mediaType,
      isEntry
    });
  });
  pageAssets.forEach(({ src }) => {
    assert(1 === pageAssets.filter((p2) => p2.src === src).length);
  });
  pageAssets = pageAssets.map((pageAsset) => {
    const baseServerAssets = pageContext._baseAssets || pageContext._baseServer;
    pageAsset.src = prependBase(toPosixPath(pageAsset.src), baseServerAssets);
    return pageAsset;
  });
  await sortPageAssetsForEarlyHintsHeader(pageAssets, isProduction2);
  return pageAssets;
}
var init_getPageAssets = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/getPageAssets.js"() {
    init_retrievePageAssetsProd();
    init_retrievePageAssetsDev();
    init_inferMediaType();
    init_sortPageAssetsForEarlyHintsHeader();
    init_utils3();
    __name(getPageAssets, "getPageAssets");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/findPageConfig.js
function findPageConfig(pageConfigs, pageId) {
  const result = pageConfigs.filter((p2) => p2.pageId === pageId);
  assert(result.length <= 1);
  const pageConfig = result[0] ?? null;
  return pageConfig;
}
var init_findPageConfig = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/findPageConfig.js"() {
    init_utils();
    __name(findPageConfig, "findPageConfig");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/analyzeClientSide.js
function analyzeClientSide(pageConfig, pageFilesAll, pageId) {
  if (pageConfig) {
    const isClientRouting = getConfigValueRuntime(pageConfig, "clientRouting", "boolean")?.value ?? false;
    const isClientRuntimeLoaded = getConfigValueRuntime(pageConfig, "isClientRuntimeLoaded", "boolean")?.value ?? false;
    return { isClientRuntimeLoaded, isClientRouting };
  } else {
    const { isHtmlOnly, isClientRouting } = analyzePageClientSide(pageFilesAll, pageId);
    return { isClientRuntimeLoaded: !isHtmlOnly, isClientRouting };
  }
}
var init_analyzeClientSide = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/analyzeClientSide.js"() {
    init_getConfigValueRuntime();
    init_analyzePageClientSide();
    __name(analyzeClientSide, "analyzeClientSide");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/analyzePage.js
function analyzePage(pageContext) {
  const { pageId, _pageConfig: pageConfig, _globalContext: globalContext } = pageContext;
  const { _pageFilesAll: pageFilesAll } = globalContext;
  if (pageConfig) {
    const { isClientRuntimeLoaded, isClientRouting } = analyzeClientSide(pageConfig, pageFilesAll, pageId);
    const clientEntries = [];
    const clientFilePath = getConfigValueRuntime(pageConfig, "client", "string")?.value ?? null;
    if (clientFilePath)
      clientEntries.push(clientFilePath);
    if (isClientRuntimeLoaded)
      clientEntries.push(getVikeClientEntry(isClientRouting));
    const clientDependencies = [];
    clientDependencies.push({
      id: generateVirtualFileId({ type: "page-entry", pageId: pageConfig.pageId, isForClientSide: true }),
      onlyAssets: isClientRuntimeLoaded ? false : true,
      eagerlyImported: false
    });
    if (!globalContext._isProduction) {
      clientDependencies.push({
        id: generateVirtualFileId({ type: "page-entry", pageId: pageConfig.pageId, isForClientSide: false }),
        onlyAssets: true,
        eagerlyImported: false
      });
    }
    clientEntries.forEach((clientEntry) => {
      clientDependencies.push({
        id: clientEntry,
        onlyAssets: false,
        eagerlyImported: false
      });
    });
    return {
      isHtmlOnly: !isClientRuntimeLoaded,
      isClientRouting,
      clientEntries,
      clientDependencies,
      // pageFilesClientSide and pageFilesServerSide are only used for debugging
      pageFilesClientSide: [],
      pageFilesServerSide: []
    };
  } else {
    return analyzePageClientSide(pageFilesAll, pageId);
  }
}
var init_analyzePage = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/analyzePage.js"() {
    init_determineClientEntry();
    init_analyzePageClientSide();
    init_virtualFileId2();
    init_analyzeClientSide();
    init_getConfigValueRuntime();
    __name(analyzePage, "analyzePage");
  }
});

// node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/parse.js
function parse(str, options = {}) {
  const value = JSON.parse(str);
  return parseTransform(value, options);
}
function parseTransform(value, options = {}) {
  if (typeof value === "string") {
    return reviver(value, options);
  }
  if (
    // Also matches arrays
    typeof value === "object" && value !== null
  ) {
    Object.entries(value).forEach(([key, val]) => {
      ;
      value[key] = parseTransform(val, options);
    });
  }
  return value;
}
function reviver(value, options) {
  const parser = /* @__PURE__ */ __name((str) => parse(str, options), "parser");
  {
    const res = options.reviver?.(
      // TO-DO/eventually: provide key if some user needs it
      void 0,
      value,
      parser
    );
    if (res) {
      if (typeof res.replacement !== "string") {
        return res.replacement;
      } else {
        value = res.replacement;
        if (res.resolved)
          return value;
      }
    }
  }
  for (const { match, deserialize } of types) {
    if (match(value)) {
      return deserialize(value, parser);
    }
  }
  return value;
}
var init_parse = __esm({
  "node_modules/.pnpm/@brillout+json-serializer@0.5.20/node_modules/@brillout/json-serializer/dist/parse.js"() {
    init_types();
    __name(parse, "parse");
    __name(parseTransform, "parseTransform");
    __name(reviver, "reviver");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/assertPlusFileExport.js
function assertPlusFileExport(fileExports, filePathToShowToUser, configName) {
  const exportNames = Object.keys(fileExports);
  const isValid = /* @__PURE__ */ __name((exportName) => exportName === "default" || exportName === configName, "isValid");
  const exportNamesValid = exportNames.filter(isValid);
  const exportDefault = picocolors_default.code("export default");
  const exportNamed = picocolors_default.code(`export { ${configName} }`);
  if (exportNamesValid.length === 0) {
    assertUsage(false, `${filePathToShowToUser} should define ${exportNamed} or ${exportDefault}`);
  }
  if (exportNamesValid.length === 2) {
    assertUsage(false, `${filePathToShowToUser} is ambiguous: remove ${exportDefault} or ${exportNamed}`);
  }
  assert(exportNamesValid.length === 1);
  const exportNamesInvalid = exportNames.filter((e2) => !isValid(e2)).filter((exportName) => !SIDE_EXPORTS_TOLERATE.includes(exportName));
  if (!SIDE_EXPORTS_DO_NOT_CHECK.some((ext) => filePathToShowToUser.endsWith(ext))) {
    exportNamesInvalid.forEach((exportInvalid) => {
      assertWarning2(false, `${filePathToShowToUser} unexpected ${picocolors_default.cyan(`export { ${exportInvalid} }`)}, see https://vike.dev/no-side-exports`, {
        onlyOnce: true
      });
    });
  }
}
var SIDE_EXPORTS_TOLERATE, SIDE_EXPORTS_DO_NOT_CHECK;
var init_assertPlusFileExport = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/assertPlusFileExport.js"() {
    init_utils();
    init_picocolors();
    SIDE_EXPORTS_TOLERATE = [
      // vite-plugin-solid adds `export { $$registrations }`
      "$$registrations",
      // @vitejs/plugin-vue adds `export { _rerender_only }`
      "_rerender_only"
    ];
    SIDE_EXPORTS_DO_NOT_CHECK = [".md", ".mdx"];
    __name(assertPlusFileExport, "assertPlusFileExport");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/serialize/parsePageConfigsSerialized.js
function parsePageConfigsSerialized(pageConfigsSerialized2, pageConfigGlobalSerialized2) {
  const pageConfigs = pageConfigsSerialized2.map((pageConfigSerialized) => {
    const configValues = parseConfigValuesSerialized(pageConfigSerialized.configValuesSerialized);
    assertRouteConfigValue(configValues);
    const pageConfig = { ...pageConfigSerialized, configValues };
    return pageConfig;
  });
  const pageConfigGlobal = { configValues: {} };
  {
    const configValues = parseConfigValuesSerialized(pageConfigGlobalSerialized2.configValuesSerialized);
    Object.assign(pageConfigGlobal.configValues, configValues);
  }
  return { pageConfigs, pageConfigGlobal };
}
function assertRouteConfigValue(configValues) {
  const configName = "route";
  const configValue = configValues[configName];
  if (!configValue)
    return;
  const { value, definedAtData } = configValue;
  const configValueType = typeof value;
  assert(definedAtData);
  const configDefinedAt = getConfigDefinedAt("Config", configName, definedAtData);
  assertUsage(configValueType === "string" || isCallable(value), `${configDefinedAt} has an invalid type '${configValueType}': it should be a string or a function instead, see https://vike.dev/route`);
}
function parseConfigValuesSerialized(configValuesSerialized8) {
  const configValues = {};
  Object.entries(configValuesSerialized8).forEach(([configName, configValueSeriliazed]) => {
    let configValue;
    if (configValueSeriliazed.type === "cumulative") {
      const { valueSerialized, ...common } = configValueSeriliazed;
      const value = valueSerialized.map((valueSerializedElement, i) => {
        const { value: value2, sideExports } = parseValueSerialized(valueSerializedElement, configName, () => {
          const definedAtFile = configValueSeriliazed.definedAtData[i];
          assert(definedAtFile);
          return definedAtFile;
        });
        addSideExports(sideExports);
        return value2;
      });
      configValue = { value, ...common };
    } else {
      const { valueSerialized, ...common } = configValueSeriliazed;
      const { value, sideExports } = parseValueSerialized(valueSerialized, configName, () => {
        assert(configValueSeriliazed.type !== "computed");
        const { definedAtData } = configValueSeriliazed;
        const definedAtFile = Array.isArray(definedAtData) ? definedAtData[0] : definedAtData;
        return definedAtFile;
      });
      addSideExports(sideExports);
      configValue = { value, ...common };
    }
    configValues[configName] = configValue;
  });
  return configValues;
  function addSideExports(sideExports) {
    sideExports.forEach((sideExport) => {
      const { configName, configValue } = sideExport;
      if (!configValues[configName]) {
        configValues[configName] = configValue;
      } else {
      }
    });
  }
  __name(addSideExports, "addSideExports");
}
function parseValueSerialized(valueSerialized, configName, getDefinedAtFile) {
  if (valueSerialized.type === "js-serialized") {
    let { value } = valueSerialized;
    value = parseTransform(value);
    return { value, sideExports: [] };
  }
  if (valueSerialized.type === "pointer-import") {
    const { value } = valueSerialized;
    return { value, sideExports: [] };
  }
  if (valueSerialized.type === "plus-file") {
    const definedAtFile = getDefinedAtFile();
    const { exportValues } = valueSerialized;
    assert(!definedAtFile.definedBy);
    assertPlusFileExport(exportValues, definedAtFile.filePathToShowToUser, configName);
    let value;
    let valueWasFound = false;
    const sideExports = [];
    Object.entries(exportValues).forEach(([exportName, exportValue]) => {
      const isSideExport = exportName !== "default" && exportName !== configName;
      if (!isSideExport) {
        value = exportValue;
        assert(!valueWasFound);
        valueWasFound = true;
      } else {
        sideExports.push({
          configName: exportName,
          configValue: {
            type: "standard",
            // We don't support side exports for cumulative values. We could support it but it isn't trivial.
            value: exportValue,
            definedAtData: {
              filePathToShowToUser: definedAtFile.filePathToShowToUser,
              fileExportPathToShowToUser: [exportName]
            }
          }
        });
      }
    });
    assert(valueWasFound);
    return { value, sideExports };
  }
  assert(false);
}
var init_parsePageConfigsSerialized = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/serialize/parsePageConfigsSerialized.js"() {
    init_utils();
    init_getConfigDefinedAt();
    init_parse();
    init_assertPlusFileExport();
    __name(parsePageConfigsSerialized, "parsePageConfigsSerialized");
    __name(assertRouteConfigValue, "assertRouteConfigValue");
    __name(parseConfigValuesSerialized, "parseConfigValuesSerialized");
    __name(parseValueSerialized, "parseValueSerialized");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/loadAndParseVirtualFilePageEntry.js
async function loadAndParseVirtualFilePageEntry(pageConfig, isDev) {
  if ("isPageEntryLoaded" in pageConfig && // We don't need to cache in dev, since Vite already caches the virtual module
  !isDev) {
    return pageConfig;
  }
  const { moduleId, moduleExportsPromise } = pageConfig.loadVirtualFilePageEntry();
  const virtualFileExportsPageEntry = await moduleExportsPromise;
  if (!virtualFileExportsPageEntry)
    assert(false, { moduleExportsPromise, virtualFileExportsPageEntry, moduleId });
  const configValues = parseVirtualFileExportsPageEntry(virtualFileExportsPageEntry);
  Object.assign(pageConfig.configValues, configValues);
  objectAssign(pageConfig, { isPageEntryLoaded: true });
  return pageConfig;
}
function parseVirtualFileExportsPageEntry(virtualFileExportsPageEntry) {
  const configValues = parseConfigValuesSerialized(virtualFileExportsPageEntry.configValuesSerialized);
  return configValues;
}
var init_loadAndParseVirtualFilePageEntry = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/page-configs/loadAndParseVirtualFilePageEntry.js"() {
    init_utils();
    init_parsePageConfigsSerialized();
    __name(loadAndParseVirtualFilePageEntry, "loadAndParseVirtualFilePageEntry");
    __name(parseVirtualFileExportsPageEntry, "parseVirtualFileExportsPageEntry");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/humanizeTime.js
function humanizeTime(milliseconds) {
  const seconds2 = milliseconds / 1e3;
  if (seconds2 < 120) {
    const n = round(seconds2);
    return `${n} second${plural(n)}`;
  }
  {
    const minutes = seconds2 / 60;
    const n = round(minutes);
    return `${n} minute${plural(n)}`;
  }
}
function round(n) {
  let rounded = n.toFixed(1);
  if (rounded.endsWith(".0"))
    rounded = rounded.slice(0, -2);
  return rounded;
}
function plural(n) {
  return n === "1" ? "" : "s";
}
var init_humanizeTime = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/humanizeTime.js"() {
    __name(humanizeTime, "humanizeTime");
    __name(round, "round");
    __name(plural, "plural");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/hooks/getHook.js
function getHookFromPageContext(pageContext, hookName) {
  if (!(hookName in pageContext.exports)) {
    return null;
  }
  const { hooksTimeout } = pageContext.config;
  const hookTimeout = getHookTimeout(hooksTimeout, hookName);
  const hookFn = pageContext.exports[hookName];
  if (hookFn === null)
    return null;
  const file = pageContext.exportsAll[hookName][0];
  assert(file.exportValue === hookFn);
  const hookFilePath = file.filePath;
  assert(hookFilePath);
  return getHook(hookFn, hookName, hookFilePath, hookTimeout);
}
function getHookFromPageContextNew(hookName, pageContext) {
  const { hooksTimeout } = pageContext.config;
  const hookTimeout = getHookTimeout(hooksTimeout, hookName);
  const hooks = [];
  pageContext.exportsAll[hookName]?.forEach((val) => {
    const hookFn = val.exportValue;
    if (hookFn === null)
      return;
    const hookFilePath = val.filePath;
    assert(hookFilePath);
    hooks.push(getHook(hookFn, hookName, hookFilePath, hookTimeout));
  });
  return hooks;
}
function getHookFromPageConfigGlobal(pageConfigGlobal, hookName) {
  const configValue = pageConfigGlobal.configValues[hookName];
  if (!configValue?.value)
    return null;
  const { hookFn, hookFilePath } = getHookFromConfigValue(configValue);
  const hookTimeout = getHookTimeoutGlobal(hookName);
  return getHook(hookFn, hookName, hookFilePath, hookTimeout);
}
function getHookFromPageConfigGlobalCumulative(pageConfigGlobal, hookName) {
  const configValue = pageConfigGlobal.configValues[hookName];
  if (!configValue?.value)
    return [];
  const val = configValue.value;
  assert(isArray(val));
  return val.map((v, i) => {
    const hookFn = v;
    const hookTimeout = getHookTimeoutGlobal(hookName);
    assert(isArray(configValue.definedAtData));
    const hookFilePath = getHookFilePathToShowToUser(configValue.definedAtData[i]);
    return getHook(hookFn, hookName, hookFilePath, hookTimeout);
  });
}
function getHookTimeoutGlobal(hookName) {
  const hookTimeout = getHookTimeoutDefault(hookName);
  return hookTimeout;
}
function getHook(hookFn, hookName, hookFilePath, hookTimeout) {
  assert(hookFilePath);
  assertHookFn(hookFn, { hookName, hookFilePath });
  const hook2 = { hookFn, hookName, hookFilePath, hookTimeout };
  return hook2;
}
function getHookFromConfigValue(configValue) {
  const hookFn = configValue.value;
  assert(hookFn);
  const hookFilePath = getHookFilePathToShowToUser(configValue.definedAtData);
  return { hookFn, hookFilePath };
}
function assertHookFn(hookFn, { hookName, hookFilePath }) {
  assert(hookName && hookFilePath);
  assert(!hookName.endsWith(")"));
  assert(!hookFilePath.endsWith(" "));
  assertUsage(isCallable(hookFn), `Hook ${hookName}() defined by ${hookFilePath} should be a function`);
  checkType(hookFn);
}
function getHookTimeout(hooksTimeoutProvidedByUser, hookName) {
  const hooksTimeoutProvidedbyUserNormalized = getHooksTimeoutProvidedByUserNormalized(hooksTimeoutProvidedByUser);
  if (hooksTimeoutProvidedbyUserNormalized === false)
    return { error: false, warning: false };
  const providedbyUser = hooksTimeoutProvidedbyUserNormalized[hookName];
  const hookTimeout = getHookTimeoutDefault(hookName);
  if (providedbyUser?.error !== void 0)
    hookTimeout.error = providedbyUser.error;
  if (providedbyUser?.warning !== void 0)
    hookTimeout.warning = providedbyUser.warning;
  return hookTimeout;
}
function getHooksTimeoutProvidedByUserNormalized(hooksTimeoutProvidedByUser) {
  if (hooksTimeoutProvidedByUser === void 0)
    return {};
  if (hooksTimeoutProvidedByUser === false)
    return false;
  assertUsage(isObject(hooksTimeoutProvidedByUser), `Setting ${picocolors_default.cyan("hooksTimeout")} should be ${picocolors_default.cyan("false")} or an object`);
  const hooksTimeoutProvidedByUserNormalized = {};
  Object.entries(hooksTimeoutProvidedByUser).forEach(([hookName, hookTimeoutProvidedbyUser]) => {
    if (hookTimeoutProvidedbyUser === false) {
      hooksTimeoutProvidedByUserNormalized[hookName] = { error: false, warning: false };
      return;
    }
    assertUsage(isObject(hookTimeoutProvidedbyUser), `Setting ${picocolors_default.cyan(`hooksTimeout.${hookName}`)} should be ${picocolors_default.cyan("false")} or an object`);
    const [error, warning] = ["error", "warning"].map((timeoutName) => {
      const timeoutVal = hookTimeoutProvidedbyUser[timeoutName];
      if (timeoutVal === void 0 || timeoutVal === false)
        return timeoutVal;
      const errPrefix = `Setting ${picocolors_default.cyan(`hooksTimeout.${hookName}.${timeoutName}`)} should be`;
      assertUsage(typeof timeoutVal === "number", `${errPrefix} ${picocolors_default.cyan("false")} or a number`);
      assertUsage(timeoutVal > 0, `${errPrefix} a positive number`);
      return timeoutVal;
    });
    hooksTimeoutProvidedByUserNormalized[hookName] = { error, warning };
  });
  return hooksTimeoutProvidedByUserNormalized;
}
function getHookTimeoutDefault(hookName) {
  if (hookName === "onBeforeRoute") {
    return {
      error: 5 * 1e3,
      warning: 1 * 1e3
    };
  }
  if (globalObject7.isPrerendering) {
    return {
      error: 2 * 60 * 1e3,
      warning: 30 * 1e3
    };
  } else {
    assert(!hookName.toLowerCase().includes("prerender"));
  }
  return {
    error: 30 * 1e3,
    warning: 4 * 1e3
  };
}
var globalObject7;
var init_getHook = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/hooks/getHook.js"() {
    init_getGlobalObject();
    init_helpers();
    init_getConfigValueRuntime();
    init_utils();
    init_picocolors();
    globalObject7 = getGlobalObject("hooks/getHook.ts", {});
    __name(getHookFromPageContext, "getHookFromPageContext");
    __name(getHookFromPageContextNew, "getHookFromPageContextNew");
    __name(getHookFromPageConfigGlobal, "getHookFromPageConfigGlobal");
    __name(getHookFromPageConfigGlobalCumulative, "getHookFromPageConfigGlobalCumulative");
    __name(getHookTimeoutGlobal, "getHookTimeoutGlobal");
    __name(getHook, "getHook");
    __name(getHookFromConfigValue, "getHookFromConfigValue");
    __name(assertHookFn, "assertHookFn");
    __name(getHookTimeout, "getHookTimeout");
    __name(getHooksTimeoutProvidedByUserNormalized, "getHooksTimeoutProvidedByUserNormalized");
    __name(getHookTimeoutDefault, "getHookTimeoutDefault");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getProxyForPublicUsage.js
function getProxyForPublicUsage(obj, objName, skipOnInternalProp, fallback) {
  return new Proxy(obj, {
    get: getTrapGet(obj, objName, skipOnInternalProp, fallback)
  });
}
function getTrapGet(obj, objName, skipOnInternalProp, fallback) {
  return function(_, prop) {
    const propStr = String(prop);
    if (prop === "_isProxyObject")
      return true;
    if (!skipOnInternalProp)
      onInternalProp(propStr, objName);
    if (fallback && !(prop in obj)) {
      return fallback(prop);
    }
    const val = obj[prop];
    onNotSerializable(propStr, val, objName);
    return val;
  };
}
function onNotSerializable(propStr, val, objName) {
  if (val !== NOT_SERIALIZABLE)
    return;
  const propName = getPropAccessNotation(propStr);
  assert(isBrowser());
  assertUsage(false, `Can't access ${objName}${propName} on the client side. Because it can't be serialized, see server logs.`);
}
function onInternalProp(propStr, objName) {
  if (isBrowser())
    return;
  if (propStr === "_configFromHook")
    return;
  if (propStr.startsWith("_")) {
    assertWarning2(false, `Using internal ${objName}.${propStr} which may break in any minor version update. Reach out on GitHub to request official support for your use case.`, { onlyOnce: true, showStackTrace: true });
  }
}
var init_getProxyForPublicUsage = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getProxyForPublicUsage.js"() {
    init_NOT_SERIALIZABLE();
    init_utils();
    __name(getProxyForPublicUsage, "getProxyForPublicUsage");
    __name(getTrapGet, "getTrapGet");
    __name(onNotSerializable, "onNotSerializable");
    __name(onInternalProp, "onInternalProp");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/prepareGlobalContextForPublicUsage.js
function prepareGlobalContextForPublicUsage(globalContext) {
  assert(globalContext._isOriginalObject);
  const globalContextPublic = getProxyForPublicUsage(globalContext, "globalContext");
  return globalContextPublic;
}
var init_prepareGlobalContextForPublicUsage = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/prepareGlobalContextForPublicUsage.js"() {
    init_getProxyForPublicUsage();
    init_utils();
    __name(prepareGlobalContextForPublicUsage, "prepareGlobalContextForPublicUsage");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/preparePageContextForPublicUsage.js
function preparePageContextForPublicUsage(pageContext) {
  assert(!pageContext._isProxyObject);
  assert(!pageContext.globalContext);
  assert(pageContext._isOriginalObject);
  addIs404ToPageProps(pageContext);
  if (!("_pageId" in pageContext)) {
    Object.defineProperty(pageContext, "_pageId", {
      get() {
        assertWarning2(false, "pageContext._pageId has been renamed to pageContext.pageId", {
          showStackTrace: true,
          onlyOnce: true
        });
        return pageContext.pageId;
      },
      enumerable: false
    });
  }
  sortPageContext(pageContext);
  const globalContextPublic = prepareGlobalContextForPublicUsage(pageContext._globalContext);
  const pageContextPublic = getProxyForPublicUsage(
    pageContext,
    "pageContext",
    // We must skip it in the client-side because of the reactivity mechanism of UI frameworks like Solid.
    // - TO-DO/soon/proxy: double check whether that's true
    true,
    (prop) => {
      if (prop === "globalContext") {
        return globalContextPublic;
      }
      if (prop in globalContextPublic) {
        return globalContextPublic[prop];
      }
    }
  );
  return pageContextPublic;
}
function sortPageContext(pageContext) {
  let descriptors = Object.getOwnPropertyDescriptors(pageContext);
  for (const key of Object.keys(pageContext))
    delete pageContext[key];
  descriptors = Object.fromEntries(Object.entries(descriptors).sort(([key1], [key2]) => compareString(key1, key2)));
  Object.defineProperties(pageContext, descriptors);
}
function assertPropertyGetters(pageContext) {
  ;
  [
    "urlPathname",
    // TO-DO/next-major-release: remove
    "urlParsed",
    // TO-DO/next-major-release: remove
    "url",
    // TO-DO/next-major-release: remove
    "pageExports"
  ].forEach((prop) => {
    if (pageContext.prop)
      assert(isPropertyGetter(pageContext, prop));
  });
}
var init_preparePageContextForPublicUsage = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/preparePageContextForPublicUsage.js"() {
    init_utils();
    init_addIs404ToPageProps();
    init_prepareGlobalContextForPublicUsage();
    init_getProxyForPublicUsage();
    __name(preparePageContextForPublicUsage, "preparePageContextForPublicUsage");
    __name(sortPageContext, "sortPageContext");
    __name(assertPropertyGetters, "assertPropertyGetters");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/hooks/execHook.js
async function execHook(hookName, pageContext, preparePageContextForPublicUsage2) {
  const hooks = getHookFromPageContextNew(hookName, pageContext);
  return await execHookDirect(hooks, pageContext, preparePageContextForPublicUsage2);
}
async function execHookGlobal(hookName, pageConfigGlobal, pageContext, hookArg, prepareForPublicUsage) {
  const hooks = getHookFromPageConfigGlobalCumulative(pageConfigGlobal, hookName);
  const hookArgForPublicUsage = prepareForPublicUsage(hookArg);
  await Promise.all(hooks.map(async (hook2) => {
    await execHookDirectAsync(() => hook2.hookFn(hookArgForPublicUsage), hook2, pageContext);
  }));
}
async function execHookDirect(hooks, pageContext, preparePageContextForPublicUsage2) {
  if (!hooks.length)
    return [];
  const pageContextForPublicUsage = preparePageContextForPublicUsage2(pageContext);
  const hooksWithResult = await Promise.all(hooks.map(async (hook2) => {
    const hookReturn = await execHookDirectAsync(() => hook2.hookFn(pageContextForPublicUsage), hook2, pageContextForPublicUsage);
    return { ...hook2, hookReturn };
  }));
  return hooksWithResult;
}
async function execHookDirectSingle(hook2, pageContext, preparePageContextForPublicUsage2) {
  const hooksWithResult = await execHookDirect([hook2], pageContext, preparePageContextForPublicUsage2);
  const { hookReturn } = hooksWithResult[0];
  assertUsage(hookReturn === void 0, `The ${hook2.hookName}() hook defined by ${hook2.hookFilePath} isn't allowed to return a value`);
}
async function execHookDirectSingleWithReturn(hook2, pageContext, preparePageContextForPublicUsage2) {
  const hooksWithResult = await execHookDirect([hook2], pageContext, preparePageContextForPublicUsage2);
  const { hookReturn } = hooksWithResult[0];
  return { hookReturn };
}
function isUserHookError(err) {
  if (!isObject(err))
    return false;
  return globalObject8.userHookErrors.get(err) ?? false;
}
function execHookDirectAsync(hookFnCaller, hook2, pageContextForPublicUsage) {
  const { hookName, hookFilePath, hookTimeout: { error: timeoutErr, warning: timeoutWarn } } = hook2;
  let resolve;
  let reject;
  const promise = new Promise((resolve_, reject_) => {
    resolve = /* @__PURE__ */ __name((ret) => {
      clearTimeouts();
      resolve_(ret);
    }, "resolve");
    reject = /* @__PURE__ */ __name((err) => {
      clearTimeouts();
      reject_(err);
    }, "reject");
  });
  const clearTimeouts = /* @__PURE__ */ __name(() => {
    if (currentTimeoutWarn)
      clearTimeout(currentTimeoutWarn);
    if (currentTimeoutErr)
      clearTimeout(currentTimeoutErr);
  }, "clearTimeouts");
  const currentTimeoutWarn = isNotDisabled(timeoutWarn) && setTimeout(() => {
    assertWarning2(false, `The ${hookName}() hook defined by ${hookFilePath} is slow: it's taking more than ${humanizeTime(timeoutWarn)} (https://vike.dev/hooksTimeout)`, { onlyOnce: false });
  }, timeoutWarn);
  const currentTimeoutErr = isNotDisabled(timeoutErr) && setTimeout(() => {
    const err = getProjectError(`The ${hookName}() hook defined by ${hookFilePath} timed out: it didn't finish after ${humanizeTime(timeoutErr)} (https://vike.dev/hooksTimeout)`);
    reject(err);
  }, timeoutErr);
  (async () => {
    try {
      providePageContextInternal(pageContextForPublicUsage);
      const ret = await hookFnCaller();
      resolve(ret);
    } catch (err) {
      if (isObject(err)) {
        globalObject8.userHookErrors.set(err, { hookName, hookFilePath });
      }
      reject(err);
    }
  })();
  return promise;
}
function execHookDirectSync(hook2, pageContext, preparePageContextForPublicUsage2) {
  const pageContextForPublicUsage = preparePageContextForPublicUsage2(pageContext);
  providePageContextInternal(pageContextForPublicUsage);
  const hookReturn = hook2.hookFn(pageContextForPublicUsage);
  return { hookReturn };
}
function isNotDisabled(timeout) {
  return !!timeout && timeout !== Infinity;
}
function providePageContextInternal(pageContext) {
  globalObject8.pageContext = pageContext;
  Promise.resolve().then(() => {
    globalObject8.pageContext = null;
  });
}
var globalObject8;
var init_execHook = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/hooks/execHook.js"() {
    init_assert();
    init_getGlobalObject();
    init_humanizeTime();
    init_isObject();
    init_getHook();
    init_preparePageContextForPublicUsage();
    globalObject8 = getGlobalObject("utils/execHook.ts", {
      userHookErrors: /* @__PURE__ */ new WeakMap(),
      pageContext: null
    });
    __name(execHook, "execHook");
    __name(execHookGlobal, "execHookGlobal");
    __name(execHookDirect, "execHookDirect");
    __name(execHookDirectSingle, "execHookDirectSingle");
    __name(execHookDirectSingleWithReturn, "execHookDirectSingleWithReturn");
    __name(isUserHookError, "isUserHookError");
    __name(execHookDirectAsync, "execHookDirectAsync");
    __name(execHookDirectSync, "execHookDirectSync");
    __name(isNotDisabled, "isNotDisabled");
    __name(providePageContextInternal, "providePageContextInternal");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/preparePageContextForPublicUsageServer.js
function preparePageContextForPublicUsageServer(pageContext) {
  assertPropertyGetters(pageContext);
  pageContext = preparePageContextForPublicUsage(pageContext);
  return pageContext;
}
var init_preparePageContextForPublicUsageServer = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/preparePageContextForPublicUsageServer.js"() {
    init_preparePageContextForPublicUsage();
    __name(preparePageContextForPublicUsageServer, "preparePageContextForPublicUsageServer");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/execHookServer.js
async function execHookServer(hookName, pageContext) {
  return await execHook(hookName, pageContext, preparePageContextForPublicUsageServer);
}
var init_execHookServer = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/execHookServer.js"() {
    init_execHook();
    init_preparePageContextForPublicUsageServer();
    __name(execHookServer, "execHookServer");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/loadPageConfigsLazyServerSide.js
async function loadPageConfigsLazyServerSide(pageContext) {
  objectAssign(pageContext, {
    _pageConfig: findPageConfig(pageContext._globalContext._pageConfigs, pageContext.pageId)
  });
  updateType(pageContext, await loadPageUserFiles(pageContext));
  updateType(pageContext, await resolvePageContext(pageContext));
  await execHookServer("onCreatePageContext", pageContext);
  return pageContext;
}
async function resolvePageContext(pageContext) {
  const { isHtmlOnly, clientEntries, clientDependencies } = analyzePage(pageContext);
  const passToClient = [];
  const errMsgSuffix = " should be an array of strings.";
  const isV1Design = !!pageContext._pageConfig;
  if (!isV1Design) {
    pageContext.exportsAll.passToClient?.forEach((e2) => {
      assertUsage(hasProp(e2, "exportValue", "string[]"), `${e2.exportSource}${errMsgSuffix}`);
      passToClient.push(...e2.exportValue);
    });
  } else {
    pageContext.from.configsCumulative.passToClient?.values.forEach((v) => {
      const { value, definedAt } = v;
      const errMsg = `+passToClient value defined at ${definedAt}${errMsgSuffix}`;
      assertUsage(isArray(value), `+passToClient value defined at ${definedAt} should be an array`);
      const valS = value.map((el) => {
        if (isObject(el)) {
          assertWarning2(!("once" in el), "The passToClient once setting is deprecated and no longer has any effect. Instead, see the upcoming .once.js suffix (see https://github.com/vikejs/vike/issues/2566 for more information).", { onlyOnce: true });
          assertUsage(hasProp(el, "prop", "string"), errMsg);
          return el.prop;
        }
        assertUsage(typeof el === "string", errMsg);
        return el;
      });
      passToClient.push(...valS);
    });
  }
  objectAssign(pageContext, {
    Page: pageContext.exports.Page,
    _isHtmlOnly: isHtmlOnly,
    _passToClient: passToClient,
    headersResponse: resolveHeadersResponse(pageContext)
  });
  objectAssign(pageContext, {
    __getPageAssets: /* @__PURE__ */ __name(async () => {
      if ("_pageAssets" in pageContext) {
        return pageContext._pageAssets;
      } else {
        const pageAssets = await getPageAssets(pageContext, clientDependencies, clientEntries);
        objectAssign(pageContext, { _pageAssets: pageAssets });
        return pageContext._pageAssets;
      }
    }, "__getPageAssets")
  });
  Object.assign(pageContext, {
    _getPageAssets: /* @__PURE__ */ __name(async () => {
      assertWarning2(false, "pageContext._getPageAssets() deprecated, see https://vike.dev/preloading", {
        onlyOnce: true,
        showStackTrace: true
      });
      const pageAssetsOldFormat = [];
      (await pageContext.__getPageAssets()).forEach((p2) => {
        if (p2.assetType === "script" && p2.isEntry) {
          pageAssetsOldFormat.push({
            src: p2.src,
            preloadType: null,
            assetType: "script",
            mediaType: p2.mediaType
          });
        }
        pageAssetsOldFormat.push({
          src: p2.src,
          preloadType: p2.assetType,
          assetType: p2.assetType === "style" ? "style" : "preload",
          mediaType: p2.mediaType
        });
      });
      return pageAssetsOldFormat;
    }, "_getPageAssets")
  });
  return pageContext;
}
async function loadPageUserFiles(pageContext) {
  const [{ configPublicPageLazy }] = await Promise.all([
    loadPageUserFiles_v1Design(pageContext),
    analyzePageClientSideInit(pageContext._globalContext._pageFilesAll, pageContext.pageId, {
      sharedPageFilesAlreadyLoaded: true
    })
  ]);
  objectAssign(pageContext, configPublicPageLazy);
  return pageContext;
}
async function loadPageUserFiles_v1Design(pageContext) {
  const pageFilesServerSide = getPageFilesServerSide(pageContext._pageFilesAll, pageContext.pageId);
  const isDev = !pageContext._globalContext._isProduction;
  const pageConfigLoaded = !pageContext._pageConfig ? null : await loadAndParseVirtualFilePageEntry(pageContext._pageConfig, isDev);
  await Promise.all(pageFilesServerSide.map((p2) => p2.loadFile?.()));
  const configPublicPageLazy = resolveVikeConfigPublicPageLazyLoaded(pageFilesServerSide, pageConfigLoaded, pageContext._globalContext._pageConfigGlobal);
  return {
    configPublicPageLazy,
    pageFilesLoaded: pageFilesServerSide
  };
}
function resolveHeadersResponse(pageContext) {
  const headersResponse = mergeHeaders(pageContext.config.headersResponse);
  if (!headersResponse.get("Cache-Control")) {
    const cacheControl = getCacheControl(pageContext.pageId, pageContext._globalContext._pageConfigs);
    if (cacheControl)
      headersResponse.set("Cache-Control", cacheControl);
  }
  return headersResponse;
}
function mergeHeaders(headersList = []) {
  const headersMerged = new Headers();
  headersList.forEach((headers) => {
    new Headers(headers).forEach((value, key) => {
      headersMerged.append(key, value);
    });
  });
  return headersMerged;
}
var init_loadPageConfigsLazyServerSide = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/loadPageConfigsLazyServerSide.js"() {
    init_getPageFiles();
    init_resolveVikeConfigPublic();
    init_analyzePageClientSide();
    init_utils3();
    init_getPageAssets();
    init_findPageConfig();
    init_analyzePage();
    init_loadAndParseVirtualFilePageEntry();
    init_execHookServer();
    init_getCacheControl();
    __name(loadPageConfigsLazyServerSide, "loadPageConfigsLazyServerSide");
    __name(resolvePageContext, "resolvePageContext");
    __name(loadPageUserFiles, "loadPageUserFiles");
    __name(loadPageUserFiles_v1Design, "loadPageUserFiles_v1Design");
    __name(resolveHeadersResponse, "resolveHeadersResponse");
    __name(mergeHeaders, "mergeHeaders");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/assertHookReturnedObject.js
function assertHookReturnedObject(obj, keysExpected, errPrefix) {
  assert(!errPrefix.endsWith(" "));
  const keysUnknown = [];
  const keys = Object.keys(obj);
  for (const key of keys) {
    if (!keysExpected.includes(key)) {
      keysUnknown.push(key);
    }
  }
  assertUsage(keysUnknown.length === 0, [
    errPrefix,
    "returned an object with following unknown keys:",
    stringifyStringArray(keysUnknown) + ".",
    "Only following keys are allowed:",
    stringifyStringArray(keysExpected) + "."
  ].join(" "));
}
var init_assertHookReturnedObject = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/assertHookReturnedObject.js"() {
    init_utils();
    __name(assertHookReturnedObject, "assertHookReturnedObject");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertRoutingType.js
function assertClientRouting() {
  assertNoContradiction(checkIfClientRouting());
  state.isClientRouting = true;
}
function checkIfClientRouting() {
  return state.isClientRouting !== false;
}
function assertNoContradiction(noContradiction) {
  assertUsage(isBrowser(), `${picocolors_default.cyan("import { something } from 'vike/client/router'")} is forbidden on the server-side`, { showStackTrace: true });
  assertWarning2(noContradiction, "You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.", { showStackTrace: true, onlyOnce: true });
}
var state;
var init_assertRoutingType = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/utils/assertRoutingType.js"() {
    init_assert();
    init_getGlobalObject();
    init_isBrowser();
    init_picocolors();
    state = getGlobalObject("utils/assertRouterType.ts", {});
    __name(assertClientRouting, "assertClientRouting");
    __name(checkIfClientRouting, "checkIfClientRouting");
    __name(assertNoContradiction, "assertNoContradiction");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/utils.js
var init_utils4 = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/utils.js"() {
    init_assertRoutingType();
    init_isBrowser();
    init_assert();
    init_hasProp();
    init_isObjectWithKeys();
    init_sorter();
    init_isPromise();
    init_isPlainObject();
    init_objectAssign();
    init_slice();
    init_unique();
    init_isBrowser();
    init_parseUrl();
    init_checkType();
    init_joinEnglish();
    init_truncateString();
    init_isCallable();
    if (isBrowser()) {
      assertClientRouting();
    }
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/abort.js
function isAbortError(thing) {
  return typeof thing === "object" && thing !== null && stamp3 in thing;
}
function logAbortErrorHandled(err, isProduction2, pageContext) {
  if (isProduction2)
    return;
  const urlCurrent = pageContext._urlRewrite ?? pageContext.urlOriginal;
  assert(urlCurrent);
  const abortCall = err._pageContextAbort._abortCall;
  assert(abortCall);
  const hookLoc = isUserHookError(err);
  let thrownBy = "";
  if (hookLoc) {
    thrownBy = ` by ${picocolors_default.cyan(`${hookLoc.hookName}()`)} hook defined at ${hookLoc.hookFilePath}`;
  } else {
  }
  assertInfo(false, `${picocolors_default.cyan(abortCall)} thrown${thrownBy} while rendering ${picocolors_default.cyan(urlCurrent)}`, {
    onlyOnce: false
  });
}
function getPageContextFromAllRewrites(pageContextsFromRewrite) {
  assertNoInfiniteLoop(pageContextsFromRewrite);
  const pageContextFromAllRewrites = { _urlRewrite: null };
  pageContextsFromRewrite.forEach((pageContextFromRewrite) => {
    Object.assign(pageContextFromAllRewrites, pageContextFromRewrite);
  });
  return pageContextFromAllRewrites;
}
function assertNoInfiniteLoop(pageContextsFromRewrite) {
  const urlRewrites = [];
  pageContextsFromRewrite.forEach((pageContext) => {
    const urlRewrite = pageContext._urlRewrite;
    {
      const idx = urlRewrites.indexOf(urlRewrite);
      if (idx !== -1) {
        const loop = [...urlRewrites.slice(idx), urlRewrite].map((url) => `render('${url}')`).join(" => ");
        assertUsage(false, `Infinite loop of render() calls: ${loop}`);
      }
    }
    urlRewrites.push(urlRewrite);
  });
}
function assertNoInfiniteAbortLoop(rewriteCount, redirectCount) {
  const abortCalls = [
    // prettier-ignore
    // biome-ignore format:
    rewriteCount > 0 && picocolors_default.cyan("throw render('/some-url')"),
    redirectCount > 0 && picocolors_default.cyan("throw redirect('/some-url')")
  ].filter(Boolean).join(" and ");
  assertUsage(rewriteCount + redirectCount <= 7, `Maximum chain length of 7 ${abortCalls} exceeded. Did you define an infinite loop of ${abortCalls}?`);
}
var stamp3;
var init_abort = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/abort.js"() {
    init_execHook();
    init_utils4();
    init_picocolors();
    stamp3 = "_isAbortError";
    __name(isAbortError, "isAbortError");
    __name(logAbortErrorHandled, "logAbortErrorHandled");
    __name(getPageContextFromAllRewrites, "getPageContextFromAllRewrites");
    __name(assertNoInfiniteLoop, "assertNoInfiniteLoop");
    __name(assertNoInfiniteAbortLoop, "assertNoInfiniteAbortLoop");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/isNewError.js
function isNewError(errErrorPage, errNominalPage) {
  warnIfErrorIsNotObject(errErrorPage);
  return !isSameErrorMessage(errNominalPage, errErrorPage) || // Isn't this redudant/superfluous? I think we can remove this entire file and only use isSameErrorMessage() instead.
  !hasAlreadyLogged(errNominalPage);
}
function hasAlreadyLogged(err) {
  if (!isObject(err))
    return false;
  return globalObject9.wasAlreadyLogged.has(err);
}
function setAlreadyLogged(err) {
  if (!isObject(err))
    return;
  globalObject9.wasAlreadyLogged.add(err);
}
var globalObject9;
var init_isNewError = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/isNewError.js"() {
    init_utils3();
    globalObject9 = getGlobalObject("renderPage/isNewError.ts", {
      wasAlreadyLogged: /* @__PURE__ */ new WeakSet()
    });
    __name(isNewError, "isNewError");
    __name(hasAlreadyLogged, "hasAlreadyLogged");
    __name(setAlreadyLogged, "setAlreadyLogged");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/logErrorHint.js
function logErrorHint(error) {
  const hint = getErrorHint(error);
  if (hint)
    logHint(hint);
}
function getErrorHint(error) {
  {
    const knownErr = isKnownError(error);
    if (knownErr) {
      if (knownErr.link) {
        return hintLinkPrefix + knownErr.link;
      } else {
        return hintDefault;
      }
    }
  }
  return null;
}
function logHint(hint) {
  hint = formatHintLog(hint);
  hint = picocolors_default.bold(hint);
  console.error(hint);
}
function isKnownError(error) {
  const anywhere = getAnywhere(error);
  const knownErr = [
    //
    ...errorsMisc,
    ...errorsReact,
    ...errorsCjsEsm_withPreciseLink,
    ...errorsCjsEsm
  ].find((knownError) => {
    if (!includesLowercase(anywhere, knownError.errMsg))
      return false;
    if (knownError.mustMentionNodeModules !== false && !includesLowercase(anywhere, "node_modules"))
      return false;
    return true;
  });
  if (!knownErr)
    return false;
  return knownErr;
}
function includesLowercase(str, substr) {
  if (substr instanceof RegExp) {
    let { flags: flags2 } = substr;
    if (!flags2.includes("i"))
      flags2 += "i";
    const regex = new RegExp(substr.source, flags2);
    return regex.test(str);
  }
  if (typeof substr === "string") {
    return str.toLowerCase().includes(substr.toLowerCase());
  }
  assert(false);
}
function getAnywhere(error) {
  const code = getErrCode(error);
  const message = getErrMessage(error);
  const stack = getErrStack(error);
  const anywhere = [code, message, stack].filter(Boolean).join("\n");
  return anywhere;
}
function getErrMessage(err) {
  if (!isObject(err))
    return null;
  if (!err.message)
    return null;
  if (typeof err.message !== "string")
    return null;
  return err.message;
}
function getErrCode(err) {
  if (!isObject(err))
    return null;
  if (!err.code)
    return null;
  if (typeof err.code !== "string")
    return null;
  return err.code;
}
function getErrStack(err) {
  if (!isObject(err))
    return null;
  if (!err.stack)
    return null;
  if (typeof err.stack !== "string")
    return null;
  return err.stack;
}
var hintDefault, hintLinkPrefix, errorsMisc, reactInvalidEelement, errorsReact, errorsCjsEsm_withPreciseLink, errorsCjsEsm;
var init_logErrorHint = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/logErrorHint.js"() {
    init_utils3();
    init_picocolors();
    hintDefault = "The error could be a CJS/ESM issue, see https://vike.dev/broken-npm-package";
    hintLinkPrefix = "To fix this error, see ";
    errorsMisc = [
      {
        errMsg: "window is not defined",
        link: "https://vike.dev/hints#window-is-not-defined",
        mustMentionNodeModules: false
      },
      {
        errMsg: "jsxDEV is not a function",
        link: "https://github.com/vikejs/vike/issues/1469#issuecomment-1919518096",
        mustMentionNodeModules: false
      },
      {
        // ```
        // Error [RollupError]: Could not resolve "../dist/client/assets.json" from "renderer/+onRenderHtml.tsx"
        // ```
        errMsg: "assets.json",
        link: "https://vike.dev/getGlobalContext",
        mustMentionNodeModules: false
      },
      {
        errMsg: "ERR_UNKNOWN_FILE_EXTENSION",
        link: "https://vike.dev/broken-npm-package#err-unknown-file-extension"
      }
    ];
    reactInvalidEelement = "https://vike.dev/broken-npm-package#react-invalid-component";
    errorsReact = [
      {
        errMsg: "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components)",
        link: reactInvalidEelement,
        // The stack trace can be user-land while the import is coming from node_modules
        mustMentionNodeModules: false
      },
      {
        errMsg: "Objects are not valid as a React child",
        link: reactInvalidEelement,
        mustMentionNodeModules: false
      },
      {
        // React's "Invalid hook call.", see https://github.com/vikejs/vike/discussions/1637#discussioncomment-9424712
        errMsg: "Cannot read properties of null (reading 'useContext')"
      }
    ];
    errorsCjsEsm_withPreciseLink = [
      {
        // `SyntaxError: Named export '${exportName}' not found. The requested module '${packageName}' is a CommonJS module, which may not support all module.exports as named exports.`
        errMsg: /Named export.*not found/i,
        link: "https://vike.dev/broken-npm-package#named-export-not-found",
        // It seems that this always points to an npm package import.
        mustMentionNodeModules: false
      }
    ];
    errorsCjsEsm = [
      { errMsg: "ERR_UNSUPPORTED_DIR_IMPORT" },
      { errMsg: "ERR_REQUIRE_ESM" },
      { errMsg: "Must use import" },
      { errMsg: /Cannot find \S+ '(\S+)' imported from (\S+)/ },
      { errMsg: "ERR_UNKNOWN_FILE_EXTENSION" },
      { errMsg: /Unknown file extension "\S+" for (\S+)/ },
      // `SyntaxError: Cannot use import statement outside a module`.
      {
        errMsg: "Cannot use import statement",
        // Since user code is always ESM, this error must always originate from an npm package.
        mustMentionNodeModules: false
      },
      { errMsg: "is not exported" },
      { errMsg: "Cannot read properties of undefined" },
      { errMsg: ".default is not" },
      // Using CJS inside ESM modules.
      { errMsg: "require is not a function" },
      { errMsg: "exports is not defined" },
      { errMsg: "module is not defined" },
      { errMsg: "not defined in ES" },
      { errMsg: "Unexpected token 'export'" },
      { errMsg: "Failed to resolve entry for package" }
    ];
    __name(logErrorHint, "logErrorHint");
    __name(getErrorHint, "getErrorHint");
    __name(logHint, "logHint");
    __name(isKnownError, "isKnownError");
    __name(includesLowercase, "includesLowercase");
    __name(getAnywhere, "getAnywhere");
    __name(getErrMessage, "getErrMessage");
    __name(getErrCode, "getErrCode");
    __name(getErrStack, "getErrStack");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/loggerProd.js
function logErrorProd(err, _httpRequestId) {
  warnIfErrorIsNotObject(err);
  setAlreadyLogged(err);
  if (isAbortError(err)) {
    return;
  }
  const errStr = isObject(err) && "stack" in err ? String(err.stack) : String(err);
  console.error(picocolors_default.red(errStr));
  onRuntimeError(err);
}
function onRuntimeError(err) {
  logErrorHint(err);
}
var init_loggerProd = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/loggerProd.js"() {
    init_abort();
    init_isNewError();
    init_utils3();
    init_picocolors();
    init_logErrorHint();
    __name(logErrorProd, "logErrorProd");
    __name(onRuntimeError, "onRuntimeError");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/loggerRuntime.js
var logRuntimeError, logRuntimeInfo;
var init_loggerRuntime = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/loggerRuntime.js"() {
    init_loggerProd();
    logRuntimeInfo = null;
    logRuntimeError = // @ts-expect-error
    logRuntimeError ?? // Default
    logErrorProd;
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/execHookOnRenderHtml.js
async function execHookOnRenderHtml(pageContext) {
  const hook2 = getRenderHook(pageContext);
  objectAssign(pageContext, { _renderHook: hook2 });
  const { hookReturn } = await execHookDirectSingleWithReturn(hook2, pageContext, preparePageContextForPublicUsageServer);
  const { documentHtml, pageContextProvidedByRenderHook, pageContextPromise, injectFilter } = processHookReturnValue(hookReturn, hook2);
  Object.assign(pageContext, pageContextProvidedByRenderHook);
  objectAssign(pageContext, { _pageContextPromise: pageContextPromise });
  const onErrorWhileStreaming = /* @__PURE__ */ __name((err) => {
    logRuntimeError(err, pageContext._httpRequestId);
    if (!pageContext.errorWhileRendering) {
      pageContext.errorWhileRendering = err;
    }
  }, "onErrorWhileStreaming");
  const htmlRender = await renderDocumentHtml(documentHtml, pageContext, onErrorWhileStreaming, injectFilter);
  assert(typeof htmlRender === "string" || isStream(htmlRender));
  return { htmlRender, renderHook: hook2 };
}
function getRenderHook(pageContext) {
  let hookFound;
  {
    let hook2;
    let hookName = void 0;
    hook2 = getHookFromPageContext(pageContext, "onRenderHtml");
    if (hook2) {
      hookName = "onRenderHtml";
    } else {
      hook2 = getHookFromPageContext(pageContext, "render");
      if (hook2) {
        hookName = "render";
      }
    }
    if (hook2) {
      assert(hookName);
      const { hookFilePath, hookFn, hookTimeout } = hook2;
      hookFound = { hookFn, hookFilePath, hookName, hookTimeout };
    }
  }
  if (!hookFound) {
    const hookName = pageContext._globalContext._pageConfigs.length > 0 ? "onRenderHtml" : "render";
    assertUsage(false, `No ${hookName}() hook found, see https://vike.dev/${hookName}`);
  }
  return hookFound;
}
function processHookReturnValue(hookReturnValue, renderHook) {
  let documentHtml;
  let pageContextPromise = null;
  let pageContextProvidedByRenderHook = null;
  let injectFilter = null;
  if (isDocumentHtml(hookReturnValue)) {
    documentHtml = hookReturnValue;
    return { documentHtml, pageContextProvidedByRenderHook, pageContextPromise, injectFilter };
  }
  const errPrefix = `The ${renderHook.hookName}() hook defined at ${renderHook.hookFilePath}`;
  const errSuffix = `a string generated with ${picocolors_default.cyan("escapeInject`<html>...</html>`")} or the value returned by ${picocolors_default.cyan("dangerouslySkipEscape()")}, see https://vike.dev/escapeInject`;
  if (typeof hookReturnValue === "string") {
    assertWarning2(false, [
      errPrefix,
      `returned a plain JavaScript string which is ${picocolors_default.red(picocolors_default.bold("dangerous"))}: it should instead return`,
      errSuffix
    ].join(" "), { onlyOnce: true });
    hookReturnValue = dangerouslySkipEscape(hookReturnValue);
  }
  const wrongReturnValue = `should return the value ${picocolors_default.cyan("documentHtml")} or an object ${picocolors_default.cyan("{ documentHtml }")} where ${picocolors_default.cyan("documentHtml")} is ${errSuffix}`;
  assertUsage(isObject(hookReturnValue), `${errPrefix} ${wrongReturnValue}`);
  assertHookReturnedObject(hookReturnValue, ["documentHtml", "pageContext", "injectFilter"], errPrefix);
  assertUsage(hookReturnValue.documentHtml, `${errPrefix} returned an object that is missing the ${picocolors_default.code("documentHtml")} property: it ${wrongReturnValue}`);
  if (hookReturnValue.injectFilter) {
    assertUsage(isCallable(hookReturnValue.injectFilter), "injectFilter should be a function");
    injectFilter = hookReturnValue.injectFilter;
  }
  {
    let val = hookReturnValue.documentHtml;
    const errBegin = `${errPrefix} returned ${picocolors_default.cyan("{ documentHtml }")}, but ${picocolors_default.cyan("documentHtml")}`;
    if (typeof val === "string") {
      assertWarning2(false, [
        errBegin,
        `is a plain JavaScript string which is ${picocolors_default.bold(picocolors_default.red("dangerous"))}: ${picocolors_default.cyan("documentHtml")} should be`,
        errSuffix
      ].join(" "), { onlyOnce: true });
      val = dangerouslySkipEscape(val);
    }
    assertUsage(isDocumentHtml(val), [errBegin, "should be", errSuffix].join(" "));
    documentHtml = val;
  }
  if (hookReturnValue.pageContext) {
    const val = hookReturnValue.pageContext;
    const errBegin = `${errPrefix} returned ${picocolors_default.cyan("{ pageContext }")}, but ${picocolors_default.cyan("pageContext")}`;
    if (isPromise(val) || isCallable(val)) {
      assertWarning2(!isPromise(val), `${errBegin} is a promise which is deprecated in favor of async functions, see https://vike.dev/streaming#initial-data-after-stream-end`, { onlyOnce: true });
      pageContextPromise = val;
    } else {
      assertUsage(isObject(val), `${errBegin} should be an object or an async function, see https://vike.dev/streaming#initial-data-after-stream-end`);
      assertPageContextProvidedByUser(val, renderHook);
      pageContextProvidedByRenderHook = val;
    }
  }
  return { documentHtml, pageContextProvidedByRenderHook, pageContextPromise, injectFilter };
}
var init_execHookOnRenderHtml = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/execHookOnRenderHtml.js"() {
    init_renderHtml();
    init_getHook();
    init_utils3();
    init_stream();
    init_assertPageContextProvidedByUser();
    init_preparePageContextForPublicUsageServer();
    init_assertHookReturnedObject();
    init_loggerRuntime();
    init_picocolors();
    init_execHook();
    __name(execHookOnRenderHtml, "execHookOnRenderHtml");
    __name(getRenderHook, "getRenderHook");
    __name(processHookReturnValue, "processHookReturnValue");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/assertOnBeforeRenderHookReturn.js
function assertOnBeforeRenderHookReturn(hookReturnValue, hookFilePath) {
  if (hookReturnValue === void 0 || hookReturnValue === null) {
    return;
  }
  const errPrefix = `The onBeforeRender() hook defined by ${hookFilePath}`;
  assertUsage(isPlainObject(hookReturnValue), `${errPrefix} should return a plain JavaScript object, ${picocolors_default.cyan("undefined")}, or ${picocolors_default.cyan("null")}`);
  assertHookReturnedObject(hookReturnValue, ["pageContext"], errPrefix);
  if (hookReturnValue.pageContext) {
    assertPageContextProvidedByUser(hookReturnValue["pageContext"], { hookName: "onBeforeRender", hookFilePath });
  }
}
var init_assertOnBeforeRenderHookReturn = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/assertOnBeforeRenderHookReturn.js"() {
    init_utils();
    init_assertPageContextProvidedByUser();
    init_assertHookReturnedObject();
    init_picocolors();
    __name(assertOnBeforeRenderHookReturn, "assertOnBeforeRenderHookReturn");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/execHookDataAndOnBeforeRender.js
async function execHookDataAndOnBeforeRender(pageContext) {
  if (pageContext._pageContextAlreadyProvidedByOnPrerenderHook) {
    return;
  }
  const hooks = await execHookServer("data", pageContext);
  const dataHook = hooks[0];
  if (dataHook) {
    const pageContextFromHook = {
      data: dataHook.hookReturn
    };
    Object.assign(pageContext, pageContextFromHook);
    if (!pageContext.isClientSideNavigation) {
      await execHookServer("onData", pageContext);
    }
  }
  const res = await execHookServer("onBeforeRender", pageContext);
  const onBeforeRenderHook = res[0];
  if (onBeforeRenderHook) {
    const { hookReturn } = onBeforeRenderHook;
    assertOnBeforeRenderHookReturn(hookReturn, onBeforeRenderHook.hookFilePath);
    const pageContextFromHook = hookReturn?.pageContext;
    Object.assign(pageContext, pageContextFromHook);
  }
}
var init_execHookDataAndOnBeforeRender = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/execHookDataAndOnBeforeRender.js"() {
    init_assertOnBeforeRenderHookReturn();
    init_execHookServer();
    __name(execHookDataAndOnBeforeRender, "execHookDataAndOnBeforeRender");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/execHookGuard.js
async function execHookGuard(pageContext, prepareForPublicUsage) {
  let hook2;
  if (pageContext._globalContext._pageFilesAll.length > 0) {
    assert(pageContext._globalContext._pageConfigs.length === 0);
    hook2 = findPageGuard(pageContext.pageId, pageContext._globalContext._pageFilesAll);
  } else {
    hook2 = getHookFromPageContext(pageContext, "guard");
  }
  if (!hook2)
    return;
  await execHookDirectSingle(hook2, pageContext, prepareForPublicUsage);
}
function findPageGuard(pageId, pageFilesAll) {
  const pageRouteFile = pageFilesAll.find((p2) => p2.pageId === pageId && p2.fileType === ".page.route");
  if (!pageRouteFile)
    return null;
  const { filePath, fileExports } = pageRouteFile;
  assert(fileExports);
  const hookFn = fileExports.guard;
  if (!hookFn)
    return null;
  const hookFilePath = filePath;
  const hookTimeout = getHookTimeoutDefault("guard");
  assertUsage(isCallable(hookFn), `${errIntro} ${hookFilePath} should be a function`);
  return { hookFn, hookName: "guard", hookFilePath, hookTimeout };
}
var errIntro;
var init_execHookGuard = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/execHookGuard.js"() {
    init_getHook();
    init_utils4();
    init_execHook();
    errIntro = "The guard() hook defined by";
    __name(execHookGuard, "execHookGuard");
    __name(findPageGuard, "findPageGuard");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/renderPageAfterRoute.js
async function renderPageAfterRoute(pageContext) {
  assert(hasProp(pageContext, "pageId", "string"));
  const isError = pageContext.is404 || !!pageContext.errorWhileRendering;
  assert(isError === (pageContext.pageId === getErrorPageId(pageContext._globalContext._pageFilesAll, pageContext._globalContext._pageConfigs)));
  updateType(pageContext, await loadPageConfigsLazyServerSide(pageContext));
  if (!isError) {
    await execHookGuard(pageContext, (pageContext2) => preparePageContextForPublicUsageServer(pageContext2));
  }
  if (!isError) {
    await execHookDataAndOnBeforeRender(pageContext);
  } else {
    try {
      await execHookDataAndOnBeforeRender(pageContext);
    } catch (err) {
      if (isNewError(err, pageContext.errorWhileRendering)) {
        logRuntimeError(err, pageContext._httpRequestId);
      }
    }
  }
  if (pageContext.isClientSideNavigation) {
    if (isError) {
      objectAssign(pageContext, { [isServerSideError]: true });
    }
    const pageContextSerialized = getPageContextClientSerialized(pageContext, false);
    const httpResponse2 = await createHttpResponsePageContextJson(pageContextSerialized);
    objectAssign(pageContext, { httpResponse: httpResponse2 });
    return pageContext;
  }
  const renderHookResult = await execHookOnRenderHtml(pageContext);
  const { htmlRender, renderHook } = renderHookResult;
  const httpResponse = await createHttpResponsePage(htmlRender, renderHook, pageContext);
  objectAssign(pageContext, { httpResponse });
  return pageContext;
}
var init_renderPageAfterRoute = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/renderPageAfterRoute.js"() {
    init_error_page();
    init_renderHtml();
    init_utils3();
    init_serializeContext();
    init_createHttpResponse();
    init_loadPageConfigsLazyServerSide();
    init_execHookOnRenderHtml();
    init_execHookDataAndOnBeforeRender();
    init_loggerRuntime();
    init_isNewError();
    init_preparePageContextForPublicUsageServer();
    init_execHookGuard();
    init_picocolors();
    init_isServerSideError();
    __name(renderPageAfterRoute, "renderPageAfterRoute");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageContextUrlComputed.js
function getPageContextUrlComputed(pageContext) {
  assert(typeof pageContext.urlOriginal === "string");
  assertPropertyGetters(pageContext);
  const pageContextUrlComputed = {};
  objectDefineProperty(pageContextUrlComputed, "urlPathname", {
    get: urlPathnameGetter,
    enumerable: true,
    configurable: true
  });
  objectDefineProperty(pageContextUrlComputed, "url", {
    get: urlGetter,
    enumerable: false,
    configurable: true
  });
  objectDefineProperty(pageContextUrlComputed, "urlParsed", {
    get: urlParsedGetter,
    enumerable: true,
    configurable: true
  });
  return pageContextUrlComputed;
}
function getUrlParsed(pageContext) {
  const assertUrlResolved = /* @__PURE__ */ __name((src) => assert(
    typeof urlResolved === "string",
    // TO-DO/eventually: remove debug logs, see:
    // - https://github.com/vikejs/vike/issues/2138#issuecomment-2631713411
    // - https://github.com/vikejs/vike/commit/5c7810f3080ab62536950f26e019bb2a3a517082
    { src, urlResolved }
  ), "assertUrlResolved");
  let urlResolved;
  let isBaseToBeRemoved;
  if (pageContext.urlLogical) {
    urlResolved = pageContext.urlLogical;
    isBaseToBeRemoved = false;
    assertUrlResolved(1);
  } else if (pageContext._urlRewrite) {
    urlResolved = pageContext._urlRewrite;
    isBaseToBeRemoved = false;
    assertUrlResolved(2);
  } else {
    urlResolved = pageContext.urlOriginal;
    isBaseToBeRemoved = true;
    assertUrlResolved(3);
  }
  assertUrlResolved(4);
  let urlHandler = pageContext._urlHandler;
  if (!urlHandler)
    urlHandler = /* @__PURE__ */ __name((url) => url, "urlHandler");
  urlResolved = urlHandler(urlResolved);
  const baseServer2 = !isBaseToBeRemoved ? "/" : pageContext._baseServer;
  return parseUrl(urlResolved, baseServer2);
}
function urlPathnameGetter() {
  const { pathname } = getUrlParsed(this);
  const urlPathname = pathname;
  assert(urlPathname.startsWith("/"));
  return urlPathname;
}
function urlGetter() {
  assertWarning2(false, "`pageContext.url` is outdated. Use `pageContext.urlPathname`, `pageContext.urlParsed`, or `pageContext.urlOriginal` instead. (See https://vike.dev/migration/0.4.23 for more information.)", { onlyOnce: true, showStackTrace: true });
  return urlPathnameGetter.call(this);
}
function urlParsedGetter() {
  const {
    // remove isBaseMissing as it isn't part of UrlPublic
    isBaseMissing: _,
    ...urlParsed
  } = getUrlParsed(this);
  const hashIsAvailable = isBrowser();
  const warnHashNotAvailable = /* @__PURE__ */ __name((prop) => {
    assertWarning2(hashIsAvailable, `pageContext.urlParsed.${prop} isn't available on the server-side (HTTP requests don't include the URL hash)`, { onlyOnce: true, showStackTrace: true });
  }, "warnHashNotAvailable");
  const urlParsedEnhanced = {
    ...urlParsed,
    get hash() {
      warnHashNotAvailable("hash");
      return urlParsed.hash;
    },
    get hashOriginal() {
      warnHashNotAvailable("hashOriginal");
      return urlParsed.hashOriginal;
    },
    // TO-DO/next-major-release: remove
    get hashString() {
      assertWarning2(false, "pageContext.urlParsed.hashString has been renamed to pageContext.urlParsed.hashOriginal", {
        onlyOnce: true,
        showStackTrace: true
      });
      warnHashNotAvailable("hashString");
      return urlParsed.hashOriginal;
    },
    // TO-DO/next-major-release: remove
    get searchString() {
      assertWarning2(false, "pageContext.urlParsed.searchString has been renamed to pageContext.urlParsed.searchOriginal", { onlyOnce: true, showStackTrace: true });
      return urlParsed.searchOriginal;
    }
  };
  changeEnumerable(urlParsedEnhanced, "hashString", false);
  changeEnumerable(urlParsedEnhanced, "searchString", false);
  if (!hashIsAvailable) {
    changeEnumerable(urlParsedEnhanced, "hash", false);
    changeEnumerable(urlParsedEnhanced, "hashOriginal", false);
  }
  return urlParsedEnhanced;
}
var init_getPageContextUrlComputed = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageContextUrlComputed.js"() {
    init_objectDefineProperty();
    init_preparePageContextForPublicUsage();
    init_utils();
    __name(getPageContextUrlComputed, "getPageContextUrlComputed");
    __name(getUrlParsed, "getUrlParsed");
    __name(urlPathnameGetter, "urlPathnameGetter");
    __name(urlGetter, "urlGetter");
    __name(urlParsedGetter, "urlParsedGetter");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/createPageContextShared.js
function createPageContextShared(pageContextCreated, vikeConfigPublicGlobal) {
  objectAssign(pageContextCreated, vikeConfigPublicGlobal);
  return pageContextCreated;
}
function createPageContextObject() {
  const pageContext = {
    _isOriginalObject: true,
    isPageContext: true
  };
  changeEnumerable(pageContext, "_isOriginalObject", false);
  return pageContext;
}
var init_createPageContextShared = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/createPageContextShared.js"() {
    init_utils();
    __name(createPageContextShared, "createPageContextShared");
    __name(createPageContextObject, "createPageContextObject");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/createPageContextServerSide.js
function createPageContextServerSide(pageContextInit, globalContext, args) {
  assert(pageContextInit.urlOriginal);
  const pageContextCreated = createPageContext(pageContextInit, args.isPrerendering);
  objectAssign(pageContextCreated, {
    _globalContext: globalContext,
    _pageFilesAll: globalContext._pageFilesAll,
    // TO-DO/next-major-release: remove
    // We use pageContext._baseServer and pageContext._baseAssets instead of pageContext._globalContext.baseServer and pageContext._globalContext.baseAssets because the Base URLs can (eventually one day if needed) be made non-global
    _baseServer: globalContext.baseServer,
    _baseAssets: globalContext.baseAssets,
    _pageContextInit: pageContextInit,
    _urlRewrite: null,
    _urlHandler: args.ssr?.urlHandler ?? null,
    isClientSideNavigation: args.ssr?.isClientSideNavigation ?? false
  });
  objectAssign(pageContextCreated, globalContext._vikeConfigPublicGlobal);
  const pageContextUrlComputed = getPageContextUrlComputed(pageContextCreated);
  objectAssign(pageContextCreated, pageContextUrlComputed);
  {
    let headers;
    if (pageContextInit.headersOriginal) {
      headers = normalizeHeaders(pageContextInit.headersOriginal);
      assertUsage(!("headers" in pageContextInit), "You're defining pageContextInit.headersOriginal as well as pageContextInit.headers but you should only define pageContextInit.headersOriginal instead, see https://vike.dev/headers");
    } else if (pageContextInit.headers) {
      headers = pageContextInit.headers;
      assertWarning2(false, "Setting pageContextInit.headers is deprecated: set pageContextInit.headersOriginal instead, see https://vike.dev/headers", { onlyOnce: true });
    } else {
      headers = null;
    }
    objectAssign(pageContextCreated, { headers });
  }
  const pageContextAugmented = createPageContextShared(pageContextCreated, globalContext._vikeConfigPublicGlobal);
  updateType(pageContextCreated, pageContextAugmented);
  return pageContextCreated;
}
function createPageContextServerSideWithoutGlobalContext(pageContextInit) {
  const pageContext = createPageContext(pageContextInit, false);
  return pageContext;
}
function createPageContext(pageContextInit, isPrerendering) {
  const pageContext = createPageContextObject();
  objectAssign(pageContext, {
    isClientSide: false,
    isPrerendering
  });
  objectAssign(pageContext, pageContextInit);
  return pageContext;
}
var init_createPageContextServerSide = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/createPageContextServerSide.js"() {
    init_utils3();
    init_getPageContextUrlComputed();
    init_createPageContextShared();
    __name(createPageContextServerSide, "createPageContextServerSide");
    __name(createPageContextServerSideWithoutGlobalContext, "createPageContextServerSideWithoutGlobalContext");
    __name(createPageContext, "createPageContext");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/resolveRouteString.js
function assertRouteString(routeString, errPrefix = "Invalid") {
  let errPrefix2 = `${errPrefix} Route String ${highlight(routeString)}`;
  assertUsage(routeString !== "", `${errPrefix2} (empty string): set it to ${highlight("/")} instead`);
  assertUsage(["/", "*"].includes(routeString[0]), `${errPrefix2}: it should start with ${highlight("/")} or ${highlight("*")}`);
  assertUsage(!routeString.includes("**"), `${errPrefix2}: set it to ${highlight(routeString.split("**").join("*"))} instead`);
}
function resolveRouteString(routeString, urlPathname) {
  assertRouteString(routeString);
  const segments = parseRouteString(routeString);
  const routeRegexStrInner = segments.map((segment) => {
    if (segment.param) {
      return "[^/]+";
    }
    if (segment.glob) {
      return ".*";
    }
    return escapeRegex(segment.static);
  }).map((s) => `(${s})`).join("");
  const routeRegex = new RegExp(`^${routeRegexStrInner}/?$`);
  const routeRegexMatch = urlPathname.match(routeRegex);
  if (!routeRegexMatch)
    return null;
  const routeParams = {};
  const [_, ...segmentsValue] = routeRegexMatch;
  let globIdx = 0;
  const hasMultipleGlobs = segments.filter((segment) => segment.glob).length > 1;
  segments.forEach((segment, i) => {
    let val = segmentsValue[i];
    if (segment.param) {
      routeParams[segment.param] = val;
    }
    if (segment.glob) {
      const param = `*${hasMultipleGlobs ? ++globIdx : ""}`;
      routeParams[param] = val;
    }
  });
  return { routeParams };
}
function parseRouteString(routeString) {
  const segments = [];
  const pushStatic = /* @__PURE__ */ __name((s) => {
    const segmentLast = segments[segments.length - 1];
    if (segmentLast?.static) {
      segmentLast.static += s;
    } else {
      segments.push({ static: s });
    }
  }, "pushStatic");
  const parts = routeString.split("/");
  parts.forEach((s, i) => {
    if (i !== 0)
      pushStatic("/");
    if (isParam(s)) {
      assertWarning2(!s.startsWith(PARAM_TOKEN_OLD), `Outdated Route String ${highlight(routeString)}, use ${highlight(routeString.split(PARAM_TOKEN_OLD).join(PARAM_TOKEN_NEW))} instead`, { onlyOnce: true });
      segments.push({ param: s.slice(1) });
    } else {
      if (s === "*" && i === parts.length - 1 && routeString !== "*" && routeString !== "/*") {
        segments.push({ glob: true });
      } else {
        s.split("*").forEach((s2, i2) => {
          if (i2 !== 0)
            segments.push({ glob: true });
          if (s2 !== "") {
            pushStatic(s2);
          }
        });
      }
    }
  });
  return segments;
}
function analyzeRouteString(routeString) {
  const segments = parseRouteString(routeString);
  const countStaticParts = /* @__PURE__ */ __name((s) => s?.split("/").filter(Boolean).length || 0, "countStaticParts");
  let numberOfStaticPartsBeginning = 0;
  for (const segment of segments) {
    if (!segment.static)
      break;
    numberOfStaticPartsBeginning += countStaticParts(segment.static);
  }
  const numberOfStaticParts = segments.map((s) => countStaticParts(s.static)).reduce((sum, a) => sum + a, 0);
  const numberOfParams = segments.filter((s) => s.param).length;
  const numberOfGlobs = segments.filter((s) => s.glob).length;
  return { numberOfStaticPartsBeginning, numberOfStaticParts, numberOfParams, numberOfGlobs };
}
function isParam(routeSegment) {
  return routeSegment.startsWith(PARAM_TOKEN_NEW) || routeSegment.startsWith(PARAM_TOKEN_OLD);
}
function isStaticRouteString(routeString) {
  const url = routeString;
  const match = resolveRouteString(routeString, url);
  assert(match);
  return Object.keys(match.routeParams).length === 0;
}
function highlight(routeString) {
  if (isBrowser()) {
    return `'${routeString}'`;
  } else {
    if (routeString === "") {
      routeString = "''";
    }
    return picocolors_default.cyan(routeString);
  }
}
var PARAM_TOKEN_NEW, PARAM_TOKEN_OLD;
var init_resolveRouteString = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/resolveRouteString.js"() {
    init_utils();
    init_utils4();
    init_picocolors();
    PARAM_TOKEN_NEW = "@";
    PARAM_TOKEN_OLD = ":";
    __name(assertRouteString, "assertRouteString");
    __name(resolveRouteString, "resolveRouteString");
    __name(parseRouteString, "parseRouteString");
    __name(analyzeRouteString, "analyzeRouteString");
    __name(isParam, "isParam");
    __name(isStaticRouteString, "isStaticRouteString");
    __name(highlight, "highlight");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/resolvePrecedence.js
function resolvePrecedence(routeMatches) {
  routeMatches.sort(sortMatches).sort(makeFirst((routeMatch) => routeMatch.routeType === "FUNCTION" && !!routeMatch.precedence && routeMatch.precedence < 0)).sort(makeFirst((routeMatch) => routeMatch.routeType === "STRING" && isStaticRouteString(routeMatch.routeString) === false)).sort(makeFirst((routeMatch) => routeMatch.routeType === "FUNCTION" && !routeMatch.precedence)).sort(makeFirst((routeMatch) => routeMatch.routeType === "STRING" && isStaticRouteString(routeMatch.routeString) === true)).sort(makeFirst((routeMatch) => routeMatch.routeType === "FILESYSTEM")).sort(makeFirst((routeMatch) => routeMatch.routeType === "FUNCTION" && !!routeMatch.precedence && routeMatch.precedence > 0));
}
function sortMatches(routeMatch1, routeMatch2) {
  {
    const precedence1 = routeMatch1.precedence ?? 0;
    const precedence2 = routeMatch2.precedence ?? 0;
    if (precedence1 !== precedence2) {
      return precedence1 > precedence2 ? -1 : 1;
    }
  }
  if (!routeMatch2.routeString) {
    return 0;
  }
  if (!routeMatch1.routeString) {
    return 0;
  }
  {
    const getValue = /* @__PURE__ */ __name((routeString) => analyzeRouteString(routeString).numberOfStaticPartsBeginning, "getValue");
    const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);
    if (result !== 0) {
      return result;
    }
  }
  {
    const getValue = /* @__PURE__ */ __name((routeString) => analyzeRouteString(routeString).numberOfStaticParts, "getValue");
    const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);
    if (result !== 0) {
      return result;
    }
  }
  {
    const getValue = /* @__PURE__ */ __name((routeString) => analyzeRouteString(routeString).numberOfGlobs, "getValue");
    const result = lowerFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);
    if (result !== 0) {
      return result;
    }
  }
  {
    const getValue = /* @__PURE__ */ __name((routeString) => analyzeRouteString(routeString).numberOfParams, "getValue");
    const result = higherFirst(getValue)(routeMatch1.routeString, routeMatch2.routeString);
    if (result !== 0) {
      return result;
    }
  }
  return 0;
}
var init_resolvePrecedence = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/resolvePrecedence.js"() {
    init_resolveRouteString();
    init_utils4();
    init_utils4();
    init_resolveRouteString();
    __name(resolvePrecedence, "resolvePrecedence");
    __name(sortMatches, "sortMatches");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/resolveRouteFunction.js
async function resolveRouteFunction(routeFunction, pageContext, routeFunctionFilePath) {
  let { hookReturn: result } = execHookDirectSync({
    hookFn: routeFunction,
    hookFilePath: routeFunctionFilePath,
    hookName: "route"
  }, pageContext, preparePageContextForPublicUsage);
  assertSyncRouting(result, `The Route Function ${routeFunctionFilePath}`);
  result = await result;
  if (result === false) {
    return null;
  }
  if (result === true) {
    result = {};
  }
  assertUsage(isPlainObject(result), `The Route Function ${routeFunctionFilePath} should return a boolean or a plain JavaScript object (but it's ${picocolors_default.cyan(`typeof result === ${JSON.stringify(typeof result)}`)} instead)`);
  if ("match" in result) {
    const { match } = result;
    assertUsage(typeof match === "boolean", `The ${picocolors_default.cyan("match")} value returned by the Route Function ${routeFunctionFilePath} should be a boolean.`);
    if (!match) {
      return null;
    }
  }
  let precedence = null;
  if ("precedence" in result) {
    precedence = result.precedence;
    assertUsage(typeof precedence === "number", `The ${picocolors_default.cyan("precedence")} value returned by the Route Function ${routeFunctionFilePath} should be a number.`);
  }
  assertRouteParams(result, `The ${picocolors_default.cyan("routeParams")} object returned by the Route Function ${routeFunctionFilePath} should`);
  const routeParams = result.routeParams || {};
  assertUsage(!("pageContext" in result), `Providing ${picocolors_default.cyan("pageContext")} in Route Functions is prohibited, see https://vike.dev/route-function#cannot-provide-pagecontext`);
  assert(isPlainObject(routeParams));
  Object.keys(result).forEach((key) => {
    assertUsage(key === "match" || key === "routeParams" || key === "precedence", `The Route Function ${routeFunctionFilePath} returned an object with an unknown property ${picocolors_default.cyan(key)} (the known properties are ${picocolors_default.cyan("match")}, ${picocolors_default.cyan("routeParams")}, and ${picocolors_default.cyan("precedence")})`);
  });
  return {
    precedence,
    routeParams
  };
}
function assertSyncRouting(res, errPrefix) {
  assertWarning2(!isPromise(res), `${errPrefix} returned a promise, but asynchronous routing is deprecated and will be removed in the next major release, see https://vike.dev/route-function#async`, { onlyOnce: true });
}
function warnDeprecatedAllowKey() {
  const allowKey = picocolors_default.cyan("iKnowThePerformanceRisksOfAsyncRouteFunctions");
  assertWarning2(false, `${allowKey} is deprecated and will be removed in the next major release`, { onlyOnce: true });
}
function assertRouteParams(result, errPrefix) {
  assert(errPrefix.endsWith(" should"));
  if (!hasProp(result, "routeParams")) {
    return;
  }
  assert(errPrefix.endsWith(" should"));
  assertUsage(hasProp(result, "routeParams", "string{}"), `${errPrefix} be an object holding string values.`);
}
var init_resolveRouteFunction = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/resolveRouteFunction.js"() {
    init_execHook();
    init_preparePageContextForPublicUsage();
    init_utils4();
    init_picocolors();
    __name(resolveRouteFunction, "resolveRouteFunction");
    __name(assertSyncRouting, "assertSyncRouting");
    __name(warnDeprecatedAllowKey, "warnDeprecatedAllowKey");
    __name(assertRouteParams, "assertRouteParams");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/execHookOnBeforeRoute.js
async function execHookOnBeforeRoute(pageContext) {
  const pageContextFromOnBeforeRouteHook = {};
  if (!pageContext._globalContext._onBeforeRouteHook)
    return null;
  const pageContextFromHook = await getPageContextFromHook(pageContext._globalContext._onBeforeRouteHook, pageContext);
  if (pageContextFromHook) {
    objectAssign(pageContextFromOnBeforeRouteHook, pageContextFromHook);
    if (hasProp(pageContextFromOnBeforeRouteHook, "pageId", "string") || hasProp(pageContextFromOnBeforeRouteHook, "pageId", "null")) {
      if (!hasProp(pageContextFromOnBeforeRouteHook, "routeParams")) {
        objectAssign(pageContextFromOnBeforeRouteHook, { routeParams: {} });
      } else {
        assert(hasProp(pageContextFromOnBeforeRouteHook, "routeParams", "object"));
      }
      objectAssign(pageContextFromOnBeforeRouteHook, {
        _routingProvidedByOnBeforeRouteHook: true
      });
      return pageContextFromOnBeforeRouteHook;
    }
  }
  objectAssign(pageContextFromOnBeforeRouteHook, {
    _routingProvidedByOnBeforeRouteHook: false
  });
  return pageContextFromOnBeforeRouteHook;
}
async function getPageContextFromHook(onBeforeRouteHook, pageContext) {
  let { hookReturn } = execHookDirectSync(onBeforeRouteHook, pageContext, preparePageContextForPublicUsage);
  assertSyncRouting(hookReturn, `The onBeforeRoute() hook ${onBeforeRouteHook.hookFilePath}`);
  hookReturn = await hookReturn;
  const errPrefix = `The onBeforeRoute() hook defined by ${onBeforeRouteHook.hookFilePath}`;
  assertUsage(hookReturn === null || hookReturn === void 0 || isObjectWithKeys(hookReturn, ["pageContext"]) && hasProp(hookReturn, "pageContext"), `${errPrefix} should return ${picocolors_default.cyan("null")}, ${picocolors_default.cyan("undefined")}, or a plain JavaScript object ${picocolors_default.cyan("{ pageContext: { /* ... */ } }")}`);
  if (hookReturn === null || hookReturn === void 0) {
    return null;
  }
  assertUsage(hasProp(hookReturn, "pageContext", "object"), `${errPrefix} returned ${picocolors_default.cyan("{ pageContext }")} but pageContext should be a plain JavaScript object.`);
  if (hasProp(hookReturn.pageContext, "pageId") && !hasProp(hookReturn.pageContext, "pageId", "null")) {
    const errPrefix2 = `${errPrefix} returned ${picocolors_default.cyan("{ pageContext: { pageId } }")} but ${picocolors_default.cyan("pageId")} should be`;
    assertUsage(hasProp(hookReturn.pageContext, "pageId", "string"), `${errPrefix2} a string or null`);
    assertUsage(pageContext._globalContext._allPageIds.includes(hookReturn.pageContext.pageId), `${errPrefix2} ${joinEnglish(pageContext._globalContext._allPageIds.map((s) => picocolors_default.cyan(s)), "or")}`);
  }
  if (hasProp(hookReturn.pageContext, "routeParams")) {
    assertRouteParams(hookReturn.pageContext, `${errPrefix} returned ${picocolors_default.cyan("{ pageContext: { routeParams } }")} but routeParams should`);
  }
  const deprecatedReturn = /* @__PURE__ */ __name((prop) => `${errPrefix} returned ${picocolors_default.cyan(`{ pageContext: { ${prop} } }`)} which is deprecated. Return ${picocolors_default.cyan("{ pageContext: { urlLogical } }")} instead.`, "deprecatedReturn");
  if (hasProp(hookReturn.pageContext, "url")) {
    assertWarning2(false, deprecatedReturn("url"), { onlyOnce: true });
    hookReturn.pageContext.urlLogical = hookReturn.pageContext.url;
    delete hookReturn.pageContext.url;
  }
  if (hasProp(hookReturn.pageContext, "urlOriginal")) {
    assertWarning2(false, deprecatedReturn("urlOriginal"), { onlyOnce: true });
    hookReturn.pageContext.urlLogical = hookReturn.pageContext.urlOriginal;
    delete hookReturn.pageContext.urlOriginal;
  }
  if (hasProp(hookReturn.pageContext, "urlLogical")) {
    assertUsageUrlPathnameAbsolute(
      // We skip validation and type-cast instead of assertUsage() in order to save client-side KBs
      hookReturn.pageContext.urlLogical,
      `${errPrefix} returned ${picocolors_default.cyan("{ pageContext: { urlLogical } }")} and ${picocolors_default.cyan("urlLogical")}`
    );
  }
  assertPageContextProvidedByUser(hookReturn.pageContext, {
    hookFilePath: onBeforeRouteHook.hookFilePath,
    hookName: "onBeforeRoute"
  });
  const pageContextAddendumHook = {};
  objectAssign(pageContextAddendumHook, hookReturn.pageContext);
  return pageContextAddendumHook;
}
var init_execHookOnBeforeRoute = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/execHookOnBeforeRoute.js"() {
    init_assertPageContextProvidedByUser();
    init_utils4();
    init_resolveRouteFunction();
    init_picocolors();
    init_execHook();
    init_preparePageContextForPublicUsage();
    __name(execHookOnBeforeRoute, "execHookOnBeforeRoute");
    __name(getPageContextFromHook, "getPageContextFromHook");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/index.js
async function route(pageContext, skipOnBeforeRouteHook) {
  debug("Pages routes:", pageContext._globalContext._pageRoutes);
  const pageContextFromRoute = {};
  if (!skipOnBeforeRouteHook) {
    const pageContextFromOnBeforeRouteHook = await execHookOnBeforeRoute(pageContext);
    if (pageContextFromOnBeforeRouteHook) {
      if (pageContextFromOnBeforeRouteHook._routingProvidedByOnBeforeRouteHook) {
        assert(pageContextFromOnBeforeRouteHook.pageId);
        return pageContextFromOnBeforeRouteHook;
      } else {
        objectAssign(pageContextFromRoute, pageContextFromOnBeforeRouteHook);
      }
    }
    objectAssign(pageContext, pageContextFromOnBeforeRouteHook);
  }
  const allPageIds = pageContext._globalContext._allPageIds;
  assertUsage(allPageIds.length > 0, "No page found. You must create at least one page.");
  assert(pageContext._globalContext._pageFilesAll.length > 0 || pageContext._globalContext._pageConfigs.length > 0);
  const { urlPathname } = pageContext;
  assert(urlPathname.startsWith("/"));
  const routeMatches = [];
  await Promise.all(pageContext._globalContext._pageRoutes.map(async (pageRoute) => {
    const { pageId, routeType } = pageRoute;
    if (pageRoute.routeType === "FILESYSTEM") {
      const { routeString } = pageRoute;
      const match = resolveRouteString(routeString, urlPathname);
      if (match) {
        const { routeParams } = match;
        routeMatches.push({ pageId, routeParams, routeString, routeType });
      }
      return;
    }
    if (pageRoute.routeType === "STRING") {
      const { routeString } = pageRoute;
      const match = resolveRouteString(routeString, urlPathname);
      if (match) {
        const { routeParams } = match;
        assert(routeType === "STRING");
        routeMatches.push({
          pageId,
          routeString,
          routeParams,
          routeType
        });
      }
      return;
    }
    if (pageRoute.routeType === "FUNCTION") {
      const { routeFunction, routeFunctionFilePath } = pageRoute;
      const match = await resolveRouteFunction(routeFunction, pageContext, routeFunctionFilePath);
      if (match) {
        const { routeParams, precedence } = match;
        routeMatches.push({ pageId, precedence, routeParams, routeType });
      }
      return;
    }
    assert(false);
  }));
  resolvePrecedence(routeMatches);
  const winner = routeMatches[0] ?? null;
  debug(`Route matches for URL ${picocolors_default.cyan(urlPathname)} (in precedence order):`, routeMatches);
  objectAssign(pageContextFromRoute, { _routeMatch: winner });
  if (!winner) {
    objectAssign(pageContextFromRoute, {
      pageId: null,
      routeParams: {}
    });
    return pageContextFromRoute;
  }
  {
    const { routeParams } = winner;
    assert(isPlainObject(routeParams));
    objectAssign(pageContextFromRoute, {
      pageId: winner.pageId,
      routeParams: winner.routeParams
    });
  }
  return pageContextFromRoute;
}
var init_route = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/index.js"() {
    init_assertRoutingType();
    init_isBrowser();
    init_utils4();
    init_resolvePrecedence();
    init_resolveRouteString();
    init_resolveRouteFunction();
    init_execHookOnBeforeRoute();
    init_debug();
    init_picocolors();
    if (isBrowser()) {
      assertClientRouting();
    }
    __name(route, "route");
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/createErrorWithCleanStackTrace.js
function createErrorWithCleanStackTrace2(errorMessage2, numberOfStackTraceLinesToRemove5) {
  const err = new Error(errorMessage2);
  err.stack = clean2(err.stack, numberOfStackTraceLinesToRemove5);
  return err;
}
function clean2(errStack, numberOfStackTraceLinesToRemove5) {
  if (!errStack) {
    return errStack;
  }
  const stackLines = splitByLine2(errStack);
  let linesRemoved = 0;
  const stackLine__cleaned = stackLines.filter((line) => {
    if (line.includes(" (internal/") || line.includes(" (node:internal")) {
      return false;
    }
    if (linesRemoved < numberOfStackTraceLinesToRemove5 && isStackTraceLine2(line)) {
      linesRemoved++;
      return false;
    }
    return true;
  }).join("\n");
  return stackLine__cleaned;
}
function isStackTraceLine2(line) {
  return line.startsWith("    at ");
}
function splitByLine2(str) {
  return str.split(/\r?\n/);
}
var init_createErrorWithCleanStackTrace2 = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/createErrorWithCleanStackTrace.js"() {
    __name(createErrorWithCleanStackTrace2, "createErrorWithCleanStackTrace");
    __name(clean2, "clean");
    __name(isStackTraceLine2, "isStackTraceLine");
    __name(splitByLine2, "splitByLine");
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/PROJECT_VERSION.js
var PROJECT_VERSION2;
var init_PROJECT_VERSION2 = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/PROJECT_VERSION.js"() {
    PROJECT_VERSION2 = "0.7.14";
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/projectInfo.js
var projectInfo;
var init_projectInfo = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/projectInfo.js"() {
    init_PROJECT_VERSION2();
    projectInfo = {
      projectName: "@brillout/vite-plugin-server-entry",
      npmPackageName: "@brillout/vite-plugin-server-entry",
      projectVersion: PROJECT_VERSION2,
      githubRepository: "https://github.com/brillout/vite-plugin-server-entry"
    };
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/assert.js
function assert2(condition, debugInfo) {
  if (condition) {
    return;
  }
  const debugStr = (() => {
    if (!debugInfo) {
      return null;
    }
    const debugInfoSerialized = typeof debugInfo === "string" ? debugInfo : "`" + JSON.stringify(debugInfo) + "`";
    return `Debug info (this is for the ${projectInfo.projectName} maintainers; you can ignore this): ${debugInfoSerialized}`;
  })();
  const internalError = createErrorWithCleanStackTrace2([
    `${internalErrorPrefix} You stumbled upon a bug in the source code of ${projectInfo.projectName}.`,
    `Reach out at ${projectInfo.githubRepository}/issues/new and include this error stack (the error stack is usually enough to fix the problem).`,
    "A maintainer will fix the bug (usually under 24 hours).",
    `Don't hesitate to reach out as it makes ${projectInfo.projectName} more robust.`,
    debugStr
  ].filter(Boolean).join(" "), numberOfStackTraceLinesToRemove2);
  throw internalError;
}
function assertUsage2(condition, errorMessage2) {
  if (condition) {
    return;
  }
  const errMsg = `${usageErrorPrefix} ${errorMessage2}`;
  const usageError = createErrorWithCleanStackTrace2(errMsg, numberOfStackTraceLinesToRemove2);
  throw usageError;
}
var logLabel, internalErrorPrefix, usageErrorPrefix, numberOfStackTraceLinesToRemove2;
var init_assert2 = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/assert.js"() {
    init_createErrorWithCleanStackTrace2();
    init_projectInfo();
    logLabel = `[${projectInfo.npmPackageName}@${projectInfo.projectVersion}]`;
    internalErrorPrefix = `${logLabel}[Bug]`;
    usageErrorPrefix = `${logLabel}[Wrong Usage]`;
    numberOfStackTraceLinesToRemove2 = 2;
    __name(assert2, "assert");
    __name(assertUsage2, "assertUsage");
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/filesystemPathHandling.js
function toPosixPath2(path) {
  if (isPosix()) {
    assertPosixPath2(path);
    return path;
  }
  if (isWin32()) {
    const pathPosix = path.split(sepWin32).join(sepPosix);
    assertPosixPath2(pathPosix);
    return pathPosix;
  }
  assert2(false);
}
function assertPosixPath2(path) {
  assert2(path && !path.includes(sepWin32), `Wrongly formatted path: ${path}`);
}
function isWin32() {
  return process.platform === "win32";
}
function isPosix() {
  return !isWin32();
}
var sepPosix, sepWin32;
var init_filesystemPathHandling = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/filesystemPathHandling.js"() {
    init_assert2();
    sepPosix = "/";
    sepWin32 = "\\";
    __name(toPosixPath2, "toPosixPath");
    __name(assertPosixPath2, "assertPosixPath");
    __name(isWin32, "isWin32");
    __name(isPosix, "isPosix");
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/getCwdSafe.js
function getCwdSafe() {
  if (typeof process == "undefined" || !("cwd" in process))
    return null;
  return toPosixPath2(process.cwd());
}
var init_getCwdSafe = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/getCwdSafe.js"() {
    init_filesystemPathHandling();
    __name(getCwdSafe, "getCwdSafe");
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/requireResolve.js
async function requireResolve(id, currentFilePath) {
  const req = await getRequire(currentFilePath);
  return req.resolve(id);
}
async function getRequire(currentFilePath) {
  const { createRequire } = await import_("module");
  const req = createRequire(currentFilePath);
  return req;
}
var init_requireResolve = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/requireResolve.js"() {
    init_esm();
    __name(requireResolve, "requireResolve");
    __name(getRequire, "getRequire");
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/isWebpackResolve.js
function isWebpackResolve(moduleResolve, cwd) {
  assert2(process);
  return (
    // Upon `require.resolve()` webpack returns a number
    typeof moduleResolve === "number" || // Upon `import.meta.resolve()` webpack returns a path such as /test/webpack/dist/server/entry.mjs which seems to be relative to the monorepo root
    getFirstDir(moduleResolve) !== getFirstDir(cwd) || // `import.meta.resolve()` + windows => webpack returns file:///D:/test/webpack/dist/server/entry.mjs
    process.platform === "win32" && getSecondDir(moduleResolve) !== getSecondDir(cwd)
  );
}
function getFirstDir(path) {
  return getDirs(path)[0];
}
function getSecondDir(path) {
  return getDirs(path)[1];
}
function getDirs(path) {
  assert2(!path.startsWith("file:"));
  return toPosixPath2(path).split("/").filter(Boolean);
}
var init_isWebpackResolve = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/utils/isWebpackResolve.js"() {
    init_assert2();
    init_filesystemPathHandling();
    __name(isWebpackResolve, "isWebpackResolve");
    __name(getFirstDir, "getFirstDir");
    __name(getSecondDir, "getSecondDir");
    __name(getDirs, "getDirs");
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/utils.js
var init_utils5 = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/utils.js"() {
    init_assert2();
    init_getCwdSafe();
    init_filesystemPathHandling();
    init_requireResolve();
    init_isWebpackResolve();
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/shared/utils.js
var init_utils6 = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/shared/utils.js"() {
    init_assert2();
    init_getCwdSafe();
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/shared/debug.js
function logDebug(...msgs) {
  console.log(`${logLabel}[DEBUG]`, ...msgs);
}
function getDEBUG2() {
  let DEBUG3;
  try {
    DEBUG3 = process.env.DEBUG;
  } catch {
  }
  return DEBUG3;
}
var DEBUG2, isDebug2;
var init_debug3 = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/shared/debug.js"() {
    init_utils6();
    DEBUG2 = getDEBUG2() ?? "";
    isDebug2 = DEBUG2.includes("vite-plugin-server-entry");
    if (isDebug2)
      Error.stackTraceLimit = Infinity;
    __name(logDebug, "logDebug");
    __name(getDEBUG2, "getDEBUG");
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/debugLogsRuntime.js
function debugLogsRuntimePre(autoImporter) {
  if (!isDebug2)
    return;
  logDebug("DEBUG_LOGS_RUNTIME [begin]");
  try {
    logDebug("process.platform", JSON.stringify(process.platform));
  } catch {
    logDebug("process.platform", "undefined");
  }
  try {
    logDebug("process.release", JSON.stringify(process.release));
  } catch {
    logDebug("process.release", "undefined");
  }
  try {
    logDebug("navigator", JSON.stringify(navigator));
  } catch {
    logDebug("navigator", "undefined");
  }
  logDebug("cwd", getCwdSafe());
  logDebug("importer.status", autoImporter.status);
  if (autoImporter.status === "SET") {
    logDebug("importer.pluginVersion", autoImporter.pluginVersion);
    logDebug("importer.paths.autoImporterFilePathOriginal", autoImporter.paths.autoImporterFilePathOriginal);
    logDebug("importer.paths.autoImporterFilePathActual", autoImporter.paths.autoImporterFilePathActual);
    logDebug("importer.paths.serverEntryFilePathRelative", autoImporter.paths.serverEntryFilePathRelative);
    logDebug("importer.paths.serverEntryFilePathOriginal", autoImporter.paths.serverEntryFilePathOriginal);
    try {
      logDebug("importer.paths.serverEntryFilePathResolved()", autoImporter.paths.serverEntryFilePathResolved());
    } catch (err) {
      logDebug("importer.paths.serverEntryFilePathResolved() error:", err);
      logDebug("importer.paths.serverEntryFilePathResolved()", "ERRORED");
    }
  }
}
function debugLogsRuntimePost(info) {
  if (!isDebug2)
    return;
  for (var key in info)
    logDebug(key, info[key]);
  logDebug("DEBUG_LOGS_RUNTIME [end]");
}
var init_debugLogsRuntime = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/debugLogsRuntime.js"() {
    init_utils6();
    init_debug3();
    __name(debugLogsRuntimePre, "debugLogsRuntimePre");
    __name(debugLogsRuntimePost, "debugLogsRuntimePost");
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/shared/serverEntryFileNameBase.js
var serverEntryFileNameBase, serverEntryFileNameBaseAlternative;
var init_serverEntryFileNameBase = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/shared/serverEntryFileNameBase.js"() {
    serverEntryFileNameBase = "entry";
    serverEntryFileNameBaseAlternative = "entryLibraries";
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/shared/usageHints.js
var usageHintRollupEntryNames;
var init_usageHints = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/shared/usageHints.js"() {
    usageHintRollupEntryNames = "If you use rollupOptions.output.entryFileNames then make sure you don't change the file name of the production server entry";
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/crawlOutDir.js
async function crawlOutDir({ outDir, tolerateDoesNotExist, outFileSearch }) {
  let path;
  let fs;
  try {
    path = await import_("path");
    fs = await import_("fs");
  } catch {
    return false;
  }
  const cwd = process.cwd();
  const isPathAbsolute = /* @__PURE__ */ __name((p2) => {
    if (process.platform === "win32") {
      return path.win32.isAbsolute(p2);
    } else {
      return p2.startsWith("/");
    }
  }, "isPathAbsolute");
  if (outDir) {
    assertPosixPath2(outDir);
    assert2(isPathAbsolute(outDir), outDir);
  } else {
    if (!cwd)
      return false;
    outDir = path.posix.join(cwd, "dist");
  }
  const outDirServer = path.posix.join(outDir, "server");
  const outDirServerExists = fs.existsSync(outDirServer);
  if (!outDirServerExists)
    return false;
  const outFileNameList = [];
  outFileSearch.forEach((outFileNameBase) => {
    outFileNameList.push(...[
      //
      `${outFileNameBase}.mjs`,
      `${outFileNameBase}.js`,
      `${outFileNameBase}.cjs`
    ]);
  });
  let outFileFound;
  const getOutFilePath = /* @__PURE__ */ __name((outFileName) => path.posix.join(outDirServer, outFileName), "getOutFilePath");
  for (const outFileName of outFileNameList) {
    const outFilePath = getOutFilePath(outFileName);
    assert2(isPathAbsolute(outFilePath));
    let outFilePathResolved;
    try {
      outFilePathResolved = await requireResolve(
        outFilePath,
        // Since `outFilePath` is absolute, we can pass a wrong `currentFilePath` argument value.
        // - We avoid using `__filename` because it isn't defined when this file is included in an ESM bundle.
        // - We cannot use `import.meta.filename` (nor `import.meta.url`) because there doesn't seem to be a way to safely/conditionally access `import.meta`.
        cwd
      );
    } catch {
      continue;
    }
    assert2(outFilePathResolved);
    outFileFound = {
      outFilePath: outFilePathResolved,
      outFileName
    };
  }
  if (!outFileFound) {
    if (tolerateDoesNotExist) {
      return false;
    } else {
      assert2(outDirServerExists);
      assertUsage2(false, `The server production entry is missing. ${usageHintRollupEntryNames}. One of the following is expected to exist: 
${outFileNameList.map((outFileName) => `  ${getOutFilePath(outFileName)}`).join("\n")}`);
    }
  }
  assert2(outFileSearch.some((outFileNameBase) => outFileFound.outFileName.startsWith(outFileNameBase)));
  if (isWebpackResolve(outFileFound.outFilePath, cwd)) {
    return false;
  }
  return outFileFound.outFilePath;
}
var init_crawlOutDir = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/crawlOutDir.js"() {
    init_utils5();
    init_esm();
    init_usageHints();
    __name(crawlOutDir, "crawlOutDir");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isCallable.js
function isCallable3(thing) {
  return thing instanceof Function || typeof thing === "function";
}
var init_isCallable3 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isCallable.js"() {
    __name(isCallable3, "isCallable");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/hasProp.js
function hasProp2(obj, prop, type2 = "unknown") {
  const propExists = typeof obj === "object" && obj !== null && prop in obj;
  if (!propExists) {
    return false;
  }
  if (type2 === "unknown") {
    return true;
  }
  const propValue = obj[prop];
  if (type2 === "array") {
    return Array.isArray(propValue);
  }
  if (type2 === "string[]") {
    return Array.isArray(propValue) && propValue.every((el) => typeof el === "string");
  }
  if (type2 === "function") {
    return isCallable3(propValue);
  }
  if (Array.isArray(type2)) {
    return typeof propValue === "string" && type2.includes(propValue);
  }
  if (type2 === "null") {
    return propValue === null;
  }
  if (type2 === "true") {
    return propValue === true;
  }
  return typeof propValue === type2;
}
var init_hasProp2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/hasProp.js"() {
    init_isCallable3();
    __name(hasProp2, "hasProp");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/checkType.js
function checkType2(_) {
}
var init_checkType2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/checkType.js"() {
    __name(checkType2, "checkType");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isPromise.js
var init_isPromise2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isPromise.js"() {
    init_isCallable3();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/cast.js
var init_cast2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/cast.js"() {
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/createErrorWithCleanStackTrace.js
function createErrorWithCleanStackTrace3(errorMessage2, numberOfStackTraceLinesToRemove5) {
  const err = new Error(errorMessage2);
  err.stack = clean3(err.stack, numberOfStackTraceLinesToRemove5);
  return err;
}
function clean3(errStack, numberOfStackTraceLinesToRemove5) {
  if (!errStack) {
    return errStack;
  }
  const stackLines = splitByLine3(errStack);
  let linesRemoved = 0;
  const stackLine__cleaned = stackLines.filter((line) => {
    if (line.includes(" (internal/") || line.includes(" (node:internal")) {
      return false;
    }
    if (linesRemoved < numberOfStackTraceLinesToRemove5 && isStackTraceLine3(line)) {
      linesRemoved++;
      return false;
    }
    return true;
  }).join("\n");
  return stackLine__cleaned;
}
function isStackTraceLine3(line) {
  return line.startsWith("    at ");
}
function splitByLine3(str) {
  return str.split(/\r?\n/);
}
var init_createErrorWithCleanStackTrace3 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/createErrorWithCleanStackTrace.js"() {
    __name(createErrorWithCleanStackTrace3, "createErrorWithCleanStackTrace");
    __name(clean3, "clean");
    __name(isStackTraceLine3, "isStackTraceLine");
    __name(splitByLine3, "splitByLine");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/getGlobalObject.js
function getGlobalObject2(key, defaultValue) {
  const globalObjectsAll = globalThis[projectKey] = globalThis[projectKey] || {};
  const globalObject24 = globalObjectsAll[key] = globalObjectsAll[key] || defaultValue;
  return globalObject24;
}
var projectKey;
var init_getGlobalObject2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/getGlobalObject.js"() {
    __name(getGlobalObject2, "getGlobalObject");
    projectKey = "_telefunc";
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/PROJECT_VERSION.js
var PROJECT_VERSION3;
var init_PROJECT_VERSION3 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/PROJECT_VERSION.js"() {
    PROJECT_VERSION3 = "0.2.11";
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/projectInfo.js
var projectInfo2;
var init_projectInfo2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/projectInfo.js"() {
    init_PROJECT_VERSION3();
    projectInfo2 = {
      projectName: "Telefunc",
      projectVersion: PROJECT_VERSION3
    };
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/assert.js
function assert3(condition, debugInfo) {
  if (condition) {
    return;
  }
  const debugStr = (() => {
    if (!debugInfo) {
      return "";
    }
    const debugInfoSerialized = typeof debugInfo === "string" ? debugInfo : "`" + JSON.stringify(debugInfo) + "`";
    return `Debug info (this is for the ${projectInfo2.projectName} maintainers; you can ignore this): ${debugInfoSerialized}.`;
  })();
  const link = "https://github.com/brillout/telefunc/issues/new";
  const internalError = createErrorWithCleanStackTrace3([
    internalErrorPrefix2,
    `You stumbled upon a Telefunc bug. Go to ${link} and copy-paste this error. A maintainer will fix the bug (usually under 24 hours).`,
    debugStr
  ].join(" "), numberOfStackTraceLinesToRemove3);
  throw internalError;
}
function assertUsage3(condition, errorMessage2) {
  if (condition) {
    return;
  }
  const whiteSpace = errorMessage2.startsWith("[") ? "" : " ";
  const usageError = createErrorWithCleanStackTrace3(`${usageErrorPrefix2}${whiteSpace}${errorMessage2}`, numberOfStackTraceLinesToRemove3);
  throw usageError;
}
var errorPrefix, internalErrorPrefix2, usageErrorPrefix2, warningPrefix, infoPrefix, numberOfStackTraceLinesToRemove3, globalObject10;
var init_assert3 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/assert.js"() {
    init_createErrorWithCleanStackTrace3();
    init_getGlobalObject2();
    init_projectInfo2();
    errorPrefix = `[telefunc@${projectInfo2.projectVersion}]`;
    internalErrorPrefix2 = `${errorPrefix}[Bug]`;
    usageErrorPrefix2 = `${errorPrefix}[Wrong Usage]`;
    warningPrefix = `${errorPrefix}[Warning]`;
    infoPrefix = `${errorPrefix}[Info]`;
    numberOfStackTraceLinesToRemove3 = 2;
    __name(assert3, "assert");
    __name(assertUsage3, "assertUsage");
    globalObject10 = getGlobalObject2("assert.ts", { alreadyLogged: /* @__PURE__ */ new Set() });
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isBrowser.js
function isBrowser3() {
  return typeof window !== "undefined" && typeof window.scrollY === "number";
}
var init_isBrowser2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isBrowser.js"() {
    __name(isBrowser3, "isBrowser");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/assertIsNotBrowser.js
function assertIsNotBrowser2() {
  assert3(!isBrowser3());
}
var init_assertIsNotBrowser2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/assertIsNotBrowser.js"() {
    init_isBrowser2();
    init_assert3();
    __name(assertIsNotBrowser2, "assertIsNotBrowser");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/path.js
function pathIsAbsolute(filePath) {
  return IS_ABSOLUTE_RE.test(filePath);
}
function toPosixPath3(path) {
  const pathPosix = path.split("\\").join("/");
  assertPosixPath3(pathPosix);
  return pathPosix;
}
function assertPosixPath3(path) {
  const errMsg = /* @__PURE__ */ __name((msg) => `Not a posix path: ${msg}`, "errMsg");
  assert3(path !== null, errMsg("null"));
  assert3(typeof path === "string", errMsg(`typeof path === ${JSON.stringify(typeof path)}`));
  assert3(path !== "", errMsg("(empty string)"));
  assert3(path);
  assert3(!path.includes("\\"), errMsg(path));
}
var IS_ABSOLUTE_RE;
var init_path2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/path.js"() {
    init_assert3();
    init_assertIsNotBrowser2();
    assertIsNotBrowser2();
    IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
    __name(pathIsAbsolute, "pathIsAbsolute");
    __name(toPosixPath3, "toPosixPath");
    __name(assertPosixPath3, "assertPosixPath");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/unique.js
function unique2(arr) {
  return Array.from(new Set(arr));
}
var init_unique2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/unique.js"() {
    __name(unique2, "unique");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/getUrlPathname.js
var init_getUrlPathname = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/getUrlPathname.js"() {
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isObject.js
function isObject3(value) {
  return typeof value === "object" && value !== null;
}
var init_isObject3 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isObject.js"() {
    __name(isObject3, "isObject");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isPlainObject.js
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  return (
    /* Doesn't work in Cloudlfare Pages workers
    value.constructor === Object
    */
    value.constructor.name === "Object"
  );
}
var init_isPlainObject2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isPlainObject.js"() {
    __name(isPlainObject2, "isPlainObject");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/objectAssign.js
var init_objectAssign2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/objectAssign.js"() {
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/lowercaseFirstLetter.js
var init_lowercaseFirstLetter = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/lowercaseFirstLetter.js"() {
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/getTelefunctionKey.js
function getTelefunctionKey(filePath, exportName) {
  assert3(!exportName.includes(":"));
  const telefunctionKey = filePath + ":" + exportName;
  return telefunctionKey;
}
var init_getTelefunctionKey = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/getTelefunctionKey.js"() {
    init_assert3();
    __name(getTelefunctionKey, "getTelefunctionKey");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isProduction.js
var init_isProduction = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isProduction.js"() {
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/assertModuleScope.js
var globalObject11;
var init_assertModuleScope = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/assertModuleScope.js"() {
    init_getGlobalObject2();
    init_assert3();
    globalObject11 = getGlobalObject2("./assertModuleScope.ts", {
      loadedModules: []
    });
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isTelefuncFilePath.js
function isTelefuncFilePath(filePath) {
  assertPosixPath3(filePath);
  return filePath.includes(".telefunc.");
}
var init_isTelefuncFilePath = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isTelefuncFilePath.js"() {
    init_path2();
    __name(isTelefuncFilePath, "isTelefuncFilePath");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isWebpack.js
var init_isWebpack = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isWebpack.js"() {
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isVikeApp.js
var init_isVikeApp = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isVikeApp.js"() {
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isNullish.js
var init_isNullish2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isNullish.js"() {
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/getRandomId.js
var init_getRandomId2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/getRandomId.js"() {
    init_assert3();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/rollupSourceMap.js
var init_rollupSourceMap = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/rollupSourceMap.js"() {
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isScriptFile.js
var extJs2, extTs2, extJsOrTs2, extJsx2, extTsx2, extJsxOrTsx2, extTemplates2, scriptFileExtensionList2, javaScriptFileExtensionList, javaScriptFileExtensionPattern;
var init_isScriptFile2 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/utils/isScriptFile.js"() {
    init_assertIsNotBrowser2();
    assertIsNotBrowser2();
    extJs2 = [
      "js",
      "cjs",
      "mjs"
    ];
    extTs2 = [
      "ts",
      "cts",
      "mts"
    ];
    extJsOrTs2 = [...extJs2, ...extTs2];
    extJsx2 = [
      "jsx",
      "cjsx",
      "mjsx"
    ];
    extTsx2 = [
      "tsx",
      "ctsx",
      "mtsx"
    ];
    extJsxOrTsx2 = [...extJsx2, ...extTsx2];
    extTemplates2 = [
      "vue",
      "svelte",
      "marko",
      "md",
      "mdx"
    ];
    scriptFileExtensionList2 = [...extJsOrTs2, ...extJsxOrTsx2, ...extTemplates2];
    javaScriptFileExtensionList = [...extJsOrTs2, ...extJsxOrTsx2];
    javaScriptFileExtensionPattern = "(" + javaScriptFileExtensionList.join("|") + ")";
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/utils.js
var init_utils7 = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/utils.js"() {
    init_hasProp2();
    init_isCallable3();
    init_checkType2();
    init_isPromise2();
    init_cast2();
    init_path2();
    init_unique2();
    init_getUrlPathname();
    init_getGlobalObject2();
    init_isObject3();
    init_isPlainObject2();
    init_assert3();
    init_projectInfo2();
    init_objectAssign2();
    init_lowercaseFirstLetter();
    init_getTelefunctionKey();
    init_isProduction();
    init_assertModuleScope();
    init_isTelefuncFilePath();
    init_isWebpack();
    init_isVikeApp();
    init_isNullish2();
    init_getRandomId2();
    init_rollupSourceMap();
    init_isScriptFile2();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/serverConfig.js
function validateUserConfig(configUserUnwrapped, prop, val) {
  if (prop === "root") {
    assertUsage3(typeof val === "string", "config.root should be a string");
    assertUsage3(pathIsAbsolute(val), "config.root should be an absolute path");
    configUserUnwrapped[prop] = val;
  } else if (prop === "telefuncUrl") {
    assertUsage3(typeof val === "string", "config.telefuncUrl should be a string");
    assertUsage3(val.startsWith("/"), `config.telefuncUrl (server-side) is '${val}' but it should start with '/' (it should be a URL pathname such as '/_telefunc'), see https://telefunc.com/telefuncUrl`);
    configUserUnwrapped[prop] = val;
  } else if (prop === "telefuncFiles") {
    const wrongType = "config.telefuncFiles should be a list of paths";
    assertUsage3(Array.isArray(val), wrongType);
    val.forEach((val2) => {
      assertUsage3(typeof val2 === "string", wrongType);
      assertUsage3(pathIsAbsolute(val2), `[config.telefuncFiles] ${val2} should be an absolute path`);
      assertUsage3(isTelefuncFilePath(toPosixPath3(val2)), `[config.telefuncFiles] ${val2} doesn't contain \`.telefunc.\``);
    });
    configUserUnwrapped[prop] = val;
  } else if (prop === "disableEtag") {
    assertUsage3(typeof val === "boolean", "config.disableEtag should be a boolean");
    configUserUnwrapped[prop] = val;
  } else if (prop === "disableNamingConvention") {
    assertUsage3(typeof val === "boolean", "config.disableNamingConvention should be a boolean");
    configUserUnwrapped[prop] = val;
  } else if (prop === "shield") {
    assertUsage3(typeof val === "object" && val !== null, "config.shield should be a object");
    if ("dev" in val) {
      assertUsage3(typeof val.dev === "boolean", "config.shield.dev should be a boolean");
    }
    configUserUnwrapped[prop] = val;
  } else if (prop === "log") {
    assertUsage3(typeof val === "object" && val !== null, "config.log should be an object");
    if ("shieldErrors" in val) {
      const shieldErrors = val.shieldErrors;
      if (typeof shieldErrors === "boolean") {
      } else if (isObject3(shieldErrors)) {
        if ("dev" in shieldErrors) {
          assertUsage3(typeof shieldErrors.dev === "boolean", "config.log.shieldErrors.dev should be a boolean");
        }
        if ("prod" in shieldErrors) {
          assertUsage3(typeof shieldErrors.prod === "boolean", "config.log.shieldErrors.prod should be a boolean");
        }
      } else {
        assertUsage3(false, "config.log.shieldErrors should be either a boolean or an object with dev and prod boolean properties");
      }
    }
    configUserUnwrapped[prop] = val;
  } else {
    assertUsage3(false, `Unknown config.${prop}`);
  }
  return true;
}
var configUser;
var init_serverConfig = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/serverConfig.js"() {
    init_utils7();
    configUser = new Proxy({}, { set: validateUserConfig });
    __name(validateUserConfig, "validateUserConfig");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFilesUsingVite/assertManifest.js
function assertManifest(manifest) {
  assert3(hasProp2(manifest, "version", "string"));
  assertUsage3(manifest.version === projectInfo2.projectVersion, `Re-build your app. (You are using \`telefunc@${projectInfo2.projectVersion}\` while your build has been generated with a different version \`telefunc@${manifest.version}\`.)`);
  assert3(hasProp2(manifest, "config", "object"));
  checkType2(manifest);
}
var init_assertManifest = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFilesUsingVite/assertManifest.js"() {
    init_utils7();
    __name(assertManifest, "assertManifest");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFilesUsingVite/loadBuildEntry.js
function setTelefuncLoaders({ loadTelefuncFiles: loadTelefuncFiles2, loadManifest }) {
  globalObject12.loadTelefuncFiles = loadTelefuncFiles2;
  setServerConfig(loadManifest);
}
function setServerConfig(loadManifest) {
  const manifest = loadManifest();
  assertManifest(manifest);
  Object.assign(configUser, manifest.config);
}
var globalObject12;
var init_loadBuildEntry = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFilesUsingVite/loadBuildEntry.js"() {
    init_serverConfig();
    init_utils7();
    init_assertManifest();
    globalObject12 = getGlobalObject2("loadBuildEntry.ts", {});
    __name(setTelefuncLoaders, "setTelefuncLoaders");
    __name(setServerConfig, "setServerConfig");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/__internal/index.js
var init_internal = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/__internal/index.js"() {
    init_globalContext2();
    init_route();
    init_globalContext2();
    init_assertSetup();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/globalContext.js
var globalObject13;
var init_globalContext = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/globalContext.js"() {
    init_utils7();
    globalObject13 = getGlobalObject2("globalContext.ts", {
      viteDevServer: null
    });
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/vite/plugins/pluginVirtualFileEntry/VIRTUAL_FILE_ENTRY_ID.js
var init_VIRTUAL_FILE_ENTRY_ID = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/vite/plugins/pluginVirtualFileEntry/VIRTUAL_FILE_ENTRY_ID.js"() {
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFilesUsingVite.js
var init_loadTelefuncFilesUsingVite = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFilesUsingVite.js"() {
    init_runtime();
    init_utils7();
    init_loadBuildEntry();
    init_globalContext();
    init_VIRTUAL_FILE_ENTRY_ID();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFilesUsingRegistration.js
function registerTelefunction(telefunction, exportName, telefuncFilePath) {
  var _a2;
  g.telefuncFilesLoaded = (_a2 = g.telefuncFilesLoaded) !== null && _a2 !== void 0 ? _a2 : {};
  g.telefuncFilesLoaded[telefuncFilePath] = {
    ...g.telefuncFilesLoaded[telefuncFilePath],
    [exportName]: telefunction
  };
}
var g;
var init_loadTelefuncFilesUsingRegistration = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFilesUsingRegistration.js"() {
    init_utils7();
    g = getGlobalObject2("loadTelefuncFilesUsingRegistration.ts", {
      telefuncFilesLoaded: null
    });
    __name(registerTelefunction, "registerTelefunction");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFilesFromConfig.js
var init_loadTelefuncFilesFromConfig = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFilesFromConfig.js"() {
    init_utils7();
    init_esm();
    init_picocolors();
    init_serverConfig();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFiles.js
var init_loadTelefuncFiles = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/loadTelefuncFiles.js"() {
    init_utils7();
    init_loadTelefuncFilesUsingVite();
    init_loadTelefuncFilesUsingRegistration();
    init_loadTelefuncFilesFromConfig();
    init_picocolors();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/parseHttpRequest.js
var init_parseHttpRequest = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/parseHttpRequest.js"() {
    init_parse();
    init_utils7();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/Abort.js
var init_Abort = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/Abort.js"() {
    init_utils7();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/getContext/sync.js
function getContext_sync() {
  if (globalObject14.context === null) {
    if (globalObject14.neverRestored) {
      assertUsage3(false, "Using Telefunc to fetch the initial data of your page is discouraged, see https://telefunc.com/initial-data");
    }
    if (globalObject14.hasRestoreAccess || globalObject14.neverProvided) {
      assertUsage3(false, "[getContext()] Make sure to provide a context object, see https://telefunc.com/getContext#provide");
    } else {
      assertUsage3(false, "[getContext()] Cannot access context object, see https://telefunc.com/getContext#access");
    }
  }
  assert3(isObject3(globalObject14.context));
  return globalObject14.context;
}
function restoreContext_sync(context) {
  globalObject14.neverRestored = false;
  provide(context);
}
function provideTelefuncContext_sync(context) {
  assertUsage3(isObject3(context), "[provideTelefuncContext(context)] Argument `context` should be an object");
  provide(context);
}
function provide(context) {
  assert3(context === null || isObject3(context));
  if (context) {
    globalObject14.neverProvided = false;
    globalObject14.context = context;
  }
  globalObject14.hasRestoreAccess = true;
  setTimeout(() => {
    globalObject14.context = null;
    globalObject14.hasRestoreAccess = false;
  }, 0);
}
var globalObject14;
var init_sync = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/getContext/sync.js"() {
    init_utils7();
    globalObject14 = getGlobalObject2("getContext/sync.ts", {
      context: null,
      hasRestoreAccess: false,
      neverProvided: true,
      neverRestored: true
    });
    __name(getContext_sync, "getContext_sync");
    __name(restoreContext_sync, "restoreContext_sync");
    __name(provideTelefuncContext_sync, "provideTelefuncContext_sync");
    __name(provide, "provide");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/getContext.js
var globalObject15;
var init_getContext = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/getContext.js"() {
    init_sync();
    init_utils7();
    globalObject15 = getGlobalObject2("getContext.ts", {
      getContext: getContext_sync,
      restoreContext: restoreContext_sync,
      provideTelefuncContext: provideTelefuncContext_sync,
      isAsyncMode: false
    });
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/executeTelefunction.js
var init_executeTelefunction = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/executeTelefunction.js"() {
    init_Abort();
    init_getContext();
    init_utils7();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/serializeTelefunctionResult.js
var init_serializeTelefunctionResult = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/serializeTelefunctionResult.js"() {
    init_stringify();
    init_utils7();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/handleError.js
var init_handleError = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/handleError.js"() {
    init_utils7();
    init_globalContext();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/onBug.js
var init_onBug = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/onBug.js"() {
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/shield.js
function assertShield(telefunctionShield, shieldInvocation) {
  assertUsage3(Array.isArray(telefunctionShield) || isVerifierTuple(telefunctionShield), [
    `[${shieldInvocation.replace("telefunctionShield", "args")}]`,
    "`args` should be an array.",
    `Example of correct usage: \`${shieldInvocation.replace("telefunctionShield", "[shield.type.string]")}\`.`,
    `Example of wrong usage: \`${shieldInvocation.replace("telefunctionShield", "shield.type.string")}\`.`
  ].join(" "));
}
function isTelefunction(thing) {
  return isCallable3(thing) && !isVerifier(thing);
}
function installShield(telefunction, telefunctionShield, generated) {
  const installedShield = telefunction[shieldKey];
  if (installedShield && generated) {
    return;
  }
  ;
  telefunction[shieldKey] = telefunctionShield;
}
function StringBetter(thing) {
  if (isPlainObject2(thing)) {
    let str = "";
    const entries = Object.entries(thing);
    entries.forEach(([key, val], i) => {
      str += `${String(key)}:${StringBetter(val)}`;
      const isLast = i === entries.length - 1;
      if (!isLast) {
        str += ",";
      }
    });
    str = `{${str}}`;
    return str;
  }
  if (Array.isArray(thing)) {
    return `[${thing.map((el) => StringBetter(el)).join(",")}]`;
  }
  return String(thing);
}
function verifyRecursive(verifier, arg, breadcrumbs) {
  assert3(breadcrumbs.startsWith("[root]"));
  if (isVerifier(verifier)) {
    return verifier(arg, breadcrumbs);
  }
  if (isPlainObject2(verifier)) {
    const obj = verifier;
    return verifyObject(obj, arg, breadcrumbs);
  }
  if (verifier === void 0) {
    return shield.type.const(void 0)(arg, breadcrumbs);
  }
  const errorPrefix3 = `[shield()] Bad shield definition: ${breadcrumbs}`;
  const errorSuffix = `See https://telefunc.com/shield`;
  assertUsage3(!Array.isArray(verifier), errorPrefix3 + " is a plain JavaScript array which is forbidden: use `shield.type.tuple()` instead of `[]`. " + errorSuffix);
  assertUsage3(false, `${errorPrefix3} is \`${getTypeName(verifier)}\` which is forbidden. Always use \`shield.type[x]\` or a plain JavaScript Object. ${errorSuffix}`);
}
function verifyObject(obj, arg, breadcrumbs) {
  if (!isPlainObject2(arg)) {
    return errorMessage(breadcrumbs, getTypeName(arg), "object");
  }
  for (const key of unique2([...Object.keys(obj), ...Object.keys(arg)])) {
    const res = verifyRecursive(obj[key], arg[key], `${breadcrumbs} > [object: value of key \`${key}\`]`);
    if (res !== true) {
      return res;
    }
  }
  return true;
}
function errorMessage(breadcrumbs, is, should) {
  return `${breadcrumbs} is \`${is}\` but should be \`${should}\`.`;
}
function isVerifier(thing) {
  return thing && thing[isVerifierKey] === true;
}
function markVerifier(verifier) {
  assert3(isCallable3(verifier));
  verifier[isVerifierKey] = true;
}
function isVerifierTuple(thing) {
  return isVerifier(thing) && thing[isVerifierTupleKey] === true;
}
function markVerifierTuple(verifier) {
  verifier[isVerifierTupleKey] = true;
}
function getTypeName(thing) {
  if (thing === null) {
    return "null";
  }
  if (thing === void 0) {
    return "undefined";
  }
  if (typeof thing === "object") {
    assert3(thing !== null);
    if (thing.constructor === Date) {
      return "date";
    }
    if (Array.isArray(thing)) {
      return "array";
    }
  }
  return typeof thing;
}
var shieldKey, isVerifierKey, isVerifierTupleKey, shield, type;
var init_shield = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/shield.js"() {
    init_utils7();
    shieldKey = "__telefunc_shield";
    isVerifierKey = "__telefunc_isVerifier";
    isVerifierTupleKey = "__telefunc_isVerifierTuple";
    shield = /* @__PURE__ */ __name(function(arg1, arg2, options) {
      let telefunction;
      let telefunctionShield;
      if (isTelefunction(arg1)) {
        assertShield(arg2, "shield(telefunction, telefunctionShield)");
        telefunction = arg1;
        telefunctionShield = arg2;
      } else if (isTelefunction(arg2)) {
        assertShield(arg1, "shield(telefunctionShield, telefunction)");
        telefunction = arg2;
        telefunctionShield = arg1;
      } else {
        assertUsage3(false, "[shield(arg1, arg2)] Neither `arg1` nor `arg2` is a function, but one should be.");
      }
      installShield(telefunction, telefunctionShield, !!(options === null || options === void 0 ? void 0 : options.__autoGenerated));
      return telefunction;
    }, "shield");
    __name(assertShield, "assertShield");
    __name(isTelefunction, "isTelefunction");
    __name(installShield, "installShield");
    __name(StringBetter, "StringBetter");
    __name(verifyRecursive, "verifyRecursive");
    __name(verifyObject, "verifyObject");
    type = (() => {
      const or = /* @__PURE__ */ __name((...elements) => {
        const verifier = /* @__PURE__ */ __name((input, breadcrumbs) => {
          const typeTargets = elements.map((el) => verifyRecursive(el, input, `${breadcrumbs}`));
          if (typeTargets.includes(true)) {
            return true;
          }
          return `${breadcrumbs} is of wrong type`;
        }, "verifier");
        markVerifier(verifier);
        verifier.toString = () => elements.map((el) => StringBetter(el)).join("|");
        return verifier;
      }, "or");
      const tuple = /* @__PURE__ */ __name((...elements) => {
        const verifier = /* @__PURE__ */ __name((input, breadcrumbs) => {
          if (!Array.isArray(input)) {
            return errorMessage(breadcrumbs, getTypeName(input), "tuple");
          }
          const errorMessages = [...Array(Math.max(input.length, elements.length)).keys()].map((i) => verifyRecursive(i > elements.length - 1 ? type.const(void 0) : elements[i], input[i], `${breadcrumbs} > [tuple: element ${i}]`)).filter((res) => res !== true);
          if (errorMessages.length === 0) {
            return true;
          }
          return errorMessages[0];
        }, "verifier");
        markVerifier(verifier);
        markVerifierTuple(verifier);
        verifier.toString = () => StringBetter(elements);
        return verifier;
      }, "tuple");
      const array2 = /* @__PURE__ */ __name((arrayType) => {
        const verifier = /* @__PURE__ */ __name((input, breadcrumbs) => {
          if (!Array.isArray(input)) {
            return errorMessage(breadcrumbs, getTypeName(input), "array");
          }
          const errorMessages = input.map((_, i) => verifyRecursive(arrayType, input[i], `${breadcrumbs} > [array element ${i}]`)).filter((res) => res !== true);
          if (errorMessages.length === 0) {
            return true;
          }
          return errorMessages[0];
        }, "verifier");
        markVerifier(verifier);
        verifier.toString = () => {
          let s = StringBetter(arrayType);
          if (s.includes(",")) {
            s = `(${s})`;
          }
          s = `${s}[]`;
          return s;
        };
        return verifier;
      }, "array");
      const object = /* @__PURE__ */ __name((objectType) => {
        const verifier = /* @__PURE__ */ __name((input, breadcrumbs) => {
          if (typeof input !== "object" || input === null || input.constructor !== Object) {
            return errorMessage(breadcrumbs, getTypeName(input), "object");
          }
          const errorMessages = Object.entries(input).map(([key, val]) => verifyRecursive(objectType, val, `${breadcrumbs} > [object: value of key \`${key}\`]`)).filter((res) => res !== true);
          if (errorMessages.length === 0) {
            return true;
          }
          return errorMessages[0];
        }, "verifier");
        markVerifier(verifier);
        verifier.toString = () => {
          let s = StringBetter(objectType);
          if (s.includes(",")) {
            s = `(${s})`;
          }
          s = `Record<string, ${s}}`;
          return s;
        };
        return verifier;
      }, "object");
      const const_ = /* @__PURE__ */ __name((val) => {
        const verifier = /* @__PURE__ */ __name((input, breadcrumbs) => input === val ? true : errorMessage(breadcrumbs, String(input), String(val)), "verifier");
        markVerifier(verifier);
        verifier.toString = () => StringBetter(val);
        return verifier;
      }, "const_");
      const string = (() => {
        const verifier = /* @__PURE__ */ __name((input, breadcrumbs) => typeof input === "string" ? true : errorMessage(breadcrumbs, getTypeName(input), "string"), "verifier");
        markVerifier(verifier);
        verifier.toString = () => "string";
        return verifier;
      })();
      const number = (() => {
        const verifier = /* @__PURE__ */ __name((input, breadcrumbs) => typeof input === "number" ? true : errorMessage(breadcrumbs, getTypeName(input), "number"), "verifier");
        markVerifier(verifier);
        verifier.toString = () => "number";
        return verifier;
      })();
      const boolean = (() => {
        const verifier = /* @__PURE__ */ __name((input, breadcrumbs) => input === true || input === false ? true : errorMessage(breadcrumbs, getTypeName(input), "boolean"), "verifier");
        markVerifier(verifier);
        verifier.toString = () => "boolean";
        return verifier;
      })();
      const date = (() => {
        const verifier = /* @__PURE__ */ __name((input, breadcrumbs) => typeof input === "object" && input !== null && input.constructor === Date ? true : errorMessage(breadcrumbs, getTypeName(input), "date"), "verifier");
        markVerifier(verifier);
        verifier.toString = () => "date";
        return verifier;
      })();
      const any = (() => {
        const verifier = /* @__PURE__ */ __name(() => true, "verifier");
        markVerifier(verifier);
        verifier.toString = () => "date";
        return verifier;
      })();
      return {
        string,
        number,
        boolean,
        date,
        array: array2,
        object,
        or,
        tuple,
        const: const_,
        optional: /* @__PURE__ */ __name((param) => or(param, const_(void 0)), "optional"),
        nullable: /* @__PURE__ */ __name((param) => or(param, const_(null)), "nullable"),
        any
      };
    })();
    shield.type = type;
    __name(errorMessage, "errorMessage");
    __name(isVerifier, "isVerifier");
    __name(markVerifier, "markVerifier");
    __name(isVerifierTuple, "isVerifierTuple");
    __name(markVerifierTuple, "markVerifierTuple");
    __name(getTypeName, "getTypeName");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/applyShield.js
var init_applyShield = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/applyShield.js"() {
    init_shield();
    init_utils7();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/assertNamingConvention.js
var init_assertNamingConvention = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/assertNamingConvention.js"() {
    init_esm();
    init_utils7();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/assertTelefunction.js
function assertTelefunction(exportValue, exportName, telefuncFilePath) {
  assertUsage3(isCallable3(exportValue), `${picocolors_default.code(`export { ${exportName} }`)} of ${picocolors_default.bold(telefuncFilePath)} should be a function`);
}
var init_assertTelefunction = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/assertTelefunction.js"() {
    init_utils7();
    init_picocolors();
    __name(assertTelefunction, "assertTelefunction");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/findTelefunction.js
var init_findTelefunction = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/findTelefunction.js"() {
    init_utils7();
    init_assertNamingConvention();
    init_assertTelefunction();
    init_serverConfig();
    init_picocolors();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc.js
var init_runTelefunc = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc.js"() {
    init_utils7();
    init_loadTelefuncFiles();
    init_parseHttpRequest();
    init_executeTelefunction();
    init_serializeTelefunctionResult();
    init_handleError();
    init_onBug();
    init_applyShield();
    init_findTelefunction();
    init_serverConfig();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/telefunc.js
var init_telefunc = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/telefunc.js"() {
    init_runTelefunc();
    init_utils7();
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/decorateTelefunction.js
function decorateTelefunction(telefunction, exportName, telefuncFilePath, appRootDir) {
  assertTelefunction(telefunction, exportName, telefuncFilePath);
  {
    const telefunctionKey = getTelefunctionKey(telefuncFilePath, exportName);
    Object.assign(telefunction, {
      _key: telefunctionKey,
      _appRootDir: appRootDir
    });
  }
  registerTelefunction(telefunction, exportName, telefuncFilePath);
}
var init_decorateTelefunction = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/runTelefunc/decorateTelefunction.js"() {
    init_assertTelefunction();
    init_loadTelefuncFilesUsingRegistration();
    init_utils7();
    __name(decorateTelefunction, "decorateTelefunction");
  }
});

// node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/index.js
function assertServerSide() {
  var _a2;
  const isBrowser5 = typeof window !== "undefined" && "innerHTML" in (((_a2 = window === null || window === void 0 ? void 0 : window.document) === null || _a2 === void 0 ? void 0 : _a2.body) || {});
  assertUsage3(!isBrowser5, [
    "You are loading the `telefunc` module in the browser, but",
    "the `telefunc` module can only be imported in Node.js."
  ].join(" "));
}
var init_server = __esm({
  "node_modules/.pnpm/telefunc@0.2.11_@babel+core@7.28.4_@babel+parser@7.28.4_@babel+types@7.28.4_react-strea_783fb181b215c5521fab3829943fc9eb/node_modules/telefunc/dist/node/server/index.js"() {
    init_telefunc();
    init_serverConfig();
    init_getContext();
    init_Abort();
    init_shield();
    init_onBug();
    init_decorateTelefunction();
    init_utils7();
    assertServerSide();
    __name(assertServerSide, "assertServerSide");
  }
});

// .dev/build/sky.examples.platform.web/web/server/chunks/chunk-DtOK7jkR.js
var chunk_DtOK7jkR_exports = {};
__export(chunk_DtOK7jkR_exports, {
  onTest: () => onTest
});
async function onTest(x) {
  Console.log(x);
}
var __telefunc_t;
var init_chunk_DtOK7jkR = __esm({
  ".dev/build/sky.examples.platform.web/web/server/chunks/chunk-DtOK7jkR.js"() {
    "use strict";
    init_server();
    __name(onTest, "onTest");
    decorateTelefunction(onTest, "onTest", "/pages/index/HomePage.telefunc.ts", "/Users/a/Space/Projects/EmptySet/sky-modules/examples/platform/web");
    __telefunc_t = shield.type;
    shield(onTest, [__telefunc_t.number], { __autoGenerated: true });
  }
});

// .dev/build/sky.examples.platform.web/web/server/chunks/chunk-BLGzEfE8.js
var chunk_BLGzEfE8_exports = {};
__export(chunk_BLGzEfE8_exports, {
  onFetchStarWarsMovie: () => onFetchStarWarsMovie
});
async function onFetchStarWarsMovie(id) {
  return await fetch.json(
    `https://brillout.github.io/star-wars/api/films/${id}.json`
  );
}
var __telefunc_t2;
var init_chunk_BLGzEfE8 = __esm({
  ".dev/build/sky.examples.platform.web/web/server/chunks/chunk-BLGzEfE8.js"() {
    "use strict";
    init_server();
    __name(onFetchStarWarsMovie, "onFetchStarWarsMovie");
    decorateTelefunction(onFetchStarWarsMovie, "onFetchStarWarsMovie", "/pages/old/data-fetching/@id/Page.telefunc.ts", "/Users/a/Space/Projects/EmptySet/sky-modules/examples/platform/web");
    __telefunc_t2 = shield.type;
    shield(onFetchStarWarsMovie, [__telefunc_t2.string], { __autoGenerated: true });
  }
});

// .dev/build/sky.examples.platform.web/web/server/chunks/chunk-VZQ4tFqC.js
var chunk_VZQ4tFqC_exports = {};
__export(chunk_VZQ4tFqC_exports, {
  onInitStarWars: () => onInitStarWars
});
async function onInitStarWars() {
  return await fetch.json("https://brillout.github.io/star-wars/api/films.json");
}
var init_chunk_VZQ4tFqC = __esm({
  ".dev/build/sky.examples.platform.web/web/server/chunks/chunk-VZQ4tFqC.js"() {
    "use strict";
    init_server();
    __name(onInitStarWars, "onInitStarWars");
    decorateTelefunction(onInitStarWars, "onInitStarWars", "/pages/old/data-fetching/index/Page.telefunc.ts", "/Users/a/Space/Projects/EmptySet/sky-modules/examples/platform/web");
    shield.type;
    shield(onInitStarWars, [], { __autoGenerated: true });
  }
});

// .dev/build/sky.examples.platform.web/web/server/chunks/chunk-DCFQADSa.js
var chunk_DCFQADSa_exports = {};
__export(chunk_DCFQADSa_exports, {
  onTest: () => onTest2
});
async function onTest2(x) {
}
var __telefunc_t3;
var init_chunk_DCFQADSa = __esm({
  ".dev/build/sky.examples.platform.web/web/server/chunks/chunk-DCFQADSa.js"() {
    "use strict";
    init_server();
    __name(onTest2, "onTest");
    decorateTelefunction(onTest2, "onTest", "/pages/old/index/HomePage.telefunc.ts", "/Users/a/Space/Projects/EmptySet/sky-modules/examples/platform/web");
    __telefunc_t3 = shield.type;
    shield(onTest2, [__telefunc_t3.number], { __autoGenerated: true });
  }
});

// node_modules/.pnpm/react@19.1.1/node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/.pnpm/react@19.1.1/node_modules/react/cjs/react.development.js"(exports, module2) {
    "use strict";
    (function() {
      function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: /* @__PURE__ */ __name(function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              info[0],
              info[1]
            );
          }, "get")
        });
      }
      __name(defineDeprecationWarning, "defineDeprecationWarning");
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      __name(getIteratorFn, "getIteratorFn");
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
      }
      __name(warnNoop, "warnNoop");
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      __name(Component, "Component");
      function ComponentDummy() {
      }
      __name(ComponentDummy, "ComponentDummy");
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      __name(PureComponent, "PureComponent");
      function testStringCoercion(value) {
        return "" + value;
      }
      __name(testStringCoercion, "testStringCoercion");
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e2) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      __name(checkKeyStringCoercion, "checkKeyStringCoercion");
      function getComponentNameFromType(type2) {
        if (null == type2) return null;
        if ("function" === typeof type2)
          return type2.$$typeof === REACT_CLIENT_REFERENCE ? null : type2.displayName || type2.name || null;
        if ("string" === typeof type2) return type2;
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type2)
          switch ("number" === typeof type2.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type2.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type2.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type2._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type2.render;
              type2 = type2.displayName;
              type2 || (type2 = innerType.displayName || innerType.name || "", type2 = "" !== type2 ? "ForwardRef(" + type2 + ")" : "ForwardRef");
              return type2;
            case REACT_MEMO_TYPE:
              return innerType = type2.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type2._payload;
              type2 = type2._init;
              try {
                return getComponentNameFromType(type2(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      __name(getComponentNameFromType, "getComponentNameFromType");
      function getTaskName(type2) {
        if (type2 === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type2 && null !== type2 && type2.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type2);
          return name ? "<" + name + ">" : "<...>";
        } catch (x) {
          return "<...>";
        }
      }
      __name(getTaskName, "getTaskName");
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      __name(getOwner, "getOwner");
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      __name(UnknownOwner, "UnknownOwner");
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      __name(hasValidKey, "hasValidKey");
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        __name(warnAboutAccessingKey, "warnAboutAccessingKey");
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      __name(defineKeyPropWarningGetter, "defineKeyPropWarningGetter");
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      __name(elementRefGetterWithDeprecationWarning, "elementRefGetterWithDeprecationWarning");
      function ReactElement(type2, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type2 = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type2,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type2, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type2, "ref", { enumerable: false, value: null });
        type2._store = {};
        Object.defineProperty(type2._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type2, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type2, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type2, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type2.props), Object.freeze(type2));
        return type2;
      }
      __name(ReactElement, "ReactElement");
      function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          oldElement._owner,
          oldElement.props,
          oldElement._debugStack,
          oldElement._debugTask
        );
        oldElement._store && (newKey._store.validated = oldElement._store.validated);
        return newKey;
      }
      __name(cloneAndReplaceKey, "cloneAndReplaceKey");
      function isValidElement2(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      __name(isValidElement2, "isValidElement");
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      __name(escape, "escape");
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
      }
      __name(getElementKey, "getElementKey");
      function noop$1() {
      }
      __name(noop$1, "noop$1");
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      __name(resolveThenable, "resolveThenable");
      function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
        var type2 = typeof children;
        if ("undefined" === type2 || "boolean" === type2) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type2) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array2,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback) {
          invokeCallback = children;
          callback = callback(invokeCallback);
          var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
          isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array2, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement2(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + childKey
          ), "" !== nameSoFar && null != invokeCallback && isValidElement2(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array2.push(callback));
          return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type2 = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array2,
              escapedPrefix,
              type2,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (i === children.entries && (didWarnAboutMaps || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type2 = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array2,
              escapedPrefix,
              type2,
              callback
            );
        else if ("object" === type2) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array2,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array2 = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array2 ? "object with keys {" + Object.keys(children).join(", ") + "}" : array2) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      __name(mapIntoArray, "mapIntoArray");
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      __name(mapChildren, "mapChildren");
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status)
          return ctor = payload._result, void 0 === ctor && console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
            ctor
          ), "default" in ctor || console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
            ctor
          ), ctor.default;
        throw payload._result;
      }
      __name(lazyInitializer, "lazyInitializer");
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      __name(resolveDispatcher, "resolveDispatcher");
      function noop2() {
      }
      __name(noop2, "noop");
      function enqueueTask(task) {
        if (null === enqueueTaskImpl)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module2 && module2[requireString]).call(
              module2,
              "timers"
            ).setImmediate;
          } catch (_err) {
            enqueueTaskImpl = /* @__PURE__ */ __name(function(callback) {
              false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback;
              channel.port2.postMessage(void 0);
            }, "enqueueTaskImpl");
          }
        return enqueueTaskImpl(task);
      }
      __name(enqueueTask, "enqueueTask");
      function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
      }
      __name(aggregateErrors, "aggregateErrors");
      function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
        actScopeDepth = prevActScopeDepth;
      }
      __name(popActScope, "popActScope");
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue)
          if (0 !== queue.length)
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              });
              return;
            } catch (error) {
              ReactSharedInternals.thrownErrors.push(error);
            }
          else ReactSharedInternals.actQueue = null;
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
      }
      __name(recursivelyFlushAsyncActWork, "recursivelyFlushAsyncActWork");
      function flushActQueue(queue) {
        if (!isFlushing) {
          isFlushing = true;
          var i = 0;
          try {
            for (; i < queue.length; i++) {
              var callback = queue[i];
              do {
                ReactSharedInternals.didUsePromise = false;
                var continuation = callback(false);
                if (null !== continuation) {
                  if (ReactSharedInternals.didUsePromise) {
                    queue[i] = callback;
                    queue.splice(0, i);
                    return;
                  }
                  callback = continuation;
                } else break;
              } while (1);
            }
            queue.length = 0;
          } catch (error) {
            queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
          } finally {
            isFlushing = false;
          }
        }
      }
      __name(flushActQueue, "flushActQueue");
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: /* @__PURE__ */ __name(function() {
          return false;
        }, "isMounted"),
        enqueueForceUpdate: /* @__PURE__ */ __name(function(publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        }, "enqueueForceUpdate"),
        enqueueReplaceState: /* @__PURE__ */ __name(function(publicInstance) {
          warnNoop(publicInstance, "replaceState");
        }, "enqueueReplaceState"),
        enqueueSetState: /* @__PURE__ */ __name(function(publicInstance) {
          warnNoop(publicInstance, "setState");
        }, "enqueueSetState")
      }, assign2 = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, fnName;
      for (fnName in deprecatedAPIs)
        deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      ComponentDummy.prototype = Component.prototype;
      deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
      deprecatedAPIs.constructor = PureComponent;
      assign2(deprecatedAPIs, Component.prototype);
      deprecatedAPIs.isPureReactComponent = true;
      var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false,
        didUsePromise: false,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      deprecatedAPIs = {
        react_stack_bottom_frame: /* @__PURE__ */ __name(function(callStackForError) {
          return callStackForError();
        }, "react_stack_bottom_frame")
      };
      var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
        deprecatedAPIs,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
          return queueMicrotask(callback);
        });
      } : enqueueTask;
      deprecatedAPIs = Object.freeze({
        __proto__: null,
        c: /* @__PURE__ */ __name(function(size) {
          return resolveDispatcher().useMemoCache(size);
        }, "c")
      });
      exports.Children = {
        map: mapChildren,
        forEach: /* @__PURE__ */ __name(function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        }, "forEach"),
        count: /* @__PURE__ */ __name(function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }, "count"),
        toArray: /* @__PURE__ */ __name(function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }, "toArray"),
        only: /* @__PURE__ */ __name(function(children) {
          if (!isValidElement2(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }, "only")
      };
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = deprecatedAPIs;
      exports.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
        try {
          var result = callback();
        } catch (error) {
          ReactSharedInternals.thrownErrors.push(error);
        }
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
          var thenable = result;
          queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          });
          return {
            then: /* @__PURE__ */ __name(function(resolve, reject) {
              didAwaitActCall = true;
              thenable.then(
                function(returnValue) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  if (0 === prevActScopeDepth) {
                    try {
                      flushActQueue(queue), enqueueTask(function() {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                    } catch (error$0) {
                      ReactSharedInternals.thrownErrors.push(error$0);
                    }
                    if (0 < ReactSharedInternals.thrownErrors.length) {
                      var _thrownError = aggregateErrors(
                        ReactSharedInternals.thrownErrors
                      );
                      ReactSharedInternals.thrownErrors.length = 0;
                      reject(_thrownError);
                    }
                  } else resolve(returnValue);
                },
                function(error) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                    ReactSharedInternals.thrownErrors
                  ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                }
              );
            }, "then")
          };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
          then: /* @__PURE__ */ __name(function(resolve, reject) {
            didAwaitActCall = true;
            0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
              return recursivelyFlushAsyncActWork(
                returnValue$jscomp$0,
                resolve,
                reject
              );
            })) : resolve(returnValue$jscomp$0);
          }, "then")
        };
      };
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports.captureOwnerStack = function() {
        var getCurrentStack = ReactSharedInternals.getCurrentStack;
        return null === getCurrentStack ? null : getCurrentStack();
      };
      exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign2({}, element.props), key = element.key, owner = element._owner;
        if (null != config) {
          var JSCompiler_inline_result;
          a: {
            if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) && JSCompiler_inline_result.isReactWarning) {
              JSCompiler_inline_result = false;
              break a;
            }
            JSCompiler_inline_result = void 0 !== config.ref;
          }
          JSCompiler_inline_result && (owner = getOwner());
          hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
          for (propName in config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          JSCompiler_inline_result = Array(propName);
          for (var i = 0; i < propName; i++)
            JSCompiler_inline_result[i] = arguments[i + 2];
          props.children = JSCompiler_inline_result;
        }
        props = ReactElement(
          element.type,
          key,
          void 0,
          void 0,
          owner,
          props,
          element._debugStack,
          element._debugTask
        );
        for (key = 2; key < arguments.length; key++)
          owner = arguments[key], isValidElement2(owner) && owner._store && (owner._store.validated = 1);
        return props;
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
      };
      exports.createElement = function(type2, config, children) {
        for (var i = 2; i < arguments.length; i++) {
          var node = arguments[i];
          isValidElement2(node) && node._store && (node._store.validated = 1);
        }
        i = {};
        node = null;
        if (null != config)
          for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) i.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
            childArray[_i] = arguments[_i + 2];
          Object.freeze && Object.freeze(childArray);
          i.children = childArray;
        }
        if (type2 && type2.defaultProps)
          for (propName in childrenLength = type2.defaultProps, childrenLength)
            void 0 === i[propName] && (i[propName] = childrenLength[propName]);
        node && defineKeyPropWarningGetter(
          i,
          "function" === typeof type2 ? type2.displayName || type2.name || "Unknown" : type2
        );
        var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return ReactElement(
          type2,
          node,
          void 0,
          void 0,
          getOwner(),
          i,
          propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          propName ? createTask(getTaskName(type2)) : unknownOwnerDebugTask
        );
      };
      exports.createRef = function() {
        var refObject = { current: null };
        Object.seal(refObject);
        return refObject;
      };
      exports.forwardRef = function(render) {
        null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : "function" !== typeof render ? console.error(
          "forwardRef requires a render function but was given %s.",
          null === render ? "null" : typeof render
        ) : 0 !== render.length && 2 !== render.length && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        );
        null != render && null != render.defaultProps && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
        Object.defineProperty(elementType, "displayName", {
          enumerable: false,
          configurable: true,
          get: /* @__PURE__ */ __name(function() {
            return ownName;
          }, "get"),
          set: /* @__PURE__ */ __name(function(name) {
            ownName = name;
            render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
          }, "set")
        });
        return elementType;
      };
      exports.isValidElement = isValidElement2;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type2, compare) {
        null == type2 && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type2 ? "null" : typeof type2
        );
        compare = {
          $$typeof: REACT_MEMO_TYPE,
          type: type2,
          compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
          enumerable: false,
          configurable: true,
          get: /* @__PURE__ */ __name(function() {
            return ownName;
          }, "get"),
          set: /* @__PURE__ */ __name(function(name) {
            ownName = name;
            type2.name || type2.displayName || (Object.defineProperty(type2, "name", { value: name }), type2.displayName = name);
          }, "set")
        });
        return compare;
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        currentTransition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop2, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
      };
      exports.use = function(usable) {
        return resolveDispatcher().use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(
          action,
          initialState,
          permalink
        );
      };
      exports.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
      };
      exports.useContext = function(Context3) {
        var dispatcher = resolveDispatcher();
        Context3.$$typeof === REACT_CONSUMER_TYPE && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
        return dispatcher.useContext(Context3);
      };
      exports.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
      };
      exports.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, createDeps, update) {
        null == create && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        var dispatcher = resolveDispatcher();
        if ("function" === typeof update)
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return dispatcher.useEffect(create, createDeps);
      };
      exports.useId = function() {
        return resolveDispatcher().useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return resolveDispatcher().useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init2) {
        return resolveDispatcher().useReducer(reducer, initialArg, init2);
      };
      exports.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return resolveDispatcher().useTransition();
      };
      exports.version = "19.1.1";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/.pnpm/react@19.1.1/node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/.pnpm/react@19.1.1/node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_development();
    }
  }
});

// node_modules/.pnpm/react@19.1.1/node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/.pnpm/react@19.1.1/node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    (function() {
      function getComponentNameFromType(type2) {
        if (null == type2) return null;
        if ("function" === typeof type2)
          return type2.$$typeof === REACT_CLIENT_REFERENCE ? null : type2.displayName || type2.name || null;
        if ("string" === typeof type2) return type2;
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type2)
          switch ("number" === typeof type2.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type2.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type2.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type2._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type2.render;
              type2 = type2.displayName;
              type2 || (type2 = innerType.displayName || innerType.name || "", type2 = "" !== type2 ? "ForwardRef(" + type2 + ")" : "ForwardRef");
              return type2;
            case REACT_MEMO_TYPE:
              return innerType = type2.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type2._payload;
              type2 = type2._init;
              try {
                return getComponentNameFromType(type2(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      __name(getComponentNameFromType, "getComponentNameFromType");
      function testStringCoercion(value) {
        return "" + value;
      }
      __name(testStringCoercion, "testStringCoercion");
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e2) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      __name(checkKeyStringCoercion, "checkKeyStringCoercion");
      function getTaskName(type2) {
        if (type2 === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type2 && null !== type2 && type2.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type2);
          return name ? "<" + name + ">" : "<...>";
        } catch (x) {
          return "<...>";
        }
      }
      __name(getTaskName, "getTaskName");
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      __name(getOwner, "getOwner");
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      __name(UnknownOwner, "UnknownOwner");
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      __name(hasValidKey, "hasValidKey");
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        __name(warnAboutAccessingKey, "warnAboutAccessingKey");
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      __name(defineKeyPropWarningGetter, "defineKeyPropWarningGetter");
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      __name(elementRefGetterWithDeprecationWarning, "elementRefGetterWithDeprecationWarning");
      function ReactElement(type2, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type2 = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type2,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type2, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type2, "ref", { enumerable: false, value: null });
        type2._store = {};
        Object.defineProperty(type2._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type2, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type2, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type2, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type2.props), Object.freeze(type2));
        return type2;
      }
      __name(ReactElement, "ReactElement");
      function jsxDEVImpl(type2, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children)
          if (isStaticChildren)
            if (isArrayImpl(children)) {
              for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                validateChildKeys(children[isStaticChildren]);
              Object.freeze && Object.freeze(children);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
          children = getComponentNameFromType(type2);
          var keys = Object.keys(config).filter(function(k) {
            return "key" !== k;
          });
          isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
          didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys,
            children
          ), didWarnAboutKeySpread[children + isStaticChildren] = true);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type2 ? type2.displayName || type2.name || "Unknown" : type2
        );
        return ReactElement(
          type2,
          children,
          self,
          source,
          getOwner(),
          maybeKey,
          debugStack,
          debugTask
        );
      }
      __name(jsxDEVImpl, "jsxDEVImpl");
      function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
      }
      __name(validateChildKeys, "validateChildKeys");
      var React5 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React5.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      React5 = {
        react_stack_bottom_frame: /* @__PURE__ */ __name(function(callStackForError) {
          return callStackForError();
        }, "react_stack_bottom_frame")
      };
      var specialPropKeyWarningShown;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = React5.react_stack_bottom_frame.bind(
        React5,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutKeySpread = {};
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = function(type2, config, maybeKey, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type2,
          config,
          maybeKey,
          false,
          source,
          self,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type2)) : unknownOwnerDebugTask
        );
      };
      exports.jsxs = function(type2, config, maybeKey, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type2,
          config,
          maybeKey,
          true,
          source,
          self,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type2)) : unknownOwnerDebugTask
        );
      };
    })();
  }
});

// node_modules/.pnpm/react@19.1.1/node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/.pnpm/react@19.1.1/node_modules/react/jsx-runtime.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/createErrorWithCleanStackTrace.js
function createErrorWithCleanStackTrace4(errorMessage2, numberOfStackTraceLinesToRemove5) {
  const err = new Error(errorMessage2);
  err.stack = clean4(err.stack, numberOfStackTraceLinesToRemove5);
  return err;
}
function clean4(errStack, numberOfStackTraceLinesToRemove5) {
  if (!errStack) {
    return errStack;
  }
  const stackLines = splitByLine4(errStack);
  let linesRemoved = 0;
  const stackLine__cleaned = stackLines.filter((line) => {
    if (line.includes(" (internal/") || line.includes(" (node:internal")) {
      return false;
    }
    if (linesRemoved < numberOfStackTraceLinesToRemove5 && isStackTraceLine4(line)) {
      linesRemoved++;
      return false;
    }
    return true;
  }).join("\n");
  return stackLine__cleaned;
}
function isStackTraceLine4(line) {
  return line.startsWith("    at ");
}
function splitByLine4(str) {
  return str.split(/\r?\n/);
}
var init_createErrorWithCleanStackTrace4 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/createErrorWithCleanStackTrace.js"() {
    __name(createErrorWithCleanStackTrace4, "createErrorWithCleanStackTrace");
    __name(clean4, "clean");
    __name(isStackTraceLine4, "isStackTraceLine");
    __name(splitByLine4, "splitByLine");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/getGlobalObject.js
function getGlobalObject3(key, defaultValue) {
  const globalObjectsAll = globalThis[projectKey2] = globalThis[projectKey2] || {};
  const globalObject24 = globalObjectsAll[key] = globalObjectsAll[key] || defaultValue;
  return globalObject24;
}
var projectKey2;
var init_getGlobalObject3 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/getGlobalObject.js"() {
    __name(getGlobalObject3, "getGlobalObject");
    projectKey2 = "_react_streaming";
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/PROJECT_VERSION.js
var PROJECT_VERSION4;
var init_PROJECT_VERSION4 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/PROJECT_VERSION.js"() {
    PROJECT_VERSION4 = "0.4.3";
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/projectInfo.js
var projectInfo3;
var init_projectInfo3 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/projectInfo.js"() {
    init_PROJECT_VERSION4();
    projectInfo3 = {
      projectName: "react-streaming",
      projectVersion: PROJECT_VERSION4,
      npmPackageName: "react-streaming",
      githubRepository: "https://github.com/brillout/react-streaming"
    };
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/assert.js
function assert4(condition, debugInfo) {
  if (condition) {
    return;
  }
  const debugStr = (() => {
    if (!debugInfo) {
      return "";
    }
    const debugInfoSerialized = typeof debugInfo === "string" ? debugInfo : "`" + JSON.stringify(debugInfo) + "`";
    return `Debug info (this is for the ${projectInfo3.projectName} maintainers; you can ignore this): ${debugInfoSerialized}.`;
  })();
  const internalError = createErrorWithCleanStackTrace4([
    `${internalErrorPrefix3} You stumbled upon a bug in ${projectInfo3.projectName}'s source code.`,
    `Reach out at ${projectInfo3.githubRepository}/issues/new and include this error stack (the error stack is usually enough to fix the problem).`,
    "A maintainer will fix the bug (usually under 24 hours).",
    `Do not hesitate to reach out as it makes ${projectInfo3.projectName} more robust.`,
    debugStr
  ].join(" "), numberOfStackTraceLinesToRemove4);
  throw internalError;
}
function assertUsage4(condition, errorMessage2) {
  if (condition) {
    return;
  }
  const whiteSpace = errorMessage2.startsWith("[") ? "" : " ";
  const usageError = createErrorWithCleanStackTrace4(`${usageErrorPrefix3}${whiteSpace}${errorMessage2}`, numberOfStackTraceLinesToRemove4);
  throw usageError;
}
function assertWarning4(condition, errorMessage2, { onlyOnce, showStackTrace }) {
  if (condition) {
    return;
  }
  const msg = `${warningPrefix2} ${errorMessage2}`;
  if (onlyOnce) {
    const key = onlyOnce === true ? msg : onlyOnce;
    if (alreadyLogged.has(key)) {
      return;
    } else {
      alreadyLogged.add(key);
    }
  }
  if (showStackTrace) {
    console.warn(new Error(msg));
  } else {
    console.warn(msg);
  }
}
function assertSingleVersion() {
  versions.add(projectInfo3.projectVersion);
  if (versions.size >= 2) {
    const versionsStr = Array.from(versions).map((v) => `${projectInfo3.projectName}@${v}`).join(" and ");
    assertWarning4(false, `${versionsStr} loaded which is highly discouraged, see ${picocolors_default.underline("https://vike.dev/warning/version-mismatch")}`, { onlyOnce: true });
  }
}
var _a, errorPrefix2, internalErrorPrefix3, usageErrorPrefix3, warningPrefix2, infoPrefix2, numberOfStackTraceLinesToRemove4, globalObject16, versions, alreadyLogged;
var init_assert4 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/assert.js"() {
    init_createErrorWithCleanStackTrace4();
    init_getGlobalObject3();
    init_projectInfo3();
    init_picocolors();
    errorPrefix2 = `[${projectInfo3.npmPackageName}@${projectInfo3.projectVersion}]`;
    internalErrorPrefix3 = `${errorPrefix2}[Bug]`;
    usageErrorPrefix3 = `${errorPrefix2}[Wrong Usage]`;
    warningPrefix2 = `${errorPrefix2}[Warning]`;
    infoPrefix2 = `${errorPrefix2}[Info]`;
    numberOfStackTraceLinesToRemove4 = 2;
    globalObject16 = getGlobalObject3("assert.ts", {
      versions: /* @__PURE__ */ new Set(),
      alreadyLogged: /* @__PURE__ */ new Set()
    });
    ({ versions } = globalObject16);
    alreadyLogged = (_a = globalObject16.alreadyLogged) !== null && _a !== void 0 ? _a : (
      // TODO/eventually: remove
      // We need to set the same default again because older react-streaming versions (published before 11.03.2025) don't set any default in their getGlobalObject() call
      /* @__PURE__ */ new Set()
    );
    assertSingleVersion();
    __name(assert4, "assert");
    __name(assertUsage4, "assertUsage");
    __name(assertWarning4, "assertWarning");
    __name(assertSingleVersion, "assertSingleVersion");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/isBrowser.js
function isBrowser4() {
  return typeof window !== "undefined" && typeof window.scrollY === "number";
}
var init_isBrowser3 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/isBrowser.js"() {
    __name(isBrowser4, "isBrowser");
  }
});

// node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    (function() {
      function noop2() {
      }
      __name(noop2, "noop");
      function testStringCoercion(value) {
        return "" + value;
      }
      __name(testStringCoercion, "testStringCoercion");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        try {
          testStringCoercion(key);
          var JSCompiler_inline_result = false;
        } catch (e2) {
          JSCompiler_inline_result = true;
        }
        JSCompiler_inline_result && (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
        ), testStringCoercion(key));
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      __name(createPortal$1, "createPortal$1");
      function getCrossOriginStringAs(as2, input) {
        if ("font" === as2) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      __name(getCrossOriginStringAs, "getCrossOriginStringAs");
      function getValueDescriptorExpectingObjectForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
      }
      __name(getValueDescriptorExpectingObjectForWarning, "getValueDescriptorExpectingObjectForWarning");
      function getValueDescriptorExpectingEnumForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
      }
      __name(getValueDescriptorExpectingEnumForWarning, "getValueDescriptorExpectingEnumForWarning");
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      __name(resolveDispatcher, "resolveDispatcher");
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React5 = require_react(), Internals = {
        d: {
          f: noop2,
          r: /* @__PURE__ */ __name(function() {
            throw Error(
              "Invalid form element. requestFormReset must be passed a form that was rendered by React."
            );
          }, "r"),
          D: noop2,
          C: noop2,
          L: noop2,
          m: noop2,
          X: noop2,
          S: noop2,
          M: noop2
        },
        p: 0,
        findDOMNode: null
      }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React5.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
      );
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children, container3) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container3 || 1 !== container3.nodeType && 9 !== container3.nodeType && 11 !== container3.nodeType)
          throw Error("Target container is not a DOM element.");
        return createPortal$1(children, container3, null, key);
      };
      exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn)
            return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
            "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
          );
        }
      };
      exports.preconnect = function(href, options) {
        "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
          "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : null != options && "string" !== typeof options.crossOrigin && console.error(
          "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
          getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
        ) : console.error(
          "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports.prefetchDNS = function(href) {
        if ("string" !== typeof href || !href)
          console.error(
            "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
        else if (1 < arguments.length) {
          var options = arguments[1];
          "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          );
        }
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options) {
        "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
          "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : "style" !== options.as && "script" !== options.as && console.error(
          'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
          getValueDescriptorExpectingEnumForWarning(options.as)
        ) : console.error(
          "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as2 = options.as, crossOrigin = getCrossOriginStringAs(as2, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as2 ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as2 && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
        if (encountered)
          console.error(
            "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
            encountered
          );
        else
          switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
            case "script":
              break;
            default:
              encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                encountered,
                href
              );
          }
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as)
              encountered = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              ), Internals.d.M(href, {
                crossOrigin: encountered,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
          } else null == options && Internals.d.M(href);
      };
      exports.preload = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
          encountered
        );
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          encountered = options.as;
          var crossOrigin = getCrossOriginStringAs(
            encountered,
            options.crossOrigin
          );
          Internals.d.L(href, encountered, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
          encountered
        );
        "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        ), Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin: encountered,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        })) : Internals.d.m(href));
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      exports.useFormState = function(action, initialState, permalink) {
        return resolveDispatcher().useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function() {
        return resolveDispatcher().useHostTransitionStatus();
      };
      exports.version = "19.1.1";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/index.js"(exports, module2) {
    "use strict";
    if (false) {
      checkDCE();
      module2.exports = null;
    } else {
      module2.exports = require_react_dom_development();
    }
  }
});

// node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/cjs/react-dom-server.edge.development.js
var require_react_dom_server_edge_development = __commonJS({
  "node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/cjs/react-dom-server.edge.development.js"(exports) {
    "use strict";
    (function() {
      function styleReplacer(match, prefix4, s, suffix2) {
        return "" + prefix4 + ("s" === s ? "\\73 " : "\\53 ") + suffix2;
      }
      __name(styleReplacer, "styleReplacer");
      function scriptReplacer(match, prefix4, s, suffix2) {
        return "" + prefix4 + ("s" === s ? "\\u0073" : "\\u0053") + suffix2;
      }
      __name(scriptReplacer, "scriptReplacer");
      function objectName(object) {
        return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
          return p0;
        });
      }
      __name(objectName, "objectName");
      function describeKeyForErrorMessage(key) {
        var encodedKey = JSON.stringify(key);
        return '"' + key + '"' === encodedKey ? key : encodedKey;
      }
      __name(describeKeyForErrorMessage, "describeKeyForErrorMessage");
      function describeValueForErrorMessage(value) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(
              10 >= value.length ? value : value.slice(0, 10) + "..."
            );
          case "object":
            if (isArrayImpl(value)) return "[...]";
            if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
              return "client";
            value = objectName(value);
            return "Object" === value ? "{...}" : value;
          case "function":
            return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
          default:
            return String(value);
        }
      }
      __name(describeValueForErrorMessage, "describeValueForErrorMessage");
      function describeElementType(type2) {
        if ("string" === typeof type2) return type2;
        switch (type2) {
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if ("object" === typeof type2)
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeElementType(type2.render);
            case REACT_MEMO_TYPE:
              return describeElementType(type2.type);
            case REACT_LAZY_TYPE:
              var payload = type2._payload;
              type2 = type2._init;
              try {
                return describeElementType(type2(payload));
              } catch (x) {
              }
          }
        return "";
      }
      __name(describeElementType, "describeElementType");
      function describeObjectForErrorMessage(objectOrArray, expandedName) {
        var objKind = objectName(objectOrArray);
        if ("Object" !== objKind && "Array" !== objKind) return objKind;
        var start = -1, length = 0;
        if (isArrayImpl(objectOrArray))
          if (jsxChildrenParents.has(objectOrArray)) {
            var type2 = jsxChildrenParents.get(objectOrArray);
            objKind = "<" + describeElementType(type2) + ">";
            for (var i = 0; i < objectOrArray.length; i++) {
              var value = objectOrArray[i];
              value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
              "" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
            }
            objKind += "</" + describeElementType(type2) + ">";
          } else {
            objKind = "[";
            for (type2 = 0; type2 < objectOrArray.length; type2++)
              0 < type2 && (objKind += ", "), i = objectOrArray[type2], i = "object" === typeof i && null !== i ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), "" + type2 === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
            objKind += "]";
          }
        else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
          objKind = "<" + describeElementType(objectOrArray.type) + "/>";
        else {
          if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
          if (jsxPropsParents.has(objectOrArray)) {
            objKind = jsxPropsParents.get(objectOrArray);
            objKind = "<" + (describeElementType(objKind) || "...");
            type2 = Object.keys(objectOrArray);
            for (i = 0; i < type2.length; i++) {
              objKind += " ";
              value = type2[i];
              objKind += describeKeyForErrorMessage(value) + "=";
              var _value2 = objectOrArray[value];
              var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
              "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
              value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
            }
            objKind += ">";
          } else {
            objKind = "{";
            type2 = Object.keys(objectOrArray);
            for (i = 0; i < type2.length; i++)
              0 < i && (objKind += ", "), value = type2[i], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
            objKind += "}";
          }
        }
        return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
      }
      __name(describeObjectForErrorMessage, "describeObjectForErrorMessage");
      function murmurhash3_32_gc(key, seed) {
        var remainder = key.length & 3;
        var bytes = key.length - remainder;
        var h1 = seed;
        for (seed = 0; seed < bytes; ) {
          var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
          ++seed;
          k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          h1 ^= k1;
          h1 = h1 << 13 | h1 >>> 19;
          h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
          h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
          case 2:
            k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
          case 1:
            k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
        }
        h1 ^= key.length;
        h1 ^= h1 >>> 16;
        h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        return (h1 ^ h1 >>> 16) >>> 0;
      }
      __name(murmurhash3_32_gc, "murmurhash3_32_gc");
      function handleErrorInNextTick(error) {
        setTimeout(function() {
          throw error;
        });
      }
      __name(handleErrorInNextTick, "handleErrorInNextTick");
      function writeChunk(destination, chunk3) {
        if (0 !== chunk3.byteLength)
          if (2048 < chunk3.byteLength)
            0 < writtenBytes && (destination.enqueue(
              new Uint8Array(currentView.buffer, 0, writtenBytes)
            ), currentView = new Uint8Array(2048), writtenBytes = 0), destination.enqueue(chunk3);
          else {
            var allowableBytes = currentView.length - writtenBytes;
            allowableBytes < chunk3.byteLength && (0 === allowableBytes ? destination.enqueue(currentView) : (currentView.set(
              chunk3.subarray(0, allowableBytes),
              writtenBytes
            ), destination.enqueue(currentView), chunk3 = chunk3.subarray(allowableBytes)), currentView = new Uint8Array(2048), writtenBytes = 0);
            currentView.set(chunk3, writtenBytes);
            writtenBytes += chunk3.byteLength;
          }
      }
      __name(writeChunk, "writeChunk");
      function writeChunkAndReturn(destination, chunk3) {
        writeChunk(destination, chunk3);
        return true;
      }
      __name(writeChunkAndReturn, "writeChunkAndReturn");
      function completeWriting(destination) {
        currentView && 0 < writtenBytes && (destination.enqueue(
          new Uint8Array(currentView.buffer, 0, writtenBytes)
        ), currentView = null, writtenBytes = 0);
      }
      __name(completeWriting, "completeWriting");
      function stringToChunk(content) {
        return textEncoder.encode(content);
      }
      __name(stringToChunk, "stringToChunk");
      function stringToPrecomputedChunk(content) {
        content = textEncoder.encode(content);
        2048 < content.byteLength && console.error(
          "precomputed chunks must be smaller than the view size configured for this host. This is a bug in React."
        );
        return content;
      }
      __name(stringToPrecomputedChunk, "stringToPrecomputedChunk");
      function closeWithError(destination, error) {
        "function" === typeof destination.error ? destination.error(error) : destination.close();
      }
      __name(closeWithError, "closeWithError");
      function typeName(value) {
        return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
      }
      __name(typeName, "typeName");
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), false;
        } catch (e2) {
          return true;
        }
      }
      __name(willCoercionThrow, "willCoercionThrow");
      function testStringCoercion(value) {
        return "" + value;
      }
      __name(testStringCoercion, "testStringCoercion");
      function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
            attributeName,
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkAttributeStringCoercion, "checkAttributeStringCoercion");
      function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
            propName,
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkCSSPropertyStringCoercion, "checkCSSPropertyStringCoercion");
      function checkHtmlStringCoercion(value) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkHtmlStringCoercion, "checkHtmlStringCoercion");
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
          return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        console.error("Invalid attribute name: `%s`", attributeName);
        return false;
      }
      __name(isAttributeNameSafe, "isAttributeNameSafe");
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
        ) : console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
        ));
        props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
          "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
        );
      }
      __name(checkControlledValueProps, "checkControlledValueProps");
      function validateProperty$1(tagName, name) {
        if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
          return true;
        if (rARIACamel$1.test(name)) {
          tagName = "aria-" + name.slice(4).toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
              name
            ), warnedProperties$1[name] = true;
          if (name !== tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true;
        }
        if (rARIA$1.test(name)) {
          tagName = name.toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName) return warnedProperties$1[name] = true, false;
          name !== tagName && (console.error(
            "Unknown ARIA attribute `%s`. Did you mean `%s`?",
            name,
            tagName
          ), warnedProperties$1[name] = true);
        }
        return true;
      }
      __name(validateProperty$1, "validateProperty$1");
      function validateProperties$2(type2, props) {
        var invalidProps = [], key;
        for (key in props)
          validateProperty$1(type2, key) || invalidProps.push(key);
        props = invalidProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === invalidProps.length ? console.error(
          "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type2
        ) : 1 < invalidProps.length && console.error(
          "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type2
        );
      }
      __name(validateProperties$2, "validateProperties$2");
      function validateProperty(tagName, name, value, eventRegistry) {
        if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
          return true;
        var lowerCasedName = name.toLowerCase();
        if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
          return console.error(
            "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
          ), warnedProperties[name] = true;
        if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
          return true;
        if (null != eventRegistry) {
          tagName = eventRegistry.possibleRegistrationNames;
          if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
            return true;
          eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
          if (null != eventRegistry)
            return console.error(
              "Invalid event handler property `%s`. Did you mean `%s`?",
              name,
              eventRegistry
            ), warnedProperties[name] = true;
          if (EVENT_NAME_REGEX.test(name))
            return console.error(
              "Unknown event handler property `%s`. It will be ignored.",
              name
            ), warnedProperties[name] = true;
        } else if (EVENT_NAME_REGEX.test(name))
          return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
            "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
            name
          ), warnedProperties[name] = true;
        if (rARIA.test(name) || rARIACamel.test(name)) return true;
        if ("innerhtml" === lowerCasedName)
          return console.error(
            "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
          ), warnedProperties[name] = true;
        if ("aria" === lowerCasedName)
          return console.error(
            "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
          ), warnedProperties[name] = true;
        if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
          return console.error(
            "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
            typeof value
          ), warnedProperties[name] = true;
        if ("number" === typeof value && isNaN(value))
          return console.error(
            "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
            name
          ), warnedProperties[name] = true;
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
          if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
            return console.error(
              "Invalid DOM property `%s`. Did you mean `%s`?",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
        } else if (name !== lowerCasedName)
          return console.error(
            "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
            name,
            lowerCasedName
          ), warnedProperties[name] = true;
        switch (name) {
          case "dangerouslySetInnerHTML":
          case "children":
          case "style":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            return true;
          case "innerText":
          case "textContent":
            return true;
        }
        switch (typeof value) {
          case "boolean":
            switch (name) {
              case "autoFocus":
              case "checked":
              case "multiple":
              case "muted":
              case "selected":
              case "contentEditable":
              case "spellCheck":
              case "draggable":
              case "value":
              case "autoReverse":
              case "externalResourcesRequired":
              case "focusable":
              case "preserveAlpha":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "capture":
              case "download":
              case "inert":
                return true;
              default:
                lowerCasedName = name.toLowerCase().slice(0, 5);
                if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                  return true;
                value ? console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                  value,
                  name,
                  name,
                  value,
                  name
                ) : console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                  value,
                  name,
                  name,
                  value,
                  name,
                  name,
                  name
                );
                return warnedProperties[name] = true;
            }
          case "function":
          case "symbol":
            return warnedProperties[name] = true, false;
          case "string":
            if ("false" === value || "true" === value) {
              switch (name) {
                case "checked":
                case "selected":
                case "multiple":
                case "muted":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "inert":
                  break;
                default:
                  return true;
              }
              console.error(
                "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                value,
                name,
                "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                name,
                value
              );
              warnedProperties[name] = true;
            }
        }
        return true;
      }
      __name(validateProperty, "validateProperty");
      function warnUnknownProperties(type2, props, eventRegistry) {
        var unknownProps = [], key;
        for (key in props)
          validateProperty(type2, key, props[key], eventRegistry) || unknownProps.push(key);
        props = unknownProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === unknownProps.length ? console.error(
          "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type2
        ) : 1 < unknownProps.length && console.error(
          "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type2
        );
      }
      __name(warnUnknownProperties, "warnUnknownProperties");
      function camelize(string) {
        return string.replace(hyphenPattern, function(_, character) {
          return character.toUpperCase();
        });
      }
      __name(camelize, "camelize");
      function escapeTextForBrowser(text) {
        if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text)
          return "" + text;
        checkHtmlStringCoercion(text);
        text = "" + text;
        var match = matchHtmlRegExp.exec(text);
        if (match) {
          var html = "", index, lastIndex = 0;
          for (index = match.index; index < text.length; index++) {
            switch (text.charCodeAt(index)) {
              case 34:
                match = "&quot;";
                break;
              case 38:
                match = "&amp;";
                break;
              case 39:
                match = "&#x27;";
                break;
              case 60:
                match = "&lt;";
                break;
              case 62:
                match = "&gt;";
                break;
              default:
                continue;
            }
            lastIndex !== index && (html += text.slice(lastIndex, index));
            lastIndex = index + 1;
            html += match;
          }
          text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
        }
        return text;
      }
      __name(escapeTextForBrowser, "escapeTextForBrowser");
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      __name(sanitizeURL, "sanitizeURL");
      function escapeEntireInlineScriptContent(scriptText) {
        checkHtmlStringCoercion(scriptText);
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      __name(escapeEntireInlineScriptContent, "escapeEntireInlineScriptContent");
      function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {
        var inlineScriptWithNonce = void 0 === nonce ? startInlineScript : stringToPrecomputedChunk(
          '<script nonce="' + escapeTextForBrowser(nonce) + '">'
        ), idPrefix = resumableState.idPrefix;
        externalRuntimeConfig = [];
        var bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
        void 0 !== bootstrapScriptContent && externalRuntimeConfig.push(
          inlineScriptWithNonce,
          stringToChunk(
            escapeEntireInlineScriptContent(bootstrapScriptContent)
          ),
          endInlineScript
        );
        bootstrapScriptContent = [];
        void 0 !== importMap && (bootstrapScriptContent.push(importMapScriptStart), bootstrapScriptContent.push(
          stringToChunk(
            escapeEntireInlineScriptContent(JSON.stringify(importMap))
          )
        ), bootstrapScriptContent.push(importMapScriptEnd));
        onHeaders && "number" === typeof maxHeadersLength && 0 >= maxHeadersLength && console.error(
          "React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.",
          0 === maxHeadersLength ? "zero" : maxHeadersLength
        );
        importMap = onHeaders ? {
          preconnects: "",
          fontPreloads: "",
          highImagePreloads: "",
          remainingCapacity: 2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
        } : null;
        onHeaders = {
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
          startInlineScript: inlineScriptWithNonce,
          preamble: createPreambleState(),
          externalRuntimeScript: null,
          bootstrapChunks: externalRuntimeConfig,
          importMapChunks: bootstrapScriptContent,
          onHeaders,
          headers: importMap,
          resets: {
            font: {},
            dns: {},
            connect: { default: {}, anonymous: {}, credentials: {} },
            image: {},
            style: {}
          },
          charsetChunks: [],
          viewportChunks: [],
          hoistableChunks: [],
          preconnects: /* @__PURE__ */ new Set(),
          fontPreloads: /* @__PURE__ */ new Set(),
          highImagePreloads: /* @__PURE__ */ new Set(),
          styles: /* @__PURE__ */ new Map(),
          bootstrapScripts: /* @__PURE__ */ new Set(),
          scripts: /* @__PURE__ */ new Set(),
          bulkPreloads: /* @__PURE__ */ new Set(),
          preloads: {
            images: /* @__PURE__ */ new Map(),
            stylesheets: /* @__PURE__ */ new Map(),
            scripts: /* @__PURE__ */ new Map(),
            moduleScripts: /* @__PURE__ */ new Map()
          },
          nonce,
          hoistableState: null,
          stylesToHoist: false
        };
        if (void 0 !== bootstrapScripts)
          for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {
            maxHeadersLength = bootstrapScripts[importMap];
            bootstrapScriptContent = idPrefix = void 0;
            var props = {
              rel: "preload",
              as: "script",
              fetchPriority: "low",
              nonce
            };
            "string" === typeof maxHeadersLength ? props.href = inlineScriptWithNonce = maxHeadersLength : (props.href = inlineScriptWithNonce = maxHeadersLength.src, props.integrity = bootstrapScriptContent = "string" === typeof maxHeadersLength.integrity ? maxHeadersLength.integrity : void 0, props.crossOrigin = idPrefix = "string" === typeof maxHeadersLength || null == maxHeadersLength.crossOrigin ? void 0 : "use-credentials" === maxHeadersLength.crossOrigin ? "use-credentials" : "");
            preloadBootstrapScriptOrModule(
              resumableState,
              onHeaders,
              inlineScriptWithNonce,
              props
            );
            externalRuntimeConfig.push(
              startScriptSrc,
              stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
            );
            nonce && externalRuntimeConfig.push(
              scriptNonce,
              stringToChunk(escapeTextForBrowser(nonce))
            );
            "string" === typeof bootstrapScriptContent && externalRuntimeConfig.push(
              scriptIntegirty,
              stringToChunk(escapeTextForBrowser(bootstrapScriptContent))
            );
            "string" === typeof idPrefix && externalRuntimeConfig.push(
              scriptCrossOrigin,
              stringToChunk(escapeTextForBrowser(idPrefix))
            );
            externalRuntimeConfig.push(endAsyncScript);
          }
        if (void 0 !== bootstrapModules)
          for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
            importMap = bootstrapModules[bootstrapScripts], idPrefix = inlineScriptWithNonce = void 0, bootstrapScriptContent = {
              rel: "modulepreload",
              fetchPriority: "low",
              nonce
            }, "string" === typeof importMap ? bootstrapScriptContent.href = maxHeadersLength = importMap : (bootstrapScriptContent.href = maxHeadersLength = importMap.src, bootstrapScriptContent.integrity = idPrefix = "string" === typeof importMap.integrity ? importMap.integrity : void 0, bootstrapScriptContent.crossOrigin = inlineScriptWithNonce = "string" === typeof importMap || null == importMap.crossOrigin ? void 0 : "use-credentials" === importMap.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(
              resumableState,
              onHeaders,
              maxHeadersLength,
              bootstrapScriptContent
            ), externalRuntimeConfig.push(
              startModuleSrc,
              stringToChunk(escapeTextForBrowser(maxHeadersLength))
            ), nonce && externalRuntimeConfig.push(
              scriptNonce,
              stringToChunk(escapeTextForBrowser(nonce))
            ), "string" === typeof idPrefix && externalRuntimeConfig.push(
              scriptIntegirty,
              stringToChunk(escapeTextForBrowser(idPrefix))
            ), "string" === typeof inlineScriptWithNonce && externalRuntimeConfig.push(
              scriptCrossOrigin,
              stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))
            ), externalRuntimeConfig.push(endAsyncScript);
        return onHeaders;
      }
      __name(createRenderState, "createRenderState");
      function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        return {
          idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
          nextFormID: 0,
          streamingFormat: 0,
          bootstrapScriptContent,
          bootstrapScripts,
          bootstrapModules,
          instructions: NothingSent,
          hasBody: false,
          hasHtml: false,
          unknownResources: {},
          dnsResources: {},
          connectResources: { default: {}, anonymous: {}, credentials: {} },
          imageResources: {},
          styleResources: {},
          scriptResources: {},
          moduleUnknownResources: {},
          moduleScriptResources: {}
        };
      }
      __name(createResumableState, "createResumableState");
      function createPreambleState() {
        return {
          htmlChunks: null,
          headChunks: null,
          bodyChunks: null,
          contribution: NoContribution
        };
      }
      __name(createPreambleState, "createPreambleState");
      function createFormatContext(insertionMode, selectedValue, tagScope) {
        return {
          insertionMode,
          selectedValue,
          tagScope
        };
      }
      __name(createFormatContext, "createFormatContext");
      function createRootFormatContext(namespaceURI) {
        return createFormatContext(
          "http://www.w3.org/2000/svg" === namespaceURI ? SVG_MODE : "http://www.w3.org/1998/Math/MathML" === namespaceURI ? MATHML_MODE : ROOT_HTML_MODE,
          null,
          0
        );
      }
      __name(createRootFormatContext, "createRootFormatContext");
      function getChildFormatContext(parentContext, type2, props) {
        switch (type2) {
          case "noscript":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 1
            );
          case "select":
            return createFormatContext(
              HTML_MODE,
              null != props.value ? props.value : props.defaultValue,
              parentContext.tagScope
            );
          case "svg":
            return createFormatContext(SVG_MODE, null, parentContext.tagScope);
          case "picture":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 2
            );
          case "math":
            return createFormatContext(MATHML_MODE, null, parentContext.tagScope);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null, parentContext.tagScope);
          case "table":
            return createFormatContext(
              HTML_TABLE_MODE,
              null,
              parentContext.tagScope
            );
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(
              HTML_TABLE_BODY_MODE,
              null,
              parentContext.tagScope
            );
          case "colgroup":
            return createFormatContext(
              HTML_COLGROUP_MODE,
              null,
              parentContext.tagScope
            );
          case "tr":
            return createFormatContext(
              HTML_TABLE_ROW_MODE,
              null,
              parentContext.tagScope
            );
          case "head":
            if (parentContext.insertionMode < HTML_MODE)
              return createFormatContext(
                HTML_HEAD_MODE,
                null,
                parentContext.tagScope
              );
            break;
          case "html":
            if (parentContext.insertionMode === ROOT_HTML_MODE)
              return createFormatContext(
                HTML_HTML_MODE,
                null,
                parentContext.tagScope
              );
        }
        return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext(HTML_MODE, null, parentContext.tagScope) : parentContext;
      }
      __name(getChildFormatContext, "getChildFormatContext");
      function pushTextInstance(target, text, renderState, textEmbedded) {
        if ("" === text) return textEmbedded;
        textEmbedded && target.push(textSeparator);
        target.push(stringToChunk(escapeTextForBrowser(text)));
        return true;
      }
      __name(pushTextInstance, "pushTextInstance");
      function pushStyleAttribute(target, style) {
        if ("object" !== typeof style)
          throw Error(
            "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
          );
        var isFirst = true, styleName;
        for (styleName in style)
          if (hasOwnProperty.call(style, styleName)) {
            var styleValue = style[styleName];
            if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
              if (0 === styleName.indexOf("--")) {
                var nameChunk = stringToChunk(escapeTextForBrowser(styleName));
                checkCSSPropertyStringCoercion(styleValue, styleName);
                styleValue = stringToChunk(
                  escapeTextForBrowser(("" + styleValue).trim())
                );
              } else {
                nameChunk = styleName;
                var value = styleValue;
                if (-1 < nameChunk.indexOf("-")) {
                  var name = nameChunk;
                  warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                    "Unsupported style property %s. Did you mean %s?",
                    name,
                    camelize(name.replace(msPattern$1, "ms-"))
                  ));
                } else if (badVendoredStyleNamePattern.test(nameChunk))
                  name = nameChunk, warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                    "Unsupported vendor-prefixed style property %s. Did you mean %s?",
                    name,
                    name.charAt(0).toUpperCase() + name.slice(1)
                  ));
                else if (badStyleValueWithSemicolonPattern.test(value)) {
                  name = nameChunk;
                  var value$jscomp$0 = value;
                  warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = true, console.error(
                    `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
                    name,
                    value$jscomp$0.replace(
                      badStyleValueWithSemicolonPattern,
                      ""
                    )
                  ));
                }
                "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
                  "`NaN` is an invalid value for the `%s` css style property.",
                  nameChunk
                )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
                  "`Infinity` is an invalid value for the `%s` css style property.",
                  nameChunk
                )));
                nameChunk = styleName;
                value = styleNameCache.get(nameChunk);
                void 0 !== value ? nameChunk = value : (value = stringToPrecomputedChunk(
                  escapeTextForBrowser(
                    nameChunk.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
                  )
                ), styleNameCache.set(nameChunk, value), nameChunk = value);
                "number" === typeof styleValue ? styleValue = 0 === styleValue || unitlessNumbers.has(styleName) ? stringToChunk("" + styleValue) : stringToChunk(styleValue + "px") : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = stringToChunk(
                  escapeTextForBrowser(("" + styleValue).trim())
                ));
              }
              isFirst ? (isFirst = false, target.push(
                styleAttributeStart,
                nameChunk,
                styleAssign,
                styleValue
              )) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
            }
          }
        isFirst || target.push(attributeEnd);
      }
      __name(pushStyleAttribute, "pushStyleAttribute");
      function pushBooleanAttribute(target, name, value) {
        value && "function" !== typeof value && "symbol" !== typeof value && target.push(
          attributeSeparator,
          stringToChunk(name),
          attributeEmptyString
        );
      }
      __name(pushBooleanAttribute, "pushBooleanAttribute");
      function pushStringAttribute(target, name, value) {
        "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(
          attributeSeparator,
          stringToChunk(name),
          attributeAssign,
          stringToChunk(escapeTextForBrowser(value)),
          attributeEnd
        );
      }
      __name(pushStringAttribute, "pushStringAttribute");
      function pushAdditionalFormField(value, key) {
        this.push(startHiddenInputChunk);
        validateAdditionalFormField(value);
        pushStringAttribute(this, "name", key);
        pushStringAttribute(this, "value", value);
        this.push(endOfStartTagSelfClosing);
      }
      __name(pushAdditionalFormField, "pushAdditionalFormField");
      function validateAdditionalFormField(value) {
        if ("string" !== typeof value)
          throw Error(
            "File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration."
          );
      }
      __name(validateAdditionalFormField, "validateAdditionalFormField");
      function getCustomFormFields(resumableState, formAction) {
        if ("function" === typeof formAction.$$FORM_ACTION) {
          var id = resumableState.nextFormID++;
          resumableState = resumableState.idPrefix + id;
          try {
            var customFields = formAction.$$FORM_ACTION(resumableState);
            if (customFields) {
              var formData = customFields.data;
              null != formData && formData.forEach(validateAdditionalFormField);
            }
            return customFields;
          } catch (x) {
            if ("object" === typeof x && null !== x && "function" === typeof x.then)
              throw x;
            console.error(
              "Failed to serialize an action for progressive enhancement:\n%s",
              x
            );
          }
        }
        return null;
      }
      __name(getCustomFormFields, "getCustomFormFields");
      function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
        var formData = null;
        if ("function" === typeof formAction) {
          null === name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          ));
          null === formEncType && null === formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          ));
          null === formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ));
          var customFields = getCustomFormFields(resumableState, formAction);
          null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(
            attributeSeparator,
            stringToChunk("formAction"),
            attributeAssign,
            actionJavaScriptURL,
            attributeEnd
          ), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));
        }
        null != name && pushAttribute(target, "name", name);
        null != formAction && pushAttribute(target, "formAction", formAction);
        null != formEncType && pushAttribute(target, "formEncType", formEncType);
        null != formMethod && pushAttribute(target, "formMethod", formMethod);
        null != formTarget && pushAttribute(target, "formTarget", formTarget);
        return formData;
      }
      __name(pushFormActionAttribute, "pushFormActionAttribute");
      function pushAttribute(target, name, value) {
        switch (name) {
          case "className":
            pushStringAttribute(target, "class", value);
            break;
          case "tabIndex":
            pushStringAttribute(target, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            pushStringAttribute(target, name, value);
            break;
          case "style":
            pushStyleAttribute(target, value);
            break;
          case "src":
          case "href":
            if ("" === value) {
              "src" === name ? console.error(
                'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name,
                name
              ) : console.error(
                'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name,
                name
              );
              break;
            }
          case "action":
          case "formAction":
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "ref":
            break;
          case "autoFocus":
          case "multiple":
          case "muted":
            pushBooleanAttribute(target, name.toLowerCase(), value);
            break;
          case "xlinkHref":
            if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              stringToChunk("xlink:href"),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "inert":
            "" !== value || didWarnForNewBooleanPropsWithEmptyValue[name] || (didWarnForNewBooleanPropsWithEmptyValue[name] = true, console.error(
              "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
              name
            ));
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeEmptyString
            );
            break;
          case "capture":
          case "download":
            true === value ? target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeEmptyString
            ) : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "rowSpan":
          case "start":
            "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
            break;
          case "xlinkActuate":
            pushStringAttribute(target, "xlink:actuate", value);
            break;
          case "xlinkArcrole":
            pushStringAttribute(target, "xlink:arcrole", value);
            break;
          case "xlinkRole":
            pushStringAttribute(target, "xlink:role", value);
            break;
          case "xlinkShow":
            pushStringAttribute(target, "xlink:show", value);
            break;
          case "xlinkTitle":
            pushStringAttribute(target, "xlink:title", value);
            break;
          case "xlinkType":
            pushStringAttribute(target, "xlink:type", value);
            break;
          case "xmlBase":
            pushStringAttribute(target, "xml:base", value);
            break;
          case "xmlLang":
            pushStringAttribute(target, "xml:lang", value);
            break;
          case "xmlSpace":
            pushStringAttribute(target, "xml:space", value);
            break;
          default:
            if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
              if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {
                switch (typeof value) {
                  case "function":
                  case "symbol":
                    return;
                  case "boolean":
                    var prefix4 = name.toLowerCase().slice(0, 5);
                    if ("data-" !== prefix4 && "aria-" !== prefix4) return;
                }
                target.push(
                  attributeSeparator,
                  stringToChunk(name),
                  attributeAssign,
                  stringToChunk(escapeTextForBrowser(value)),
                  attributeEnd
                );
              }
            }
        }
      }
      __name(pushAttribute, "pushAttribute");
      function pushInnerHTML(target, innerHTML, children) {
        if (null != innerHTML) {
          if (null != children)
            throw Error(
              "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
            );
          if ("object" !== typeof innerHTML || !("__html" in innerHTML))
            throw Error(
              "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
            );
          innerHTML = innerHTML.__html;
          null !== innerHTML && void 0 !== innerHTML && (checkHtmlStringCoercion(innerHTML), target.push(stringToChunk("" + innerHTML)));
        }
      }
      __name(pushInnerHTML, "pushInnerHTML");
      function checkSelectProp(props, propName) {
        var value = props[propName];
        null != value && (value = isArrayImpl(value), props.multiple && !value ? console.error(
          "The `%s` prop supplied to <select> must be an array if `multiple` is true.",
          propName
        ) : !props.multiple && value && console.error(
          "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.",
          propName
        ));
      }
      __name(checkSelectProp, "checkSelectProp");
      function flattenOptionChildren(children) {
        var content = "";
        React5.Children.forEach(children, function(child) {
          null != child && (content += child, didWarnInvalidOptionChildren || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || (didWarnInvalidOptionChildren = true, console.error(
            "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
          )));
        });
        return content;
      }
      __name(flattenOptionChildren, "flattenOptionChildren");
      function injectFormReplayingRuntime(resumableState, renderState) {
        (resumableState.instructions & 16) === NothingSent && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(
          renderState.startInlineScript,
          formReplayingRuntimeScript,
          endInlineScript
        ));
      }
      __name(injectFormReplayingRuntime, "injectFormReplayingRuntime");
      function pushLinkImpl(target, props) {
        target.push(startChunkForTag("link"));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      __name(pushLinkImpl, "pushLinkImpl");
      function escapeStyleTextContent(styleText) {
        checkHtmlStringCoercion(styleText);
        return ("" + styleText).replace(styleRegex, styleReplacer);
      }
      __name(escapeStyleTextContent, "escapeStyleTextContent");
      function pushSelfClosing(target, props, tag) {
        target.push(startChunkForTag(tag));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      __name(pushSelfClosing, "pushSelfClosing");
      function pushTitleImpl(target, props) {
        target.push(startChunkForTag("title"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
        "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(stringToChunk(escapeTextForBrowser("" + props)));
        pushInnerHTML(target, innerHTML, children);
        target.push(endChunkForTag("title"));
        return null;
      }
      __name(pushTitleImpl, "pushTitleImpl");
      function pushScriptImpl(target, props) {
        target.push(startChunkForTag("script"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        null != children && "string" !== typeof children && (props = "number" === typeof children ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error(
          "A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.",
          props
        ));
        pushInnerHTML(target, innerHTML, children);
        "string" === typeof children && target.push(stringToChunk(escapeEntireInlineScriptContent(children)));
        target.push(endChunkForTag("script"));
        return null;
      }
      __name(pushScriptImpl, "pushScriptImpl");
      function pushStartSingletonElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return tag;
      }
      __name(pushStartSingletonElement, "pushStartSingletonElement");
      function pushStartGenericElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return "string" === typeof tag ? (target.push(stringToChunk(escapeTextForBrowser(tag))), null) : tag;
      }
      __name(pushStartGenericElement, "pushStartGenericElement");
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (void 0 === tagStartChunk) {
          if (!VALID_TAG_REGEX.test(tag)) throw Error("Invalid tag: " + tag);
          tagStartChunk = stringToPrecomputedChunk("<" + tag);
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      __name(startChunkForTag, "startChunkForTag");
      function pushStartInstance(target$jscomp$0, type2, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {
        validateProperties$2(type2, props);
        "input" !== type2 && "textarea" !== type2 && "select" !== type2 || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type2 && props.multiple ? console.error(
          "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
          type2
        ) : console.error(
          "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
          type2
        ));
        b: if (-1 === type2.indexOf("-")) var JSCompiler_inline_result = false;
        else
          switch (type2) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              JSCompiler_inline_result = false;
              break b;
            default:
              JSCompiler_inline_result = true;
          }
        JSCompiler_inline_result || "string" === typeof props.is || warnUnknownProperties(type2, props, null);
        !props.suppressContentEditableWarning && props.contentEditable && null != props.children && console.error(
          "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
        );
        formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && -1 === type2.indexOf("-") && type2.toLowerCase() !== type2 && console.error(
          "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
          type2
        );
        switch (type2) {
          case "div":
          case "span":
          case "svg":
          case "path":
            break;
          case "a":
            target$jscomp$0.push(startChunkForTag("a"));
            var children = null, innerHTML = null, propKey;
            for (propKey in props)
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "children":
                      children = propValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML = propValue;
                      break;
                    case "href":
                      "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                      break;
                    default:
                      pushAttribute(target$jscomp$0, propKey, propValue);
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML, children);
            if ("string" === typeof children) {
              target$jscomp$0.push(stringToChunk(escapeTextForBrowser(children)));
              var JSCompiler_inline_result$jscomp$0 = null;
            } else JSCompiler_inline_result$jscomp$0 = children;
            return JSCompiler_inline_result$jscomp$0;
          case "g":
          case "p":
          case "li":
            break;
          case "select":
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultSelectValue || (console.error(
              "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultSelectValue = true);
            target$jscomp$0.push(startChunkForTag("select"));
            var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
            for (propKey$jscomp$0 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$0)) {
                var propValue$jscomp$0 = props[propKey$jscomp$0];
                if (null != propValue$jscomp$0)
                  switch (propKey$jscomp$0) {
                    case "children":
                      children$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "defaultValue":
                    case "value":
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$0,
                        propValue$jscomp$0
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
            return children$jscomp$0;
          case "option":
            var selectedValue = formatContext.selectedValue;
            target$jscomp$0.push(startChunkForTag("option"));
            var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
            for (propKey$jscomp$1 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$1)) {
                var propValue$jscomp$1 = props[propKey$jscomp$1];
                if (null != propValue$jscomp$1)
                  switch (propKey$jscomp$1) {
                    case "children":
                      children$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "selected":
                      selected = propValue$jscomp$1;
                      didWarnSelectedSetOnOption || (console.error(
                        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
                      ), didWarnSelectedSetOnOption = true);
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "value":
                      value = propValue$jscomp$1;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$1,
                        propValue$jscomp$1
                      );
                  }
              }
            if (null != selectedValue) {
              if (null !== value) {
                checkAttributeStringCoercion(value, "value");
                var stringValue = "" + value;
              } else
                null === innerHTML$jscomp$1 || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = true, console.error(
                  "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
                )), stringValue = flattenOptionChildren(children$jscomp$1);
              if (isArrayImpl(selectedValue))
                for (var i = 0; i < selectedValue.length; i++) {
                  if (checkAttributeStringCoercion(selectedValue[i], "value"), "" + selectedValue[i] === stringValue) {
                    target$jscomp$0.push(selectedMarkerAttribute);
                    break;
                  }
                }
              else
                checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(selectedMarkerAttribute);
            } else selected && target$jscomp$0.push(selectedMarkerAttribute);
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
            return children$jscomp$1;
          case "textarea":
            checkControlledValueProps("textarea", props);
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultTextareaValue || (console.error(
              "Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultTextareaValue = true);
            target$jscomp$0.push(startChunkForTag("textarea"));
            var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
            for (propKey$jscomp$2 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$2)) {
                var propValue$jscomp$2 = props[propKey$jscomp$2];
                if (null != propValue$jscomp$2)
                  switch (propKey$jscomp$2) {
                    case "children":
                      children$jscomp$2 = propValue$jscomp$2;
                      break;
                    case "value":
                      value$jscomp$0 = propValue$jscomp$2;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$jscomp$2;
                      break;
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$2,
                        propValue$jscomp$2
                      );
                  }
              }
            null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
            target$jscomp$0.push(endOfStartTag);
            if (null != children$jscomp$2) {
              console.error(
                "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
              );
              if (null != value$jscomp$0)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children$jscomp$2)) {
                if (1 < children$jscomp$2.length)
                  throw Error("<textarea> can only have at most one child.");
                checkHtmlStringCoercion(children$jscomp$2[0]);
                value$jscomp$0 = "" + children$jscomp$2[0];
              }
              checkHtmlStringCoercion(children$jscomp$2);
              value$jscomp$0 = "" + children$jscomp$2;
            }
            "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);
            null !== value$jscomp$0 && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(
              stringToChunk(escapeTextForBrowser("" + value$jscomp$0))
            ));
            return null;
          case "input":
            checkControlledValueProps("input", props);
            target$jscomp$0.push(startChunkForTag("input"));
            var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
            for (propKey$jscomp$3 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$3)) {
                var propValue$jscomp$3 = props[propKey$jscomp$3];
                if (null != propValue$jscomp$3)
                  switch (propKey$jscomp$3) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    case "name":
                      name = propValue$jscomp$3;
                      break;
                    case "formAction":
                      formAction = propValue$jscomp$3;
                      break;
                    case "formEncType":
                      formEncType = propValue$jscomp$3;
                      break;
                    case "formMethod":
                      formMethod = propValue$jscomp$3;
                      break;
                    case "formTarget":
                      formTarget = propValue$jscomp$3;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$jscomp$3;
                      break;
                    case "defaultValue":
                      defaultValue$jscomp$0 = propValue$jscomp$3;
                      break;
                    case "checked":
                      checked = propValue$jscomp$3;
                      break;
                    case "value":
                      value$jscomp$1 = propValue$jscomp$3;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$3,
                        propValue$jscomp$3
                      );
                  }
              }
            null === formAction || "image" === props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'An input can only specify a formAction along with type="submit" or type="image".'
            ));
            var formData = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction,
              formEncType,
              formMethod,
              formTarget,
              name
            );
            null === checked || null === defaultChecked || didWarnDefaultChecked || (console.error(
              "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultChecked = true);
            null === value$jscomp$1 || null === defaultValue$jscomp$0 || didWarnDefaultInputValue || (console.error(
              "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultInputValue = true);
            null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
            null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
            target$jscomp$0.push(endOfStartTagSelfClosing);
            null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
            return null;
          case "button":
            target$jscomp$0.push(startChunkForTag("button"));
            var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
            for (propKey$jscomp$4 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$4)) {
                var propValue$jscomp$4 = props[propKey$jscomp$4];
                if (null != propValue$jscomp$4)
                  switch (propKey$jscomp$4) {
                    case "children":
                      children$jscomp$3 = propValue$jscomp$4;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$2 = propValue$jscomp$4;
                      break;
                    case "name":
                      name$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formAction":
                      formAction$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formEncType":
                      formEncType$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formMethod":
                      formMethod$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formTarget":
                      formTarget$jscomp$0 = propValue$jscomp$4;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$4,
                        propValue$jscomp$4
                      );
                  }
              }
            null === formAction$jscomp$0 || null == props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'A button can only specify a formAction along with type="submit" or no type.'
            ));
            var formData$jscomp$0 = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction$jscomp$0,
              formEncType$jscomp$0,
              formMethod$jscomp$0,
              formTarget$jscomp$0,
              name$jscomp$0
            );
            target$jscomp$0.push(endOfStartTag);
            null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
            if ("string" === typeof children$jscomp$3) {
              target$jscomp$0.push(
                stringToChunk(escapeTextForBrowser(children$jscomp$3))
              );
              var JSCompiler_inline_result$jscomp$1 = null;
            } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
            return JSCompiler_inline_result$jscomp$1;
          case "form":
            target$jscomp$0.push(startChunkForTag("form"));
            var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
            for (propKey$jscomp$5 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$5)) {
                var propValue$jscomp$5 = props[propKey$jscomp$5];
                if (null != propValue$jscomp$5)
                  switch (propKey$jscomp$5) {
                    case "children":
                      children$jscomp$4 = propValue$jscomp$5;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$3 = propValue$jscomp$5;
                      break;
                    case "action":
                      formAction$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "encType":
                      formEncType$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "method":
                      formMethod$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "target":
                      formTarget$jscomp$1 = propValue$jscomp$5;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$5,
                        propValue$jscomp$5
                      );
                  }
              }
            var formData$jscomp$1 = null, formActionName = null;
            if ("function" === typeof formAction$jscomp$1) {
              null === formEncType$jscomp$1 && null === formMethod$jscomp$1 || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              ));
              null === formTarget$jscomp$1 || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ));
              var customFields = getCustomFormFields(
                resumableState,
                formAction$jscomp$1
              );
              null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
                attributeSeparator,
                stringToChunk("action"),
                attributeAssign,
                actionJavaScriptURL,
                attributeEnd
              ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
            }
            null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
            null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
            null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
            null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
            target$jscomp$0.push(endOfStartTag);
            null !== formActionName && (target$jscomp$0.push(startHiddenInputChunk), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), null != formData$jscomp$1 && formData$jscomp$1.forEach(
              pushAdditionalFormField,
              target$jscomp$0
            ));
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
            if ("string" === typeof children$jscomp$4) {
              target$jscomp$0.push(
                stringToChunk(escapeTextForBrowser(children$jscomp$4))
              );
              var JSCompiler_inline_result$jscomp$2 = null;
            } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
            return JSCompiler_inline_result$jscomp$2;
          case "menuitem":
            target$jscomp$0.push(startChunkForTag("menuitem"));
            for (var propKey$jscomp$6 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$6)) {
                var propValue$jscomp$6 = props[propKey$jscomp$6];
                if (null != propValue$jscomp$6)
                  switch (propKey$jscomp$6) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "menuitems cannot have `children` nor `dangerouslySetInnerHTML`."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$6,
                        propValue$jscomp$6
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            return null;
          case "object":
            target$jscomp$0.push(startChunkForTag("object"));
            var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
            for (propKey$jscomp$7 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$7)) {
                var propValue$jscomp$7 = props[propKey$jscomp$7];
                if (null != propValue$jscomp$7)
                  switch (propKey$jscomp$7) {
                    case "children":
                      children$jscomp$5 = propValue$jscomp$7;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$4 = propValue$jscomp$7;
                      break;
                    case "data":
                      checkAttributeStringCoercion(propValue$jscomp$7, "data");
                      var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                      if ("" === sanitizedValue) {
                        console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          propKey$jscomp$7,
                          propKey$jscomp$7
                        );
                        break;
                      }
                      target$jscomp$0.push(
                        attributeSeparator,
                        stringToChunk("data"),
                        attributeAssign,
                        stringToChunk(escapeTextForBrowser(sanitizedValue)),
                        attributeEnd
                      );
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$7,
                        propValue$jscomp$7
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
            if ("string" === typeof children$jscomp$5) {
              target$jscomp$0.push(
                stringToChunk(escapeTextForBrowser(children$jscomp$5))
              );
              var JSCompiler_inline_result$jscomp$3 = null;
            } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
            return JSCompiler_inline_result$jscomp$3;
          case "title":
            var insertionMode = formatContext.insertionMode, noscriptTagInScope = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
              Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.",
                children$jscomp$6.length
              ) : "function" === typeof child || "symbol" === typeof child ? console.error(
                "React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.",
                "function" === typeof child ? "a Function" : "a Sybmol"
              ) : child && child.toString === {}.toString && (null != child.$$typeof ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML."
              ) : console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."
              ));
            }
            if (insertionMode === SVG_MODE || noscriptTagInScope || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(
                target$jscomp$0,
                props
              );
            else
              isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = void 0);
            return JSCompiler_inline_result$jscomp$4;
          case "link":
            var rel = props.rel, href = props.href, precedence = props.precedence;
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
              "stylesheet" === rel && "string" === typeof props.precedence && ("string" === typeof href && href || console.error(
                'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',
                null === href ? "`null`" : void 0 === href ? "`undefined`" : "" === href ? "an empty string" : 'something with type "' + typeof href + '"'
              ));
              pushLinkImpl(target$jscomp$0, props);
              var JSCompiler_inline_result$jscomp$5 = null;
            } else if ("stylesheet" === props.rel)
              if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) {
                if ("string" === typeof precedence) {
                  if (null != props.disabled)
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'
                    );
                  else if (props.onLoad || props.onError) {
                    var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                      propDescription,
                      propDescription
                    );
                  }
                }
                JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                  target$jscomp$0,
                  props
                );
              } else {
                var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(
                  href
                ) ? resumableState.styleResources[href] : void 0;
                if (resourceState !== EXISTS) {
                  resumableState.styleResources[href] = EXISTS;
                  styleQueue || (styleQueue = {
                    precedence: stringToChunk(escapeTextForBrowser(precedence)),
                    rules: [],
                    hrefs: [],
                    sheets: /* @__PURE__ */ new Map()
                  }, renderState.styles.set(precedence, styleQueue));
                  var resource = {
                    state: PENDING$1,
                    props: assign2({}, props, {
                      "data-precedence": props.precedence,
                      precedence: null
                    })
                  };
                  if (resourceState) {
                    2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                    var preloadResource = renderState.preloads.stylesheets.get(href);
                    preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
                  }
                  styleQueue.sheets.set(href, resource);
                  hoistableState && hoistableState.stylesheets.add(resource);
                } else if (styleQueue) {
                  var _resource = styleQueue.sheets.get(href);
                  _resource && hoistableState && hoistableState.stylesheets.add(_resource);
                }
                textEmbedded && target$jscomp$0.push(textSeparator);
                JSCompiler_inline_result$jscomp$5 = null;
              }
            else
              props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                target$jscomp$0,
                props
              ) : (textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$5 = isFallback ? null : pushLinkImpl(renderState.hoistableChunks, props));
            return JSCompiler_inline_result$jscomp$5;
          case "script":
            var asyncProp = props.async;
            if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(
                target$jscomp$0,
                props
              );
            else {
              var key = props.src;
              if ("module" === props.type) {
                var resources = resumableState.moduleScriptResources;
                var preloads = renderState.preloads.moduleScripts;
              } else
                resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
              var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
              if (resourceState$jscomp$0 !== EXISTS) {
                resources[key] = EXISTS;
                var scriptProps = props;
                if (resourceState$jscomp$0) {
                  2 === resourceState$jscomp$0.length && (scriptProps = assign2({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
                  var preloadResource$jscomp$0 = preloads.get(key);
                  preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
                }
                var resource$jscomp$0 = [];
                renderState.scripts.add(resource$jscomp$0);
                pushScriptImpl(resource$jscomp$0, scriptProps);
              }
              textEmbedded && target$jscomp$0.push(textSeparator);
              JSCompiler_inline_result$jscomp$6 = null;
            }
            return JSCompiler_inline_result$jscomp$6;
          case "style":
            var insertionMode$jscomp$0 = formatContext.insertionMode, noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
              ("function" === typeof child$jscomp$0 || "symbol" === typeof child$jscomp$0 || Array.isArray(child$jscomp$0)) && console.error(
                "React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.",
                "function" === typeof child$jscomp$0 ? "a Function" : "symbol" === typeof child$jscomp$0 ? "a Sybmol" : "an Array"
              );
            }
            var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href;
            if (insertionMode$jscomp$0 === SVG_MODE || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
              target$jscomp$0.push(startChunkForTag("style"));
              var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
              for (propKey$jscomp$8 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$8)) {
                  var propValue$jscomp$8 = props[propKey$jscomp$8];
                  if (null != propValue$jscomp$8)
                    switch (propKey$jscomp$8) {
                      case "children":
                        children$jscomp$8 = propValue$jscomp$8;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$5 = propValue$jscomp$8;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$8,
                          propValue$jscomp$8
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
              "function" !== typeof child$jscomp$1 && "symbol" !== typeof child$jscomp$1 && null !== child$jscomp$1 && void 0 !== child$jscomp$1 && target$jscomp$0.push(
                stringToChunk(escapeStyleTextContent(child$jscomp$1))
              );
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$5,
                children$jscomp$8
              );
              target$jscomp$0.push(endChunkForTag("style"));
              var JSCompiler_inline_result$jscomp$7 = null;
            } else {
              href$jscomp$0.includes(" ") && console.error(
                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".',
                href$jscomp$0
              );
              var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0;
              if (resourceState$jscomp$1 !== EXISTS) {
                resumableState.styleResources[href$jscomp$0] = EXISTS;
                resourceState$jscomp$1 && console.error(
                  'React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.',
                  href$jscomp$0
                );
                styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(
                  stringToChunk(escapeTextForBrowser(href$jscomp$0))
                ) : (styleQueue$jscomp$0 = {
                  precedence: stringToChunk(
                    escapeTextForBrowser(precedence$jscomp$0)
                  ),
                  rules: [],
                  hrefs: [stringToChunk(escapeTextForBrowser(href$jscomp$0))],
                  sheets: /* @__PURE__ */ new Map()
                }, renderState.styles.set(
                  precedence$jscomp$0,
                  styleQueue$jscomp$0
                ));
                var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
                for (propKey$jscomp$9 in props)
                  if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                    var propValue$jscomp$9 = props[propKey$jscomp$9];
                    if (null != propValue$jscomp$9)
                      switch (propKey$jscomp$9) {
                        case "children":
                          children$jscomp$9 = propValue$jscomp$9;
                          break;
                        case "dangerouslySetInnerHTML":
                          innerHTML$jscomp$6 = propValue$jscomp$9;
                      }
                  }
                var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
                "function" !== typeof child$jscomp$2 && "symbol" !== typeof child$jscomp$2 && null !== child$jscomp$2 && void 0 !== child$jscomp$2 && target.push(
                  stringToChunk(escapeStyleTextContent(child$jscomp$2))
                );
                pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);
              }
              styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
              textEmbedded && target$jscomp$0.push(textSeparator);
              JSCompiler_inline_result$jscomp$7 = void 0;
            }
            return JSCompiler_inline_result$jscomp$7;
          case "meta":
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(
                target$jscomp$0,
                props,
                "meta"
              );
            else
              textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$8 = isFallback ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(
                renderState.hoistableChunks,
                props,
                "meta"
              );
            return JSCompiler_inline_result$jscomp$8;
          case "listing":
          case "pre":
            target$jscomp$0.push(startChunkForTag(type2));
            var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
            for (propKey$jscomp$10 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$10)) {
                var propValue$jscomp$10 = props[propKey$jscomp$10];
                if (null != propValue$jscomp$10)
                  switch (propKey$jscomp$10) {
                    case "children":
                      children$jscomp$10 = propValue$jscomp$10;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$7 = propValue$jscomp$10;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$10,
                        propValue$jscomp$10
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            if (null != innerHTML$jscomp$7) {
              if (null != children$jscomp$10)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
                throw Error(
                  "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                );
              var html = innerHTML$jscomp$7.__html;
              null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline, stringToChunk(html)) : (checkHtmlStringCoercion(html), target$jscomp$0.push(stringToChunk("" + html))));
            }
            "string" === typeof children$jscomp$10 && "\n" === children$jscomp$10[0] && target$jscomp$0.push(leadingNewline);
            return children$jscomp$10;
          case "img":
            var src = props.src, srcSet = props.srcSet;
            if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet) && "low" !== props.fetchPriority && false === !!(formatContext.tagScope & 3) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
              var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
              if (resource$jscomp$1) {
                if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
                  promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
              } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
                resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
                var input = props.crossOrigin;
                var crossOrigin = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
                var headers = renderState.headers, header;
                headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
                  imageSrcSet: props.srcSet,
                  imageSizes: props.sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  nonce: props.nonce,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.refererPolicy
                }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
                  rel: "preload",
                  as: "image",
                  href: srcSet ? void 0 : src,
                  imageSrcSet: srcSet,
                  imageSizes: sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.referrerPolicy
                }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
              }
            }
            return pushSelfClosing(target$jscomp$0, props, "img");
          case "base":
          case "area":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "param":
          case "source":
          case "track":
          case "wbr":
            return pushSelfClosing(target$jscomp$0, props, type2);
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            break;
          case "head":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble = preambleState || renderState.preamble;
              if (preamble.headChunks)
                throw Error("The `<head>` tag may only be rendered once.");
              preamble.headChunks = [];
              var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
                preamble.headChunks,
                props,
                "head"
              );
            } else
              JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "head"
              );
            return JSCompiler_inline_result$jscomp$9;
          case "body":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble$jscomp$0 = preambleState || renderState.preamble;
              if (preamble$jscomp$0.bodyChunks)
                throw Error("The `<body>` tag may only be rendered once.");
              preamble$jscomp$0.bodyChunks = [];
              var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
                preamble$jscomp$0.bodyChunks,
                props,
                "body"
              );
            } else
              JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "body"
              );
            return JSCompiler_inline_result$jscomp$10;
          case "html":
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              var preamble$jscomp$1 = preambleState || renderState.preamble;
              if (preamble$jscomp$1.htmlChunks)
                throw Error("The `<html>` tag may only be rendered once.");
              preamble$jscomp$1.htmlChunks = [doctypeChunk];
              var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
                preamble$jscomp$1.htmlChunks,
                props,
                "html"
              );
            } else
              JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "html"
              );
            return JSCompiler_inline_result$jscomp$11;
          default:
            if (-1 !== type2.indexOf("-")) {
              target$jscomp$0.push(startChunkForTag(type2));
              var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
              for (propKey$jscomp$11 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$11)) {
                  var propValue$jscomp$11 = props[propKey$jscomp$11];
                  if (null != propValue$jscomp$11) {
                    var attributeName = propKey$jscomp$11;
                    switch (propKey$jscomp$11) {
                      case "children":
                        children$jscomp$11 = propValue$jscomp$11;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$8 = propValue$jscomp$11;
                        break;
                      case "style":
                        pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                        break;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "ref":
                        break;
                      case "className":
                        attributeName = "class";
                      default:
                        if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                          if (true === propValue$jscomp$11)
                            propValue$jscomp$11 = "";
                          else if ("object" === typeof propValue$jscomp$11)
                            continue;
                          target$jscomp$0.push(
                            attributeSeparator,
                            stringToChunk(attributeName),
                            attributeAssign,
                            stringToChunk(
                              escapeTextForBrowser(propValue$jscomp$11)
                            ),
                            attributeEnd
                          );
                        }
                    }
                  }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$8,
                children$jscomp$11
              );
              return children$jscomp$11;
            }
        }
        return pushStartGenericElement(target$jscomp$0, props, type2);
      }
      __name(pushStartInstance, "pushStartInstance");
      function endChunkForTag(tag) {
        var chunk3 = endTagCache.get(tag);
        void 0 === chunk3 && (chunk3 = stringToPrecomputedChunk("</" + tag + ">"), endTagCache.set(tag, chunk3));
        return chunk3;
      }
      __name(endChunkForTag, "endChunkForTag");
      function hoistPreambleState(renderState, preambleState) {
        renderState = renderState.preamble;
        null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);
        null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);
        null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);
      }
      __name(hoistPreambleState, "hoistPreambleState");
      function writeBootstrap(destination, renderState) {
        renderState = renderState.bootstrapChunks;
        for (var i = 0; i < renderState.length - 1; i++)
          writeChunk(destination, renderState[i]);
        return i < renderState.length ? (i = renderState[i], renderState.length = 0, writeChunkAndReturn(destination, i)) : true;
      }
      __name(writeBootstrap, "writeBootstrap");
      function writeStartPendingSuspenseBoundary(destination, renderState, id) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (null === id)
          throw Error(
            "An ID must have been assigned before we can complete the boundary."
          );
        writeChunk(destination, renderState.boundaryPrefix);
        writeChunk(destination, stringToChunk(id.toString(16)));
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      __name(writeStartPendingSuspenseBoundary, "writeStartPendingSuspenseBoundary");
      function writePreambleContribution(destination, preambleState) {
        preambleState = preambleState.contribution;
        preambleState !== NoContribution && (writeChunk(destination, boundaryPreambleContributionChunkStart), writeChunk(destination, stringToChunk("" + preambleState)), writeChunk(destination, boundaryPreambleContributionChunkEnd));
      }
      __name(writePreambleContribution, "writePreambleContribution");
      function writeStartSegment(destination, renderState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return writeChunk(destination, startSegmentHTML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentHTML2);
          case SVG_MODE:
            return writeChunk(destination, startSegmentSVG), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentSVG2);
          case MATHML_MODE:
            return writeChunk(destination, startSegmentMathML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentMathML2);
          case HTML_TABLE_MODE:
            return writeChunk(destination, startSegmentTable), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentTable2);
          case HTML_TABLE_BODY_MODE:
            return writeChunk(destination, startSegmentTableBody), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentTableBody2);
          case HTML_TABLE_ROW_MODE:
            return writeChunk(destination, startSegmentTableRow), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentTableRow2);
          case HTML_COLGROUP_MODE:
            return writeChunk(destination, startSegmentColGroup), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentColGroup2);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      __name(writeStartSegment, "writeStartSegment");
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return writeChunkAndReturn(destination, endSegmentHTML);
          case SVG_MODE:
            return writeChunkAndReturn(destination, endSegmentSVG);
          case MATHML_MODE:
            return writeChunkAndReturn(destination, endSegmentMathML);
          case HTML_TABLE_MODE:
            return writeChunkAndReturn(destination, endSegmentTable);
          case HTML_TABLE_BODY_MODE:
            return writeChunkAndReturn(destination, endSegmentTableBody);
          case HTML_TABLE_ROW_MODE:
            return writeChunkAndReturn(destination, endSegmentTableRow);
          case HTML_COLGROUP_MODE:
            return writeChunkAndReturn(destination, endSegmentColGroup);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      __name(writeEndSegment, "writeEndSegment");
      function escapeJSStringsForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInInstructionScripts,
          function(match) {
            switch (match) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      __name(escapeJSStringsForInstructionScripts, "escapeJSStringsForInstructionScripts");
      function escapeJSObjectForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInScripts,
          function(match) {
            switch (match) {
              case "&":
                return "\\u0026";
              case ">":
                return "\\u003e";
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      __name(escapeJSObjectForInstructionScripts, "escapeJSObjectForInstructionScripts");
      function flushStyleTagsLateForBoundary(styleQueue) {
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        0 < rules.length && 0 === hrefs.length && console.error(
          "React expected to have at least one href for an a hoistable style but found none. This is a bug in React."
        );
        var i = 0;
        if (hrefs.length) {
          writeChunk(this, lateStyleTagResourceOpen1);
          writeChunk(this, styleQueue.precedence);
          for (writeChunk(this, lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)
            writeChunk(this, hrefs[i]), writeChunk(this, spaceSeparator);
          writeChunk(this, hrefs[i]);
          writeChunk(this, lateStyleTagResourceOpen3);
          for (i = 0; i < rules.length; i++) writeChunk(this, rules[i]);
          destinationHasCapacity = writeChunkAndReturn(
            this,
            lateStyleTagTemplateClose
          );
          currentlyRenderingBoundaryHasStylesToHoist = true;
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      __name(flushStyleTagsLateForBoundary, "flushStyleTagsLateForBoundary");
      function hasStylesToHoist(stylesheet) {
        return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
      }
      __name(hasStylesToHoist, "hasStylesToHoist");
      function writeHoistablesForBoundary(destination, hoistableState, renderState) {
        currentlyRenderingBoundaryHasStylesToHoist = false;
        destinationHasCapacity = true;
        hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
        hoistableState.stylesheets.forEach(hasStylesToHoist);
        currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
        return destinationHasCapacity;
      }
      __name(writeHoistablesForBoundary, "writeHoistablesForBoundary");
      function flushResource(resource) {
        for (var i = 0; i < resource.length; i++) writeChunk(this, resource[i]);
        resource.length = 0;
      }
      __name(flushResource, "flushResource");
      function flushStyleInPreamble(stylesheet) {
        pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
        for (var i = 0; i < stylesheetFlushingQueue.length; i++)
          writeChunk(this, stylesheetFlushingQueue[i]);
        stylesheetFlushingQueue.length = 0;
        stylesheet.state = PREAMBLE;
      }
      __name(flushStyleInPreamble, "flushStyleInPreamble");
      function flushStylesInPreamble(styleQueue) {
        var hasStylesheets = 0 < styleQueue.sheets.size;
        styleQueue.sheets.forEach(flushStyleInPreamble, this);
        styleQueue.sheets.clear();
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        if (!hasStylesheets || hrefs.length) {
          writeChunk(this, styleTagResourceOpen1);
          writeChunk(this, styleQueue.precedence);
          styleQueue = 0;
          if (hrefs.length) {
            for (writeChunk(this, styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++)
              writeChunk(this, hrefs[styleQueue]), writeChunk(this, spaceSeparator);
            writeChunk(this, hrefs[styleQueue]);
          }
          writeChunk(this, styleTagResourceOpen3);
          for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
            writeChunk(this, rules[styleQueue]);
          writeChunk(this, styleTagResourceClose);
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      __name(flushStylesInPreamble, "flushStylesInPreamble");
      function preloadLateStyle(stylesheet) {
        if (stylesheet.state === PENDING$1) {
          stylesheet.state = PRELOADED;
          var props = stylesheet.props;
          pushLinkImpl(stylesheetFlushingQueue, {
            rel: "preload",
            as: "style",
            href: stylesheet.props.href,
            crossOrigin: props.crossOrigin,
            fetchPriority: props.fetchPriority,
            integrity: props.integrity,
            media: props.media,
            hrefLang: props.hrefLang,
            referrerPolicy: props.referrerPolicy
          });
          for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
            writeChunk(this, stylesheetFlushingQueue[stylesheet]);
          stylesheetFlushingQueue.length = 0;
        }
      }
      __name(preloadLateStyle, "preloadLateStyle");
      function preloadLateStyles(styleQueue) {
        styleQueue.sheets.forEach(preloadLateStyle, this);
        styleQueue.sheets.clear();
      }
      __name(preloadLateStyles, "preloadLateStyles");
      function writeStyleResourceDependenciesInJS(destination, hoistableState) {
        writeChunk(destination, arrayFirstOpenBracket);
        var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
        hoistableState.stylesheets.forEach(function(resource) {
          if (resource.state !== PREAMBLE)
            if (resource.state === LATE)
              writeChunk(destination, nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), writeChunk(
                destination,
                stringToChunk(
                  escapeJSObjectForInstructionScripts("" + resource)
                )
              ), writeChunk(destination, arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
            else {
              writeChunk(destination, nextArrayOpenBrackChunk);
              var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
              writeChunk(
                destination,
                stringToChunk(escapeJSObjectForInstructionScripts(coercedHref))
              );
              checkAttributeStringCoercion(precedence, "precedence");
              precedence = "" + precedence;
              writeChunk(destination, arrayInterstitial);
              writeChunk(
                destination,
                stringToChunk(escapeJSObjectForInstructionScripts(precedence))
              );
              for (var propKey in props)
                if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
                  switch (propKey) {
                    case "href":
                    case "rel":
                    case "precedence":
                    case "data-precedence":
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      writeStyleResourceAttributeInJS(
                        destination,
                        propKey,
                        precedence
                      );
                  }
              writeChunk(destination, arrayCloseBracket);
              nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
              resource.state = LATE;
            }
        });
        writeChunk(destination, arrayCloseBracket);
      }
      __name(writeStyleResourceDependenciesInJS, "writeStyleResourceDependenciesInJS");
      function writeStyleResourceAttributeInJS(destination, name, value) {
        var attributeName = name.toLowerCase();
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        switch (name) {
          case "innerHTML":
          case "dangerouslySetInnerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "style":
          case "ref":
            return;
          case "className":
            attributeName = "class";
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
            break;
          case "hidden":
            if (false === value) return;
            name = "";
            break;
          case "src":
          case "href":
            value = sanitizeURL(value);
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
            break;
          default:
            if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe(name))
              return;
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
        }
        writeChunk(destination, arrayInterstitial);
        writeChunk(
          destination,
          stringToChunk(escapeJSObjectForInstructionScripts(attributeName))
        );
        writeChunk(destination, arrayInterstitial);
        writeChunk(
          destination,
          stringToChunk(escapeJSObjectForInstructionScripts(name))
        );
      }
      __name(writeStyleResourceAttributeInJS, "writeStyleResourceAttributeInJS");
      function createHoistableState() {
        return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set() };
      }
      __name(createHoistableState, "createHoistableState");
      function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
        (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error(
          'Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue',
          href
        );
        resumableState.scriptResources[href] = EXISTS;
        resumableState.moduleScriptResources[href] = EXISTS;
        resumableState = [];
        pushLinkImpl(resumableState, props);
        renderState.bootstrapScripts.add(resumableState);
      }
      __name(preloadBootstrapScriptOrModule, "preloadBootstrapScriptOrModule");
      function adoptPreloadCredentials(target, preloadState) {
        null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
        null == target.integrity && (target.integrity = preloadState[1]);
      }
      __name(adoptPreloadCredentials, "adoptPreloadCredentials");
      function getPreloadAsHeader(href, as2, params) {
        href = escapeHrefForLinkHeaderURLContext(href);
        as2 = escapeStringForLinkHeaderQuotedParamValueContext(as2, "as");
        as2 = "<" + href + '>; rel=preload; as="' + as2 + '"';
        for (var paramName in params)
          hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as2 += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext(
            href,
            paramName
          ) + '"'));
        return as2;
      }
      __name(getPreloadAsHeader, "getPreloadAsHeader");
      function escapeHrefForLinkHeaderURLContext(hrefInput) {
        checkAttributeStringCoercion(hrefInput, "href");
        return ("" + hrefInput).replace(
          regexForHrefInLinkHeaderURLContext,
          escapeHrefForLinkHeaderURLContextReplacer
        );
      }
      __name(escapeHrefForLinkHeaderURLContext, "escapeHrefForLinkHeaderURLContext");
      function escapeHrefForLinkHeaderURLContextReplacer(match) {
        switch (match) {
          case "<":
            return "%3C";
          case ">":
            return "%3E";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      __name(escapeHrefForLinkHeaderURLContextReplacer, "escapeHrefForLinkHeaderURLContextReplacer");
      function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {
        willCoercionThrow(value) && (console.error(
          "The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.",
          name,
          typeName(value)
        ), testStringCoercion(value));
        return ("" + value).replace(
          regexForLinkHeaderQuotedParamValueContext,
          escapeStringForLinkHeaderQuotedParamValueContextReplacer
        );
      }
      __name(escapeStringForLinkHeaderQuotedParamValueContext, "escapeStringForLinkHeaderQuotedParamValueContext");
      function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
        switch (match) {
          case '"':
            return "%22";
          case "'":
            return "%27";
          case ";":
            return "%3B";
          case ",":
            return "%2C";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      __name(escapeStringForLinkHeaderQuotedParamValueContextReplacer, "escapeStringForLinkHeaderQuotedParamValueContextReplacer");
      function hoistStyleQueueDependency(styleQueue) {
        this.styles.add(styleQueue);
      }
      __name(hoistStyleQueueDependency, "hoistStyleQueueDependency");
      function hoistStylesheetDependency(stylesheet) {
        this.stylesheets.add(stylesheet);
      }
      __name(hoistStylesheetDependency, "hoistStylesheetDependency");
      function getComponentNameFromType(type2) {
        if (null == type2) return null;
        if ("function" === typeof type2)
          return type2.$$typeof === REACT_CLIENT_REFERENCE ? null : type2.displayName || type2.name || null;
        if ("string" === typeof type2) return type2;
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type2)
          switch ("number" === typeof type2.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type2.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type2.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type2._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type2.render;
              type2 = type2.displayName;
              type2 || (type2 = innerType.displayName || innerType.name || "", type2 = "" !== type2 ? "ForwardRef(" + type2 + ")" : "ForwardRef");
              return type2;
            case REACT_MEMO_TYPE:
              return innerType = type2.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type2._payload;
              type2 = type2._init;
              try {
                return getComponentNameFromType(type2(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      __name(getComponentNameFromType, "getComponentNameFromType");
      function popToNearestCommonAncestor(prev, next) {
        if (prev !== next) {
          prev.context._currentValue = prev.parentValue;
          prev = prev.parent;
          var parentNext = next.parent;
          if (null === prev) {
            if (null !== parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
          } else {
            if (null === parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
            popToNearestCommonAncestor(prev, parentNext);
          }
          next.context._currentValue = next.value;
        }
      }
      __name(popToNearestCommonAncestor, "popToNearestCommonAncestor");
      function popAllPrevious(prev) {
        prev.context._currentValue = prev.parentValue;
        prev = prev.parent;
        null !== prev && popAllPrevious(prev);
      }
      __name(popAllPrevious, "popAllPrevious");
      function pushAllNext(next) {
        var parentNext = next.parent;
        null !== parentNext && pushAllNext(parentNext);
        next.context._currentValue = next.value;
      }
      __name(pushAllNext, "pushAllNext");
      function popPreviousToCommonLevel(prev, next) {
        prev.context._currentValue = prev.parentValue;
        prev = prev.parent;
        if (null === prev)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
      }
      __name(popPreviousToCommonLevel, "popPreviousToCommonLevel");
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (null === parentNext)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
        next.context._currentValue = next.value;
      }
      __name(popNextToCommonLevel, "popNextToCommonLevel");
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
      }
      __name(switchContext, "switchContext");
      function warnOnInvalidCallback(callback) {
        if (null !== callback && "function" !== typeof callback) {
          var key = String(callback);
          didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ));
        }
      }
      __name(warnOnInvalidCallback, "warnOnInvalidCallback");
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType(publicInstance) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnAboutNoopUpdateForComponent[warningKey] || (console.error(
          "Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.",
          callerName,
          publicInstance
        ), didWarnAboutNoopUpdateForComponent[warningKey] = true);
      }
      __name(warnNoop, "warnNoop");
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        baseContext = baseContext.overflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          return {
            id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
            overflow: length + baseContext
          };
        }
        return {
          id: 1 << length | index << baseLength | baseIdWithLeadingBit,
          overflow: baseContext
        };
      }
      __name(pushTreeContext, "pushTreeContext");
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      __name(clz32Fallback, "clz32Fallback");
      function noop$2() {
      }
      __name(noop$2, "noop$2");
      function trackUsedThenable(thenableState2, thenable, index) {
        index = thenableState2[index];
        void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            "string" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            ));
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      __name(trackUsedThenable, "trackUsedThenable");
      function getSuspendedThenable() {
        if (null === suspendedThenable)
          throw Error(
            "Expected a suspended thenable. This is a bug in React. Please file an issue."
          );
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      __name(getSuspendedThenable, "getSuspendedThenable");
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      __name(is, "is");
      function resolveCurrentlyRenderingComponent() {
        if (null === currentlyRenderingComponent)
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        isInHookUserCodeInDev && console.error(
          "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
        );
        return currentlyRenderingComponent;
      }
      __name(resolveCurrentlyRenderingComponent, "resolveCurrentlyRenderingComponent");
      function createHook() {
        if (0 < numberOfReRenders)
          throw Error("Rendered more hooks than during the previous render");
        return { memoizedState: null, queue: null, next: null };
      }
      __name(createHook, "createHook");
      function createWorkInProgressHook() {
        null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
        return workInProgressHook;
      }
      __name(createWorkInProgressHook, "createWorkInProgressHook");
      function getThenableStateAfterSuspending() {
        var state2 = thenableState;
        thenableState = null;
        return state2;
      }
      __name(getThenableStateAfterSuspending, "getThenableStateAfterSuspending");
      function resetHooksState() {
        isInHookUserCodeInDev = false;
        currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        workInProgressHook = renderPhaseUpdates = null;
      }
      __name(resetHooksState, "resetHooksState");
      function readContext(context) {
        isInHookUserCodeInDev && console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
        return context._currentValue;
      }
      __name(readContext, "readContext");
      function basicStateReducer(state2, action) {
        return "function" === typeof action ? action(state2) : action;
      }
      __name(basicStateReducer, "basicStateReducer");
      function useReducer(reducer, initialArg, init2) {
        reducer !== basicStateReducer && (currentHookNameInDev = "useReducer");
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          init2 = workInProgressHook.queue;
          initialArg = init2.dispatch;
          if (null !== renderPhaseUpdates) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(init2);
            if (void 0 !== firstRenderPhaseUpdate) {
              renderPhaseUpdates.delete(init2);
              init2 = workInProgressHook.memoizedState;
              do {
                var action = firstRenderPhaseUpdate.action;
                isInHookUserCodeInDev = true;
                init2 = reducer(init2, action);
                isInHookUserCodeInDev = false;
                firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
              } while (null !== firstRenderPhaseUpdate);
              workInProgressHook.memoizedState = init2;
              return [init2, initialArg];
            }
          }
          return [workInProgressHook.memoizedState, initialArg];
        }
        isInHookUserCodeInDev = true;
        reducer = reducer === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init2 ? init2(initialArg) : initialArg;
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = reducer;
        reducer = workInProgressHook.queue = { last: null, dispatch: null };
        reducer = reducer.dispatch = dispatchAction.bind(
          null,
          currentlyRenderingComponent,
          reducer
        );
        return [workInProgressHook.memoizedState, reducer];
      }
      __name(useReducer, "useReducer");
      function useMemo2(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        if (null !== workInProgressHook) {
          var prevState = workInProgressHook.memoizedState;
          if (null !== prevState && null !== deps) {
            a: {
              var JSCompiler_inline_result = prevState[1];
              if (null === JSCompiler_inline_result)
                console.error(
                  "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
                  currentHookNameInDev
                ), JSCompiler_inline_result = false;
              else {
                deps.length !== JSCompiler_inline_result.length && console.error(
                  "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
                  currentHookNameInDev,
                  "[" + deps.join(", ") + "]",
                  "[" + JSCompiler_inline_result.join(", ") + "]"
                );
                for (var i = 0; i < JSCompiler_inline_result.length && i < deps.length; i++)
                  if (!objectIs(deps[i], JSCompiler_inline_result[i])) {
                    JSCompiler_inline_result = false;
                    break a;
                  }
                JSCompiler_inline_result = true;
              }
            }
            if (JSCompiler_inline_result) return prevState[0];
          }
        }
        isInHookUserCodeInDev = true;
        nextCreate = nextCreate();
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = [nextCreate, deps];
        return nextCreate;
      }
      __name(useMemo2, "useMemo");
      function dispatchAction(componentIdentity, queue, action) {
        if (25 <= numberOfReRenders)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (componentIdentity === currentlyRenderingComponent)
          if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
            renderPhaseUpdates.set(queue, componentIdentity);
          else {
            for (queue = action; null !== queue.next; ) queue = queue.next;
            queue.next = componentIdentity;
          }
      }
      __name(dispatchAction, "dispatchAction");
      function unsupportedStartTransition() {
        throw Error("startTransition cannot be called during server rendering.");
      }
      __name(unsupportedStartTransition, "unsupportedStartTransition");
      function unsupportedSetOptimisticState() {
        throw Error("Cannot update optimistic state while rendering.");
      }
      __name(unsupportedSetOptimisticState, "unsupportedSetOptimisticState");
      function useActionState(action, initialState, permalink) {
        resolveCurrentlyRenderingComponent();
        var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
        if ("function" === typeof action.$$FORM_ACTION) {
          var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
          request = request.formState;
          var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
          if (null !== request && "function" === typeof isSignatureEqual) {
            var postbackKey = request[1];
            isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
              JSON.stringify([
                componentKeyPath,
                null,
                actionStateHookIndex
              ]),
              0
            ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
          }
          var boundAction = action.bind(null, initialState);
          action = /* @__PURE__ */ __name(function(payload) {
            boundAction(payload);
          }, "action");
          "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix4) {
            prefix4 = boundAction.$$FORM_ACTION(prefix4);
            void 0 !== permalink && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix4.action = permalink);
            var formData = prefix4.data;
            formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
              JSON.stringify([
                componentKeyPath,
                null,
                actionStateHookIndex
              ]),
              0
            )), formData.append("$ACTION_KEY", nextPostbackStateKey));
            return prefix4;
          });
          return [initialState, action, false];
        }
        var _boundAction = action.bind(null, initialState);
        return [
          initialState,
          function(payload) {
            _boundAction(payload);
          },
          false
        ];
      }
      __name(useActionState, "useActionState");
      function unwrapThenable(thenable) {
        var index = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index);
      }
      __name(unwrapThenable, "unwrapThenable");
      function unsupportedRefresh() {
        throw Error("Cache cannot be refreshed during server rendering.");
      }
      __name(unsupportedRefresh, "unsupportedRefresh");
      function noop$1() {
      }
      __name(noop$1, "noop$1");
      function disabledLog() {
      }
      __name(disabledLog, "disabledLog");
      function disableLogs() {
        if (0 === disabledDepth) {
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd;
          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
      __name(disableLogs, "disableLogs");
      function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
          var props = { configurable: true, enumerable: true, writable: true };
          Object.defineProperties(console, {
            log: assign2({}, props, { value: prevLog }),
            info: assign2({}, props, { value: prevInfo }),
            warn: assign2({}, props, { value: prevWarn }),
            error: assign2({}, props, { value: prevError }),
            group: assign2({}, props, { value: prevGroup }),
            groupCollapsed: assign2({}, props, { value: prevGroupCollapsed }),
            groupEnd: assign2({}, props, { value: prevGroupEnd })
          });
        }
        0 > disabledDepth && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      __name(reenableLogs, "reenableLogs");
      function prepareStackTrace(error, structuredStackTrace) {
        error = (error.name || "Error") + ": " + (error.message || "");
        for (var i = 0; i < structuredStackTrace.length; i++)
          error += "\n    at " + structuredStackTrace[i].toString();
        return error;
      }
      __name(prepareStackTrace, "prepareStackTrace");
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix3)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix3 = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix3 + name + suffix;
      }
      __name(describeBuiltInComponentFrame, "describeBuiltInComponentFrame");
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = true;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = prepareStackTrace;
        var previousDispatcher2 = null;
        previousDispatcher2 = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: /* @__PURE__ */ __name(function() {
              try {
                if (construct) {
                  var Fake = /* @__PURE__ */ __name(function() {
                    throw Error();
                  }, "Fake");
                  Object.defineProperty(Fake.prototype, "props", {
                    set: /* @__PURE__ */ __name(function() {
                      throw Error();
                    }, "set")
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$0) {
                      control = x$0;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$1) {
                    control = x$1;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }, "DetermineComponentFrameRoot")
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            ); )
              _RunInRootFrame$Deter++;
            if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
              for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                _RunInRootFrame$Deter--;
            for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
              if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                  do
                    if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                      var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                      fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                      "function" === typeof fn && componentFrameCache.set(fn, _frame);
                      return _frame;
                    }
                  while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                }
                break;
              }
          }
        } finally {
          reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
      }
      __name(describeNativeComponentFrame, "describeNativeComponentFrame");
      function formatOwnerStack(error) {
        var prevPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = prepareStackTrace;
        error = error.stack;
        Error.prepareStackTrace = prevPrepareStackTrace;
        error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
        prevPrepareStackTrace = error.indexOf("\n");
        -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
        prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
        -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
          "\n",
          prevPrepareStackTrace
        ));
        if (-1 !== prevPrepareStackTrace)
          error = error.slice(0, prevPrepareStackTrace);
        else return "";
        return error;
      }
      __name(formatOwnerStack, "formatOwnerStack");
      function describeComponentStackByType(type2) {
        if ("string" === typeof type2) return describeBuiltInComponentFrame(type2);
        if ("function" === typeof type2)
          return type2.prototype && type2.prototype.isReactComponent ? describeNativeComponentFrame(type2, true) : describeNativeComponentFrame(type2, false);
        if ("object" === typeof type2 && null !== type2) {
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeNativeComponentFrame(type2.render, false);
            case REACT_MEMO_TYPE:
              return describeNativeComponentFrame(type2.type, false);
            case REACT_LAZY_TYPE:
              var lazyComponent = type2, payload = lazyComponent._payload;
              lazyComponent = lazyComponent._init;
              try {
                type2 = lazyComponent(payload);
              } catch (x) {
                return describeBuiltInComponentFrame("Lazy");
              }
              return describeComponentStackByType(type2);
          }
          if ("string" === typeof type2.name)
            return payload = type2.env, describeBuiltInComponentFrame(
              type2.name + (payload ? " [" + payload + "]" : "")
            );
        }
        switch (type2) {
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
        }
        return "";
      }
      __name(describeComponentStackByType, "describeComponentStackByType");
      function defaultErrorHandler(error) {
        if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
          var JSCompiler_inline_result = error.environmentName;
          error = [error].slice(0);
          "string" === typeof error[0] ? error.splice(
            0,
            1,
            "\x1B[0m\x1B[7m%c%s\x1B[0m%c " + error[0],
            "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
            " " + JSCompiler_inline_result + " ",
            ""
          ) : error.splice(
            0,
            0,
            "\x1B[0m\x1B[7m%c%s\x1B[0m%c ",
            "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
            " " + JSCompiler_inline_result + " ",
            ""
          );
          error.unshift(console);
          JSCompiler_inline_result = bind2.apply(console.error, error);
          JSCompiler_inline_result();
        } else console.error(error);
        return null;
      }
      __name(defaultErrorHandler, "defaultErrorHandler");
      function noop2() {
      }
      __name(noop2, "noop");
      function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var abortSet = /* @__PURE__ */ new Set();
        this.destination = null;
        this.flushScheduled = false;
        this.resumableState = resumableState;
        this.renderState = renderState;
        this.rootFormatContext = rootFormatContext;
        this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
        this.status = 10;
        this.fatalError = null;
        this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
        this.completedPreambleSegments = this.completedRootSegment = null;
        this.abortableTasks = abortSet;
        this.pingedTasks = [];
        this.clientRenderedBoundaries = [];
        this.completedBoundaries = [];
        this.partialBoundaries = [];
        this.trackedPostpones = null;
        this.onError = void 0 === onError ? defaultErrorHandler : onError;
        this.onPostpone = void 0 === onPostpone ? noop2 : onPostpone;
        this.onAllReady = void 0 === onAllReady ? noop2 : onAllReady;
        this.onShellReady = void 0 === onShellReady ? noop2 : onShellReady;
        this.onShellError = void 0 === onShellError ? noop2 : onShellError;
        this.onFatalError = void 0 === onFatalError ? noop2 : onFatalError;
        this.formState = void 0 === formState ? null : formState;
        this.didWarnForKey = null;
      }
      __name(RequestInstance, "RequestInstance");
      function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var now = getCurrentTime();
        1e3 < now - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = now);
        resumableState = new RequestInstance(
          resumableState,
          renderState,
          rootFormatContext,
          progressiveChunkSize,
          onError,
          onAllReady,
          onShellReady,
          onShellError,
          onFatalError,
          onPostpone,
          formState
        );
        renderState = createPendingSegment(
          resumableState,
          0,
          null,
          rootFormatContext,
          false,
          false
        );
        renderState.parentFlushed = true;
        children = createRenderTask(
          resumableState,
          null,
          children,
          -1,
          null,
          renderState,
          null,
          null,
          resumableState.abortableTasks,
          null,
          rootFormatContext,
          null,
          emptyTreeContext,
          null,
          false,
          emptyContextObject,
          null
        );
        pushComponentStack(children);
        resumableState.pingedTasks.push(children);
        return resumableState;
      }
      __name(createRequest, "createRequest");
      function createPrerenderRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
        children = createRequest(
          children,
          resumableState,
          renderState,
          rootFormatContext,
          progressiveChunkSize,
          onError,
          onAllReady,
          onShellReady,
          onShellError,
          onFatalError,
          onPostpone,
          void 0
        );
        children.trackedPostpones = {
          workingMap: /* @__PURE__ */ new Map(),
          rootNodes: [],
          rootSlots: null
        };
        return children;
      }
      __name(createPrerenderRequest, "createPrerenderRequest");
      function resolveRequest() {
        if (currentRequest) return currentRequest;
        if (supportsRequestStorage) {
          var store = requestStorage.getStore();
          if (store) return store;
        }
        return null;
      }
      __name(resolveRequest, "resolveRequest");
      function pingTask(request, task) {
        request.pingedTasks.push(task);
        1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, null !== request.trackedPostpones || 10 === request.status ? scheduleMicrotask(function() {
          return performWork(request);
        }) : setTimeout(function() {
          return performWork(request);
        }, 0));
      }
      __name(pingTask, "pingTask");
      function createSuspenseBoundary(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
        return {
          status: PENDING,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null,
          contentState: createHoistableState(),
          fallbackState: createHoistableState(),
          contentPreamble,
          fallbackPreamble,
          trackedContentKeyPath: null,
          trackedFallbackNode: null,
          errorMessage: null,
          errorStack: null,
          errorComponentStack: null
        };
      }
      __name(createSuspenseBoundary, "createSuspenseBoundary");
      function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        var task = {
          replay: null,
          node,
          childIndex,
          ping: /* @__PURE__ */ __name(function() {
            return pingTask(request, task);
          }, "ping"),
          blockedBoundary,
          blockedSegment,
          blockedPreamble,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      __name(createRenderTask, "createRenderTask");
      function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        replay.pendingTasks++;
        var task = {
          replay,
          node,
          childIndex,
          ping: /* @__PURE__ */ __name(function() {
            return pingTask(request, task);
          }, "ping"),
          blockedBoundary,
          blockedSegment: null,
          blockedPreamble: null,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      __name(createReplayTask, "createReplayTask");
      function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          parentFlushed: false,
          id: -1,
          index,
          chunks: [],
          children: [],
          preambleChildren: [],
          parentFormatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      __name(createPendingSegment, "createPendingSegment");
      function getCurrentStackInDEV() {
        if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
          return "";
        var componentStack = currentTaskInDEV.componentStack;
        try {
          var info = "";
          if ("string" === typeof componentStack.type)
            info += describeBuiltInComponentFrame(componentStack.type);
          else if ("function" === typeof componentStack.type) {
            if (!componentStack.owner) {
              var JSCompiler_temp_const = info, fn = componentStack.type, name = fn ? fn.displayName || fn.name : "";
              var JSCompiler_inline_result = name ? describeBuiltInComponentFrame(name) : "";
              info = JSCompiler_temp_const + JSCompiler_inline_result;
            }
          } else
            componentStack.owner || (info += describeComponentStackByType(componentStack.type));
          for (; componentStack; )
            JSCompiler_temp_const = null, null != componentStack.debugStack ? JSCompiler_temp_const = formatOwnerStack(
              componentStack.debugStack
            ) : (JSCompiler_inline_result = componentStack, null != JSCompiler_inline_result.stack && (JSCompiler_temp_const = "string" !== typeof JSCompiler_inline_result.stack ? JSCompiler_inline_result.stack = formatOwnerStack(
              JSCompiler_inline_result.stack
            ) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += "\n" + JSCompiler_temp_const);
          var JSCompiler_inline_result$jscomp$0 = info;
        } catch (x) {
          JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x.message + "\n" + x.stack;
        }
        return JSCompiler_inline_result$jscomp$0;
      }
      __name(getCurrentStackInDEV, "getCurrentStackInDEV");
      function pushServerComponentStack(task, debugInfo) {
        if (null != debugInfo)
          for (var i = 0; i < debugInfo.length; i++) {
            var componentInfo = debugInfo[i];
            "string" === typeof componentInfo.name && void 0 !== componentInfo.debugStack && (task.componentStack = {
              parent: task.componentStack,
              type: componentInfo,
              owner: componentInfo.owner,
              stack: componentInfo.debugStack
            }, task.debugTask = componentInfo.debugTask);
          }
      }
      __name(pushServerComponentStack, "pushServerComponentStack");
      function pushComponentStack(task) {
        var node = task.node;
        if ("object" === typeof node && null !== node)
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var type2 = node.type, owner = node._owner, stack = node._debugStack;
              pushServerComponentStack(task, node._debugInfo);
              task.debugTask = node._debugTask;
              task.componentStack = {
                parent: task.componentStack,
                type: type2,
                owner,
                stack
              };
              break;
            case REACT_LAZY_TYPE:
              pushServerComponentStack(task, node._debugInfo);
              break;
            default:
              "function" === typeof node.then && pushServerComponentStack(task, node._debugInfo);
          }
      }
      __name(pushComponentStack, "pushComponentStack");
      function getThrownInfo(node$jscomp$0) {
        var errorInfo = {};
        node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
          configurable: true,
          enumerable: true,
          get: /* @__PURE__ */ __name(function() {
            try {
              var info = "", node = node$jscomp$0;
              do
                info += describeComponentStackByType(node.type), node = node.parent;
              while (node);
              var stack = info;
            } catch (x) {
              stack = "\nError generating stack: " + x.message + "\n" + x.stack;
            }
            Object.defineProperty(errorInfo, "componentStack", {
              value: stack
            });
            return stack;
          }, "get")
        });
        return errorInfo;
      }
      __name(getThrownInfo, "getThrownInfo");
      function encodeErrorForBoundary(boundary, digest, error, thrownInfo, wasAborted) {
        boundary.errorDigest = digest;
        error instanceof Error ? (digest = String(error.message), error = String(error.stack)) : (digest = "object" === typeof error && null !== error ? describeObjectForErrorMessage(error) : String(error), error = null);
        wasAborted = wasAborted ? "Switched to client rendering because the server rendering aborted due to:\n\n" : "Switched to client rendering because the server rendering errored:\n\n";
        boundary.errorMessage = wasAborted + digest;
        boundary.errorStack = null !== error ? wasAborted + error : null;
        boundary.errorComponentStack = thrownInfo.componentStack;
      }
      __name(encodeErrorForBoundary, "encodeErrorForBoundary");
      function logRecoverableError(request, error, errorInfo, debugTask) {
        request = request.onError;
        error = debugTask ? debugTask.run(request.bind(null, error, errorInfo)) : request(error, errorInfo);
        if (null != error && "string" !== typeof error)
          console.error(
            'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
            typeof error
          );
        else return error;
      }
      __name(logRecoverableError, "logRecoverableError");
      function fatalError(request, error, errorInfo, debugTask) {
        errorInfo = request.onShellError;
        var onFatalError = request.onFatalError;
        debugTask ? (debugTask.run(errorInfo.bind(null, error)), debugTask.run(onFatalError.bind(null, error))) : (errorInfo(error), onFatalError(error));
        null !== request.destination ? (request.status = CLOSED, closeWithError(request.destination, error)) : (request.status = 13, request.fatalError = error);
      }
      __name(fatalError, "fatalError");
      function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
        var prevThenableState = task.thenableState;
        task.thenableState = null;
        currentlyRenderingComponent = {};
        currentlyRenderingTask = task;
        currentlyRenderingRequest = request;
        currentlyRenderingKeyPath = keyPath;
        isInHookUserCodeInDev = false;
        actionStateCounter = localIdCounter = 0;
        actionStateMatchingIndex = -1;
        thenableIndexCounter = 0;
        thenableState = prevThenableState;
        for (request = callComponentInDEV(Component, props, secondArg); didScheduleRenderPhaseUpdate; )
          didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
        resetHooksState();
        return request;
      }
      __name(renderWithHooks, "renderWithHooks");
      function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
        var didEmitActionStateMarkers = false;
        if (0 !== actionStateCount && null !== request.formState) {
          var segment = task.blockedSegment;
          if (null !== segment) {
            didEmitActionStateMarkers = true;
            segment = segment.chunks;
            for (var i = 0; i < actionStateCount; i++)
              i === actionStateMatchingIndex2 ? segment.push(formStateMarkerIsMatching) : segment.push(formStateMarkerIsNotMatching);
          }
        }
        actionStateCount = task.keyPath;
        task.keyPath = keyPath;
        hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
        task.keyPath = actionStateCount;
      }
      __name(finishFunctionComponent, "finishFunctionComponent");
      function renderElement(request, task, keyPath, type2, props, ref) {
        if ("function" === typeof type2)
          if (type2.prototype && type2.prototype.isReactComponent) {
            var newProps = props;
            if ("ref" in props) {
              newProps = {};
              for (var propName in props)
                "ref" !== propName && (newProps[propName] = props[propName]);
            }
            var defaultProps = type2.defaultProps;
            if (defaultProps) {
              newProps === props && (newProps = assign2({}, newProps, props));
              for (var _propName in defaultProps)
                void 0 === newProps[_propName] && (newProps[_propName] = defaultProps[_propName]);
            }
            var resolvedProps = newProps;
            var context = emptyContextObject, contextType = type2.contextType;
            if ("contextType" in type2 && null !== contextType && (void 0 === contextType || contextType.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(type2)) {
              didWarnAboutInvalidateContextType.add(type2);
              var addendum = void 0 === contextType ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof contextType ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              console.error(
                "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
                getComponentNameFromType(type2) || "Component",
                addendum
              );
            }
            "object" === typeof contextType && null !== contextType && (context = contextType._currentValue);
            var instance = new type2(resolvedProps, context);
            if ("function" === typeof type2.getDerivedStateFromProps && (null === instance.state || void 0 === instance.state)) {
              var componentName = getComponentNameFromType(type2) || "Component";
              didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error(
                "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
                componentName,
                null === instance.state ? "null" : "undefined",
                componentName
              ));
            }
            if ("function" === typeof type2.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) {
              var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
              "function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning ? foundWillMountName = "componentWillMount" : "function" === typeof instance.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount");
              "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" === typeof instance.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
              "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
                var _componentName = getComponentNameFromType(type2) || "Component", newApiName = "function" === typeof type2.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(
                  _componentName
                ), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _componentName,
                  newApiName,
                  null !== foundWillMountName ? "\n  " + foundWillMountName : "",
                  null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            var name = getComponentNameFromType(type2) || "Component";
            instance.render || (type2.prototype && "function" === typeof type2.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              name
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              name
            ));
            !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              name
            );
            instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              name
            );
            instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              name
            );
            type2.childContextTypes && !didWarnAboutChildContextTypes.has(type2) && (didWarnAboutChildContextTypes.add(type2), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              name
            ));
            type2.contextTypes && !didWarnAboutContextTypes$1.has(type2) && (didWarnAboutContextTypes$1.add(type2), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              name
            ));
            "function" === typeof instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              name
            );
            type2.prototype && type2.prototype.isPureReactComponent && "undefined" !== typeof instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(type2) || "A pure component"
            );
            "function" === typeof instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              name
            );
            "function" === typeof instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              name
            );
            "function" === typeof instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              name
            );
            "function" === typeof instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              name
            );
            var hasMutatedProps = instance.props !== resolvedProps;
            void 0 !== instance.props && hasMutatedProps && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              name
            );
            instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              name,
              name
            );
            "function" !== typeof instance.getSnapshotBeforeUpdate || "function" === typeof instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type2) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type2), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(type2)
            ));
            "function" === typeof instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name
            );
            "function" === typeof instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name
            );
            "function" === typeof type2.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              name
            );
            var state2 = instance.state;
            state2 && ("object" !== typeof state2 || isArrayImpl(state2)) && console.error("%s.state: must be set to an object or null", name);
            "function" === typeof instance.getChildContext && "object" !== typeof type2.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              name
            );
            var initialState = void 0 !== instance.state ? instance.state : null;
            instance.updater = classComponentUpdater;
            instance.props = resolvedProps;
            instance.state = initialState;
            var internalInstance = { queue: [], replace: false };
            instance._reactInternals = internalInstance;
            var contextType$jscomp$0 = type2.contextType;
            instance.context = "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 ? contextType$jscomp$0._currentValue : emptyContextObject;
            if (instance.state === resolvedProps) {
              var componentName$jscomp$0 = getComponentNameFromType(type2) || "Component";
              didWarnAboutDirectlyAssigningPropsToState.has(
                componentName$jscomp$0
              ) || (didWarnAboutDirectlyAssigningPropsToState.add(
                componentName$jscomp$0
              ), console.error(
                "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                componentName$jscomp$0
              ));
            }
            var getDerivedStateFromProps = type2.getDerivedStateFromProps;
            if ("function" === typeof getDerivedStateFromProps) {
              var partialState = getDerivedStateFromProps(
                resolvedProps,
                initialState
              );
              if (void 0 === partialState) {
                var componentName$jscomp$1 = getComponentNameFromType(type2) || "Component";
                didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error(
                  "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
                  componentName$jscomp$1
                ));
              }
              var JSCompiler_inline_result = null === partialState || void 0 === partialState ? initialState : assign2({}, initialState, partialState);
              instance.state = JSCompiler_inline_result;
            }
            if ("function" !== typeof type2.getDerivedStateFromProps && "function" !== typeof instance.getSnapshotBeforeUpdate && ("function" === typeof instance.UNSAFE_componentWillMount || "function" === typeof instance.componentWillMount)) {
              var oldState = instance.state;
              if ("function" === typeof instance.componentWillMount) {
                if (true !== instance.componentWillMount.__suppressDeprecationWarning) {
                  var componentName$jscomp$2 = getComponentNameFromType(type2) || "Unknown";
                  didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn(
                    "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName$jscomp$2
                  ), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = true);
                }
                instance.componentWillMount();
              }
              "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount();
              oldState !== instance.state && (console.error(
                "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
                getComponentNameFromType(type2) || "Component"
              ), classComponentUpdater.enqueueReplaceState(
                instance,
                instance.state,
                null
              ));
              if (null !== internalInstance.queue && 0 < internalInstance.queue.length) {
                var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
                internalInstance.queue = null;
                internalInstance.replace = false;
                if (oldReplace && 1 === oldQueue.length)
                  instance.state = oldQueue[0];
                else {
                  for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                    var partial = oldQueue[i], partialState$jscomp$0 = "function" === typeof partial ? partial.call(
                      instance,
                      nextState,
                      resolvedProps,
                      void 0
                    ) : partial;
                    null != partialState$jscomp$0 && (dontMutate ? (dontMutate = false, nextState = assign2(
                      {},
                      nextState,
                      partialState$jscomp$0
                    )) : assign2(nextState, partialState$jscomp$0));
                  }
                  instance.state = nextState;
                }
              } else internalInstance.queue = null;
            }
            var nextChildren = callRenderInDEV(instance);
            if (12 === request.status) throw null;
            instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error(
              "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
              getComponentNameFromType(type2) || "a component"
            ), didWarnAboutReassigningProps = true);
            var prevKeyPath = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, nextChildren, -1);
            task.keyPath = prevKeyPath;
          } else {
            if (type2.prototype && "function" === typeof type2.prototype.render) {
              var componentName$jscomp$3 = getComponentNameFromType(type2) || "Unknown";
              didWarnAboutBadClass[componentName$jscomp$3] || (console.error(
                "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                componentName$jscomp$3,
                componentName$jscomp$3
              ), didWarnAboutBadClass[componentName$jscomp$3] = true);
            }
            var value = renderWithHooks(
              request,
              task,
              keyPath,
              type2,
              props,
              void 0
            );
            if (12 === request.status) throw null;
            var hasId = 0 !== localIdCounter, actionStateCount = actionStateCounter, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;
            if (type2.contextTypes) {
              var _componentName$jscomp$0 = getComponentNameFromType(type2) || "Unknown";
              didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = true, console.error(
                "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
                _componentName$jscomp$0
              ));
            }
            type2 && type2.childContextTypes && console.error(
              "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
              type2.displayName || type2.name || "Component"
            );
            if ("function" === typeof type2.getDerivedStateFromProps) {
              var _componentName2 = getComponentNameFromType(type2) || "Unknown";
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] || (console.error(
                "%s: Function components do not support getDerivedStateFromProps.",
                _componentName2
              ), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true);
            }
            if ("object" === typeof type2.contextType && null !== type2.contextType) {
              var _componentName3 = getComponentNameFromType(type2) || "Unknown";
              didWarnAboutContextTypeOnFunctionComponent[_componentName3] || (console.error(
                "%s: Function components do not support contextType.",
                _componentName3
              ), didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true);
            }
            finishFunctionComponent(
              request,
              task,
              keyPath,
              value,
              hasId,
              actionStateCount,
              actionStateMatchingIndex$jscomp$0
            );
          }
        else if ("string" === typeof type2) {
          var segment = task.blockedSegment;
          if (null === segment) {
            var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
            task.formatContext = getChildFormatContext(prevContext, type2, props);
            task.keyPath = keyPath;
            renderNode(request, task, children, -1);
            task.formatContext = prevContext;
            task.keyPath = prevKeyPath$jscomp$0;
          } else {
            var _children = pushStartInstance(
              segment.chunks,
              type2,
              props,
              request.resumableState,
              request.renderState,
              task.blockedPreamble,
              task.hoistableState,
              task.formatContext,
              segment.lastPushedText,
              task.isFallback
            );
            segment.lastPushedText = false;
            var _prevContext = task.formatContext, _prevKeyPath2 = task.keyPath;
            task.keyPath = keyPath;
            if ((task.formatContext = getChildFormatContext(
              _prevContext,
              type2,
              props
            )).insertionMode === HTML_HEAD_MODE) {
              var preambleSegment = createPendingSegment(
                request,
                0,
                null,
                task.formatContext,
                false,
                false
              );
              segment.preambleChildren.push(preambleSegment);
              var preambleTask = createRenderTask(
                request,
                null,
                _children,
                -1,
                task.blockedBoundary,
                preambleSegment,
                task.blockedPreamble,
                task.hoistableState,
                request.abortableTasks,
                task.keyPath,
                task.formatContext,
                task.context,
                task.treeContext,
                task.componentStack,
                task.isFallback,
                emptyContextObject,
                task.debugTask
              );
              pushComponentStack(preambleTask);
              request.pingedTasks.push(preambleTask);
            } else renderNode(request, task, _children, -1);
            task.formatContext = _prevContext;
            task.keyPath = _prevKeyPath2;
            a: {
              var target = segment.chunks, resumableState = request.resumableState;
              switch (type2) {
                case "title":
                case "style":
                case "script":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "img":
                case "input":
                case "keygen":
                case "link":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                  break a;
                case "body":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE) {
                    resumableState.hasBody = true;
                    break a;
                  }
                  break;
                case "html":
                  if (_prevContext.insertionMode === ROOT_HTML_MODE) {
                    resumableState.hasHtml = true;
                    break a;
                  }
                  break;
                case "head":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;
              }
              target.push(endChunkForTag(type2));
            }
            segment.lastPushedText = false;
          }
        } else {
          switch (type2) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE:
              var prevKeyPath$jscomp$1 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = prevKeyPath$jscomp$1;
              return;
            case REACT_ACTIVITY_TYPE:
              if ("hidden" !== props.mode) {
                var prevKeyPath$jscomp$2 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, props.children, -1);
                task.keyPath = prevKeyPath$jscomp$2;
              }
              return;
            case REACT_SUSPENSE_LIST_TYPE:
              var _prevKeyPath3 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = _prevKeyPath3;
              return;
            case REACT_VIEW_TRANSITION_TYPE:
            case REACT_SCOPE_TYPE:
              throw Error(
                "ReactDOMServer does not yet support scope components."
              );
            case REACT_SUSPENSE_TYPE:
              a: if (null !== task.replay) {
                var _prevKeyPath = task.keyPath;
                task.keyPath = keyPath;
                var _content = props.children;
                try {
                  renderNode(request, task, _content, -1);
                } finally {
                  task.keyPath = _prevKeyPath;
                }
              } else {
                var prevKeyPath$jscomp$3 = task.keyPath, parentBoundary = task.blockedBoundary, parentPreamble = task.blockedPreamble, parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set();
                var newBoundary = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  createPreambleState(),
                  createPreambleState()
                ) : createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  null,
                  null
                );
                null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
                var boundarySegment = createPendingSegment(
                  request,
                  parentSegment.chunks.length,
                  newBoundary,
                  task.formatContext,
                  false,
                  false
                );
                parentSegment.children.push(boundarySegment);
                parentSegment.lastPushedText = false;
                var contentRootSegment = createPendingSegment(
                  request,
                  0,
                  null,
                  task.formatContext,
                  false,
                  false
                );
                contentRootSegment.parentFlushed = true;
                if (null !== request.trackedPostpones) {
                  var fallbackKeyPath = [
                    keyPath[0],
                    "Suspense Fallback",
                    keyPath[2]
                  ], fallbackReplayNode = [
                    fallbackKeyPath[1],
                    fallbackKeyPath[2],
                    [],
                    null
                  ];
                  request.trackedPostpones.workingMap.set(
                    fallbackKeyPath,
                    fallbackReplayNode
                  );
                  newBoundary.trackedFallbackNode = fallbackReplayNode;
                  task.blockedSegment = boundarySegment;
                  task.blockedPreamble = newBoundary.fallbackPreamble;
                  task.keyPath = fallbackKeyPath;
                  boundarySegment.status = 6;
                  try {
                    renderNode(request, task, fallback, -1), boundarySegment.lastPushedText && boundarySegment.textEmbedded && boundarySegment.chunks.push(textSeparator), boundarySegment.status = COMPLETED;
                  } catch (thrownValue) {
                    throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
                  } finally {
                    task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$3;
                  }
                  var suspendedPrimaryTask = createRenderTask(
                    request,
                    null,
                    content,
                    -1,
                    newBoundary,
                    contentRootSegment,
                    newBoundary.contentPreamble,
                    newBoundary.contentState,
                    task.abortSet,
                    keyPath,
                    task.formatContext,
                    task.context,
                    task.treeContext,
                    task.componentStack,
                    task.isFallback,
                    emptyContextObject,
                    task.debugTask
                  );
                  pushComponentStack(suspendedPrimaryTask);
                  request.pingedTasks.push(suspendedPrimaryTask);
                } else {
                  task.blockedBoundary = newBoundary;
                  task.blockedPreamble = newBoundary.contentPreamble;
                  task.hoistableState = newBoundary.contentState;
                  task.blockedSegment = contentRootSegment;
                  task.keyPath = keyPath;
                  contentRootSegment.status = 6;
                  try {
                    if (renderNode(request, task, content, -1), contentRootSegment.lastPushedText && contentRootSegment.textEmbedded && contentRootSegment.chunks.push(textSeparator), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && newBoundary.status === PENDING) {
                      newBoundary.status = COMPLETED;
                      0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                      break a;
                    }
                  } catch (thrownValue$2) {
                    newBoundary.status = CLIENT_RENDERED;
                    if (12 === request.status) {
                      contentRootSegment.status = 3;
                      var error = request.fatalError;
                    } else
                      contentRootSegment.status = 4, error = thrownValue$2;
                    var thrownInfo = getThrownInfo(task.componentStack);
                    var errorDigest = logRecoverableError(
                      request,
                      error,
                      thrownInfo,
                      task.debugTask
                    );
                    encodeErrorForBoundary(
                      newBoundary,
                      errorDigest,
                      error,
                      thrownInfo,
                      false
                    );
                    untrackBoundary(request, newBoundary);
                  } finally {
                    task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$3;
                  }
                  var suspendedFallbackTask = createRenderTask(
                    request,
                    null,
                    fallback,
                    -1,
                    parentBoundary,
                    boundarySegment,
                    newBoundary.fallbackPreamble,
                    newBoundary.fallbackState,
                    fallbackAbortSet,
                    [keyPath[0], "Suspense Fallback", keyPath[2]],
                    task.formatContext,
                    task.context,
                    task.treeContext,
                    task.componentStack,
                    true,
                    emptyContextObject,
                    task.debugTask
                  );
                  pushComponentStack(suspendedFallbackTask);
                  request.pingedTasks.push(suspendedFallbackTask);
                }
              }
              return;
          }
          if ("object" === typeof type2 && null !== type2)
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                if ("ref" in props) {
                  var propsWithoutRef = {};
                  for (var key in props)
                    "ref" !== key && (propsWithoutRef[key] = props[key]);
                } else propsWithoutRef = props;
                var children$jscomp$0 = renderWithHooks(
                  request,
                  task,
                  keyPath,
                  type2.render,
                  propsWithoutRef,
                  ref
                );
                finishFunctionComponent(
                  request,
                  task,
                  keyPath,
                  children$jscomp$0,
                  0 !== localIdCounter,
                  actionStateCounter,
                  actionStateMatchingIndex
                );
                return;
              case REACT_MEMO_TYPE:
                renderElement(request, task, keyPath, type2.type, props, ref);
                return;
              case REACT_PROVIDER_TYPE:
              case REACT_CONTEXT_TYPE:
                var value$jscomp$0 = props.value, children$jscomp$1 = props.children;
                var prevSnapshot = task.context;
                var prevKeyPath$jscomp$4 = task.keyPath;
                var prevValue = type2._currentValue;
                type2._currentValue = value$jscomp$0;
                void 0 !== type2._currentRenderer && null !== type2._currentRenderer && type2._currentRenderer !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type2._currentRenderer = rendererSigil;
                var prevNode = currentActiveSnapshot, newNode = {
                  parent: prevNode,
                  depth: null === prevNode ? 0 : prevNode.depth + 1,
                  context: type2,
                  parentValue: prevValue,
                  value: value$jscomp$0
                };
                currentActiveSnapshot = newNode;
                task.context = newNode;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, children$jscomp$1, -1);
                var prevSnapshot$jscomp$0 = currentActiveSnapshot;
                if (null === prevSnapshot$jscomp$0)
                  throw Error(
                    "Tried to pop a Context at the root of the app. This is a bug in React."
                  );
                prevSnapshot$jscomp$0.context !== type2 && console.error(
                  "The parent context is not the expected context. This is probably a bug in React."
                );
                prevSnapshot$jscomp$0.context._currentValue = prevSnapshot$jscomp$0.parentValue;
                void 0 !== type2._currentRenderer && null !== type2._currentRenderer && type2._currentRenderer !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type2._currentRenderer = rendererSigil;
                var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot = prevSnapshot$jscomp$0.parent;
                task.context = JSCompiler_inline_result$jscomp$0;
                task.keyPath = prevKeyPath$jscomp$4;
                prevSnapshot !== task.context && console.error(
                  "Popping the context provider did not return back to the original snapshot. This is a bug in React."
                );
                return;
              case REACT_CONSUMER_TYPE:
                var context$jscomp$0 = type2._context, render = props.children;
                "function" !== typeof render && console.error(
                  "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
                );
                var newChildren = render(context$jscomp$0._currentValue), prevKeyPath$jscomp$5 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, newChildren, -1);
                task.keyPath = prevKeyPath$jscomp$5;
                return;
              case REACT_LAZY_TYPE:
                var Component = callLazyInitInDEV(type2);
                if (12 === request.status) throw null;
                renderElement(request, task, keyPath, Component, props, ref);
                return;
            }
          var info = "";
          if (void 0 === type2 || "object" === typeof type2 && null !== type2 && 0 === Object.keys(type2).length)
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          throw Error(
            "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type2 ? type2 : typeof type2) + "." + info)
          );
        }
      }
      __name(renderElement, "renderElement");
      function resumeNode(request, task, segmentId, node, childIndex) {
        var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
          request,
          0,
          null,
          task.formatContext,
          false,
          false
        );
        resumedSegment.id = segmentId;
        resumedSegment.parentFlushed = true;
        try {
          task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = COMPLETED, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
        } finally {
          task.replay = prevReplay, task.blockedSegment = null;
        }
      }
      __name(resumeNode, "resumeNode");
      function replayElement(request, task, keyPath, name, keyOrIndex, childIndex, type2, props, ref, replay) {
        childIndex = replay.nodes;
        for (var i = 0; i < childIndex.length; i++) {
          var node = childIndex[i];
          if (keyOrIndex === node[1]) {
            if (4 === node.length) {
              if (null !== name && name !== node[0])
                throw Error(
                  "Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering."
                );
              var childNodes = node[2];
              node = node[3];
              name = task.node;
              task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
              try {
                renderElement(request, task, keyPath, type2, props, ref);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x) {
                if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                  throw task.node === name && (task.replay = replay), x;
                task.replay.pendingTasks--;
                type2 = getThrownInfo(task.componentStack);
                props = request;
                request = task.blockedBoundary;
                keyPath = x;
                ref = node;
                node = logRecoverableError(props, keyPath, type2, task.debugTask);
                abortRemainingReplayNodes(
                  props,
                  request,
                  childNodes,
                  ref,
                  keyPath,
                  node,
                  type2,
                  false
                );
              }
              task.replay = replay;
            } else {
              if (type2 !== REACT_SUSPENSE_TYPE)
                throw Error(
                  "Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type2) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering."
                );
              a: {
                replay = void 0;
                type2 = node[5];
                ref = node[2];
                name = node[3];
                keyOrIndex = null === node[4] ? [] : node[4][2];
                node = null === node[4] ? null : node[4][3];
                var prevKeyPath = task.keyPath, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                props = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  createPreambleState(),
                  createPreambleState()
                ) : createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  null,
                  null
                );
                props.parentFlushed = true;
                props.rootSegmentID = type2;
                task.blockedBoundary = props;
                task.hoistableState = props.contentState;
                task.keyPath = keyPath;
                task.replay = { nodes: ref, slots: name, pendingTasks: 1 };
                try {
                  renderNode(request, task, content, -1);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                  if (0 === props.pendingTasks && props.status === PENDING) {
                    props.status = COMPLETED;
                    request.completedBoundaries.push(props);
                    break a;
                  }
                } catch (error) {
                  props.status = CLIENT_RENDERED, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                    request,
                    error,
                    childNodes,
                    task.debugTask
                  ), encodeErrorForBoundary(props, replay, error, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                } finally {
                  task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;
                }
                props = createReplayTask(
                  request,
                  null,
                  { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
                  fallback,
                  -1,
                  parentBoundary,
                  props.fallbackState,
                  fallbackAbortSet,
                  [keyPath[0], "Suspense Fallback", keyPath[2]],
                  task.formatContext,
                  task.context,
                  task.treeContext,
                  task.componentStack,
                  true,
                  emptyContextObject,
                  task.debugTask
                );
                pushComponentStack(props);
                request.pingedTasks.push(props);
              }
            }
            childIndex.splice(i, 1);
            break;
          }
        }
      }
      __name(replayElement, "replayElement");
      function renderNodeDestructive(request, task, node, childIndex) {
        null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack(task), retryNode(request, task), task.componentStack = node, task.debugTask = childIndex);
      }
      __name(renderNodeDestructive, "renderNodeDestructive");
      function retryNode(request, task) {
        var node = task.node, childIndex = task.childIndex;
        if (null !== node) {
          if ("object" === typeof node) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = node.type, key = node.key;
                node = node.props;
                var refProp = node.ref;
                refProp = void 0 !== refProp ? refProp : null;
                var debugTask = task.debugTask, name = getComponentNameFromType(type2);
                key = null == key ? -1 === childIndex ? 0 : childIndex : key;
                var keyPath = [task.keyPath, name, key];
                null !== task.replay ? debugTask ? debugTask.run(
                  replayElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    name,
                    key,
                    childIndex,
                    type2,
                    node,
                    refProp,
                    task.replay
                  )
                ) : replayElement(
                  request,
                  task,
                  keyPath,
                  name,
                  key,
                  childIndex,
                  type2,
                  node,
                  refProp,
                  task.replay
                ) : debugTask ? debugTask.run(
                  renderElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    type2,
                    node,
                    refProp
                  )
                ) : renderElement(request, task, keyPath, type2, node, refProp);
                return;
              case REACT_PORTAL_TYPE:
                throw Error(
                  "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render."
                );
              case REACT_LAZY_TYPE:
                node = callLazyInitInDEV(node);
                if (12 === request.status) throw null;
                renderNodeDestructive(request, task, node, childIndex);
                return;
            }
            if (isArrayImpl(node)) {
              renderChildrenArray(request, task, node, childIndex);
              return;
            }
            null === node || "object" !== typeof node ? key = null : (type2 = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], key = "function" === typeof type2 ? type2 : null);
            if (key && (type2 = key.call(node))) {
              if (type2 === node) {
                if (-1 !== childIndex || null === task.componentStack || "function" !== typeof task.componentStack.type || "[object GeneratorFunction]" !== Object.prototype.toString.call(task.componentStack.type) || "[object Generator]" !== Object.prototype.toString.call(type2))
                  didWarnAboutGenerators || console.error(
                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                  ), didWarnAboutGenerators = true;
              } else
                node.entries !== key || didWarnAboutMaps || (console.error(
                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                ), didWarnAboutMaps = true);
              node = type2.next();
              if (!node.done) {
                key = [];
                do
                  key.push(node.value), node = type2.next();
                while (!node.done);
                renderChildrenArray(request, task, key, childIndex);
              }
              return;
            }
            if ("function" === typeof node.then)
              return task.thenableState = null, renderNodeDestructive(
                request,
                task,
                unwrapThenable(node),
                childIndex
              );
            if (node.$$typeof === REACT_CONTEXT_TYPE)
              return renderNodeDestructive(
                request,
                task,
                node._currentValue,
                childIndex
              );
            request = Object.prototype.toString.call(node);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === request ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          "string" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            node,
            request.renderState,
            task.lastPushedText
          ))) : "number" === typeof node || "bigint" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            "" + node,
            request.renderState,
            task.lastPushedText
          ))) : ("function" === typeof node && (request = node.displayName || node.name || "Component", console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
            request,
            request
          )), "symbol" === typeof node && console.error(
            "Symbols are not valid as a React child.\n  %s",
            String(node)
          ));
        }
      }
      __name(retryNode, "retryNode");
      function renderChildrenArray(request, task, children, childIndex) {
        var prevKeyPath = task.keyPath, previousComponentStack = task.componentStack;
        var previousDebugTask = task.debugTask;
        pushServerComponentStack(task, task.node._debugInfo);
        if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
          for (var replay = task.replay, replayNodes = replay.nodes, j = 0; j < replayNodes.length; j++) {
            var node = replayNodes[j];
            if (node[1] === childIndex) {
              childIndex = node[2];
              node = node[3];
              task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
              try {
                renderChildrenArray(request, task, children, -1);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x) {
                if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                  throw x;
                task.replay.pendingTasks--;
                var thrownInfo = getThrownInfo(task.componentStack);
                children = task.blockedBoundary;
                var error = x, resumeSlots = node;
                node = logRecoverableError(
                  request,
                  error,
                  thrownInfo,
                  task.debugTask
                );
                abortRemainingReplayNodes(
                  request,
                  children,
                  childIndex,
                  resumeSlots,
                  error,
                  node,
                  thrownInfo,
                  false
                );
              }
              task.replay = replay;
              replayNodes.splice(j, 1);
              break;
            }
          }
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        replay = task.treeContext;
        replayNodes = children.length;
        if (null !== task.replay && (j = task.replay.slots, null !== j && "object" === typeof j)) {
          for (childIndex = 0; childIndex < replayNodes; childIndex++)
            node = children[childIndex], task.treeContext = pushTreeContext(
              replay,
              replayNodes,
              childIndex
            ), error = j[childIndex], "number" === typeof error ? (resumeNode(request, task, error, node, childIndex), delete j[childIndex]) : renderNode(request, task, node, childIndex);
          task.treeContext = replay;
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        for (j = 0; j < replayNodes; j++) {
          childIndex = children[j];
          resumeSlots = request;
          node = task;
          error = childIndex;
          if (null !== error && "object" === typeof error && (error.$$typeof === REACT_ELEMENT_TYPE || error.$$typeof === REACT_PORTAL_TYPE) && error._store && (!error._store.validated && null == error.key || 2 === error._store.validated)) {
            if ("object" !== typeof error._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            error._store.validated = 1;
            thrownInfo = resumeSlots.didWarnForKey;
            null == thrownInfo && (thrownInfo = resumeSlots.didWarnForKey = /* @__PURE__ */ new WeakSet());
            resumeSlots = node.componentStack;
            if (null !== resumeSlots && !thrownInfo.has(resumeSlots)) {
              thrownInfo.add(resumeSlots);
              var componentName = getComponentNameFromType(error.type);
              thrownInfo = error._owner;
              var parentOwner = resumeSlots.owner;
              resumeSlots = "";
              if (parentOwner && "undefined" !== typeof parentOwner.type) {
                var name = getComponentNameFromType(parentOwner.type);
                name && (resumeSlots = "\n\nCheck the render method of `" + name + "`.");
              }
              resumeSlots || componentName && (resumeSlots = "\n\nCheck the top-level render call using <" + componentName + ">.");
              componentName = "";
              null != thrownInfo && parentOwner !== thrownInfo && (parentOwner = null, "undefined" !== typeof thrownInfo.type ? parentOwner = getComponentNameFromType(thrownInfo.type) : "string" === typeof thrownInfo.name && (parentOwner = thrownInfo.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
              thrownInfo = node.componentStack;
              node.componentStack = {
                parent: node.componentStack,
                type: error.type,
                owner: error._owner,
                stack: error._debugStack
              };
              console.error(
                'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                resumeSlots,
                componentName
              );
              node.componentStack = thrownInfo;
            }
          }
          task.treeContext = pushTreeContext(replay, replayNodes, j);
          renderNode(request, task, childIndex, j);
        }
        task.treeContext = replay;
        task.keyPath = prevKeyPath;
        task.componentStack = previousComponentStack;
        task.debugTask = previousDebugTask;
      }
      __name(renderChildrenArray, "renderChildrenArray");
      function untrackBoundary(request, boundary) {
        request = request.trackedPostpones;
        null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
      }
      __name(untrackBoundary, "untrackBoundary");
      function spawnNewSuspendedReplayTask(request, task, thenableState2) {
        return createReplayTask(
          request,
          thenableState2,
          task.replay,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      __name(spawnNewSuspendedReplayTask, "spawnNewSuspendedReplayTask");
      function spawnNewSuspendedRenderTask(request, task, thenableState2) {
        var segment = task.blockedSegment, newSegment = createPendingSegment(
          request,
          segment.chunks.length,
          null,
          task.formatContext,
          segment.lastPushedText,
          true
        );
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        return createRenderTask(
          request,
          thenableState2,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          newSegment,
          task.blockedPreamble,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      __name(spawnNewSuspendedRenderTask, "spawnNewSuspendedRenderTask");
      function renderNode(request, task, node, childIndex) {
        var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, previousDebugTask = task.debugTask, segment = task.blockedSegment;
        if (null === segment)
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue) {
            if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedReplayTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedReplayTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        else {
          var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue$3) {
            if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException ? getSuspendedThenable() : thrownValue$3, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedRenderTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedRenderTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        }
        task.formatContext = previousFormatContext;
        task.context = previousContext;
        task.keyPath = previousKeyPath;
        task.treeContext = previousTreeContext;
        switchContext(previousContext);
        throw node;
      }
      __name(renderNode, "renderNode");
      function abortTaskSoft(task) {
        var boundary = task.blockedBoundary;
        task = task.blockedSegment;
        null !== task && (task.status = 3, finishedTask(this, boundary, task));
      }
      __name(abortTaskSoft, "abortTaskSoft");
      function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (4 === node.length)
            abortRemainingReplayNodes(
              request$jscomp$0,
              boundary,
              node[2],
              node[3],
              error$jscomp$0,
              errorDigest$jscomp$0,
              errorInfo$jscomp$0,
              aborted
            );
          else {
            var request = request$jscomp$0;
            node = node[5];
            var error = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary(
              request,
              /* @__PURE__ */ new Set(),
              null,
              null
            );
            resumedBoundary.parentFlushed = true;
            resumedBoundary.rootSegmentID = node;
            resumedBoundary.status = CLIENT_RENDERED;
            encodeErrorForBoundary(
              resumedBoundary,
              errorDigest,
              error,
              errorInfo,
              wasAborted
            );
            resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
          }
        }
        nodes.length = 0;
        if (null !== slots) {
          if (null === boundary)
            throw Error(
              "We should not have any resumable nodes in the shell. This is a bug in React."
            );
          boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(
            boundary,
            errorDigest$jscomp$0,
            error$jscomp$0,
            errorInfo$jscomp$0,
            aborted
          ), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
          if ("object" === typeof slots)
            for (var index in slots) delete slots[index];
        }
      }
      __name(abortRemainingReplayNodes, "abortRemainingReplayNodes");
      function abortTask(task, request, error) {
        var boundary = task.blockedBoundary, segment = task.blockedSegment;
        if (null !== segment) {
          if (6 === segment.status) return;
          segment.status = 3;
        }
        segment = getThrownInfo(task.componentStack);
        if (null === boundary) {
          if (13 !== request.status && request.status !== CLOSED) {
            boundary = task.replay;
            if (null === boundary) {
              logRecoverableError(request, error, segment, null);
              fatalError(request, error, segment, null);
              return;
            }
            boundary.pendingTasks--;
            0 === boundary.pendingTasks && 0 < boundary.nodes.length && (task = logRecoverableError(request, error, segment, null), abortRemainingReplayNodes(
              request,
              null,
              boundary.nodes,
              boundary.slots,
              error,
              task,
              segment,
              true
            ));
            request.pendingRootTasks--;
            0 === request.pendingRootTasks && completeShell(request);
          }
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, task = logRecoverableError(request, error, segment, null), boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary, task, error, segment, true), untrackBoundary(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, error);
          }), boundary.fallbackAbortableTasks.clear();
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      __name(abortTask, "abortTask");
      function safelyEmitEarlyPreloads(request, shellComplete) {
        try {
          var renderState = request.renderState, onHeaders = renderState.onHeaders;
          if (onHeaders) {
            var headers = renderState.headers;
            if (headers) {
              renderState.headers = null;
              var linkHeader = headers.preconnects;
              headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
              headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
              if (!shellComplete) {
                var queueIter = renderState.styles.values(), queueStep = queueIter.next();
                b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                  for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                    var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                    var header = getPreloadAsHeader(
                      props$jscomp$0.href,
                      "style",
                      {
                        crossOrigin: props$jscomp$0.crossOrigin,
                        integrity: props$jscomp$0.integrity,
                        nonce: props$jscomp$0.nonce,
                        type: props$jscomp$0.type,
                        fetchPriority: props$jscomp$0.fetchPriority,
                        referrerPolicy: props$jscomp$0.referrerPolicy,
                        media: props$jscomp$0.media
                      }
                    );
                    if (0 <= (headers.remainingCapacity -= header.length + 2))
                      renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                    else break b;
                  }
              }
              linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
            }
          }
        } catch (error) {
          logRecoverableError(request, error, {}, null);
        }
      }
      __name(safelyEmitEarlyPreloads, "safelyEmitEarlyPreloads");
      function completeShell(request) {
        null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
        null === request.trackedPostpones && preparePreamble(request);
        request.onShellError = noop2;
        request = request.onShellReady;
        request();
      }
      __name(completeShell, "completeShell");
      function completeAll(request) {
        safelyEmitEarlyPreloads(
          request,
          null === request.trackedPostpones ? true : null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED
        );
        preparePreamble(request);
        request = request.onAllReady;
        request();
      }
      __name(completeAll, "completeAll");
      function queueCompletedSegment(boundary, segment) {
        if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          childSegment.status === COMPLETED && queueCompletedSegment(boundary, childSegment);
        } else boundary.completedSegments.push(segment);
      }
      __name(queueCompletedSegment, "queueCompletedSegment");
      function finishedTask(request, boundary, segment) {
        if (null === boundary) {
          if (null !== segment && segment.parentFlushed) {
            if (null !== request.completedRootSegment)
              throw Error(
                "There can only be one root segment. This is a bug in React."
              );
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          0 === request.pendingRootTasks && completeShell(request);
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (0 === boundary.pendingTasks ? (boundary.status === PENDING && (boundary.status = COMPLETED), null !== segment && segment.parentFlushed && segment.status === COMPLETED && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED && (boundary.fallbackAbortableTasks.forEach(
            abortTaskSoft,
            request
          ), boundary.fallbackAbortableTasks.clear(), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request))) : null !== segment && segment.parentFlushed && segment.status === COMPLETED && (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)));
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      __name(finishedTask, "finishedTask");
      function performWork(request$jscomp$2) {
        if (request$jscomp$2.status !== CLOSED && 13 !== request$jscomp$2.status) {
          var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = HooksDispatcher;
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          var prevRequest = currentRequest;
          currentRequest = request$jscomp$2;
          var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
          ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
          var prevResumableState = currentResumableState;
          currentResumableState = request$jscomp$2.resumableState;
          try {
            var pingedTasks = request$jscomp$2.pingedTasks, i;
            for (i = 0; i < pingedTasks.length; i++) {
              var request = request$jscomp$2, task = pingedTasks[i], segment = task.blockedSegment;
              if (null === segment) {
                var prevTaskInDEV = void 0, request$jscomp$0 = request;
                request = task;
                if (0 !== request.replay.pendingTasks) {
                  switchContext(request.context);
                  prevTaskInDEV = currentTaskInDEV;
                  currentTaskInDEV = request;
                  try {
                    "number" === typeof request.replay.slots ? resumeNode(
                      request$jscomp$0,
                      request,
                      request.replay.slots,
                      request.node,
                      request.childIndex
                    ) : retryNode(request$jscomp$0, request);
                    if (1 === request.replay.pendingTasks && 0 < request.replay.nodes.length)
                      throw Error(
                        "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                      );
                    request.replay.pendingTasks--;
                    request.abortSet.delete(request);
                    finishedTask(request$jscomp$0, request.blockedBoundary, null);
                  } catch (thrownValue) {
                    resetHooksState();
                    var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                    if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                      var ping3 = request.ping;
                      x.then(ping3, ping3);
                      request.thenableState = getThenableStateAfterSuspending();
                    } else {
                      request.replay.pendingTasks--;
                      request.abortSet.delete(request);
                      var errorInfo = getThrownInfo(request.componentStack), errorDigest = void 0, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                      errorDigest = logRecoverableError(
                        request$jscomp$1,
                        error$jscomp$0,
                        errorInfo$jscomp$0,
                        request.debugTask
                      );
                      abortRemainingReplayNodes(
                        request$jscomp$1,
                        boundary,
                        replayNodes,
                        resumeSlots,
                        error$jscomp$0,
                        errorDigest,
                        errorInfo$jscomp$0,
                        false
                      );
                      request$jscomp$0.pendingRootTasks--;
                      0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                      request$jscomp$0.allPendingTasks--;
                      0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                    }
                  } finally {
                    currentTaskInDEV = prevTaskInDEV;
                  }
                }
              } else if (request$jscomp$0 = prevTaskInDEV = void 0, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
                request$jscomp$1.status = 6;
                switchContext(errorDigest.context);
                request$jscomp$0 = currentTaskInDEV;
                currentTaskInDEV = errorDigest;
                var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
                try {
                  retryNode(request, errorDigest), request$jscomp$1.lastPushedText && request$jscomp$1.textEmbedded && request$jscomp$1.chunks.push(textSeparator), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedTask(
                    request,
                    errorDigest.blockedBoundary,
                    request$jscomp$1
                  );
                } catch (thrownValue) {
                  resetHooksState();
                  request$jscomp$1.children.length = childrenLength;
                  request$jscomp$1.chunks.length = chunkLength;
                  var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                    request$jscomp$1.status = PENDING;
                    errorDigest.thenableState = getThenableStateAfterSuspending();
                    var ping$jscomp$0 = errorDigest.ping;
                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                  } else {
                    var errorInfo$jscomp$1 = getThrownInfo(
                      errorDigest.componentStack
                    );
                    errorDigest.abortSet.delete(errorDigest);
                    request$jscomp$1.status = 4;
                    var boundary$jscomp$0 = errorDigest.blockedBoundary, debugTask = errorDigest.debugTask;
                    prevTaskInDEV = logRecoverableError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    );
                    null === boundary$jscomp$0 ? fatalError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    ) : (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED && (boundary$jscomp$0.status = CLIENT_RENDERED, encodeErrorForBoundary(
                      boundary$jscomp$0,
                      prevTaskInDEV,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      false
                    ), untrackBoundary(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(
                      boundary$jscomp$0
                    ), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request)));
                    request.allPendingTasks--;
                    0 === request.allPendingTasks && completeAll(request);
                  }
                } finally {
                  currentTaskInDEV = request$jscomp$0;
                }
              }
            }
            pingedTasks.splice(0, i);
            null !== request$jscomp$2.destination && flushCompletedQueues(
              request$jscomp$2,
              request$jscomp$2.destination
            );
          } catch (error) {
            pingedTasks = {}, logRecoverableError(request$jscomp$2, error, pingedTasks, null), fatalError(request$jscomp$2, error, pingedTasks, null);
          } finally {
            currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
          }
        }
      }
      __name(performWork, "performWork");
      function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
        segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
        for (var pendingPreambles = false, i = 0; i < segment.children.length; i++)
          pendingPreambles = preparePreambleFromSegment(
            request,
            segment.children[i],
            collectedPreambleSegments
          ) || pendingPreambles;
        return pendingPreambles;
      }
      __name(preparePreambleFromSubtree, "preparePreambleFromSubtree");
      function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
        var boundary = segment.boundary;
        if (null === boundary)
          return preparePreambleFromSubtree(
            request,
            segment,
            collectedPreambleSegments
          );
        var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
        if (null === preamble || null === fallbackPreamble) return false;
        switch (boundary.status) {
          case COMPLETED:
            hoistPreambleState(request.renderState, preamble);
            segment = boundary.completedSegments[0];
            if (!segment)
              throw Error(
                "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
              );
            return preparePreambleFromSubtree(
              request,
              segment,
              collectedPreambleSegments
            );
          case POSTPONED:
            if (null !== request.trackedPostpones) return true;
          case CLIENT_RENDERED:
            if (segment.status === COMPLETED)
              return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
                request,
                segment,
                collectedPreambleSegments
              );
          default:
            return true;
        }
      }
      __name(preparePreambleFromSegment, "preparePreambleFromSegment");
      function preparePreamble(request) {
        if (request.completedRootSegment && null === request.completedPreambleSegments) {
          var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment(
            request,
            request.completedRootSegment,
            collectedPreambleSegments
          ), preamble = request.renderState.preamble;
          if (false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks)
            request.completedPreambleSegments = collectedPreambleSegments;
        }
      }
      __name(preparePreamble, "preparePreamble");
      function flushSubtree(request, destination, segment, hoistableState) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING:
            segment.id = request.nextSegmentId++;
          case POSTPONED:
            return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, writeChunk(destination, placeholder1), writeChunk(destination, request.placeholderPrefix), request = stringToChunk(hoistableState.toString(16)), writeChunk(destination, request), writeChunkAndReturn(destination, placeholder2);
          case COMPLETED:
            segment.status = FLUSHED;
            var r = true, chunks = segment.chunks, chunkIdx = 0;
            segment = segment.children;
            for (var childIdx = 0; childIdx < segment.length; childIdx++) {
              for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)
                writeChunk(destination, chunks[chunkIdx]);
              r = flushSegment(request, destination, r, hoistableState);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++)
              writeChunk(destination, chunks[chunkIdx]);
            chunkIdx < chunks.length && (r = writeChunkAndReturn(destination, chunks[chunkIdx]));
            return r;
          default:
            throw Error(
              "Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React."
            );
        }
      }
      __name(flushSubtree, "flushSubtree");
      function flushSegment(request, destination, segment, hoistableState) {
        var boundary = segment.boundary;
        if (null === boundary)
          return flushSubtree(request, destination, segment, hoistableState);
        boundary.parentFlushed = true;
        if (boundary.status === CLIENT_RENDERED) {
          var errorDigest = boundary.errorDigest, errorMessage2 = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
          writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          errorDigest && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(
            destination,
            stringToChunk(escapeTextForBrowser(errorDigest))
          ), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          errorMessage2 && (writeChunk(destination, clientRenderedSuspenseBoundaryError1B), writeChunk(
            destination,
            stringToChunk(escapeTextForBrowser(errorMessage2))
          ), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          errorStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1C), writeChunk(
            destination,
            stringToChunk(escapeTextForBrowser(errorStack))
          ), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          errorComponentStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1D), writeChunk(
            destination,
            stringToChunk(escapeTextForBrowser(errorComponentStack))
          ), writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial
          ));
          writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          flushSubtree(request, destination, segment, hoistableState);
          (request = boundary.fallbackPreamble) && writePreambleContribution(destination, request);
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        if (boundary.status !== COMPLETED)
          return boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency, hoistableState), boundary.stylesheets.forEach(
            hoistStylesheetDependency,
            hoistableState
          )), flushSubtree(request, destination, segment, hoistableState), writeChunkAndReturn(destination, endSuspenseBoundary);
        if (boundary.byteSize > request.progressiveChunkSize)
          return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), flushSubtree(request, destination, segment, hoistableState), writeChunkAndReturn(destination, endSuspenseBoundary);
        hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));
        writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        segment = boundary.completedSegments;
        if (1 !== segment.length)
          throw Error(
            "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
          );
        flushSegment(request, destination, segment[0], hoistableState);
        (request = boundary.contentPreamble) && writePreambleContribution(destination, request);
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      __name(flushSegment, "flushSegment");
      function flushSegmentContainer(request, destination, segment, hoistableState) {
        writeStartSegment(
          destination,
          request.renderState,
          segment.parentFormatContext,
          segment.id
        );
        flushSegment(request, destination, segment, hoistableState);
        return writeEndSegment(destination, segment.parentFormatContext);
      }
      __name(flushSegmentContainer, "flushSegmentContainer");
      function flushCompletedBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++)
          flushPartiallyCompletedSegment(
            request,
            destination,
            boundary,
            completedSegments[i]
          );
        completedSegments.length = 0;
        writeHoistablesForBoundary(
          destination,
          boundary.contentState,
          request.renderState
        );
        completedSegments = request.resumableState;
        request = request.renderState;
        i = boundary.rootSegmentID;
        boundary = boundary.contentState;
        var requiresStyleInsertion = request.stylesToHoist;
        request.stylesToHoist = false;
        writeChunk(destination, request.startInlineScript);
        requiresStyleInsertion ? (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions = completedSegments.instructions | SentStyleInsertionFunction | SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryWithStylesScript1FullBoth)) : (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, writeChunk(
          destination,
          completeBoundaryWithStylesScript1FullPartial
        )) : writeChunk(destination, completeBoundaryWithStylesScript1Partial) : (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions |= SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryScript1Full)) : writeChunk(destination, completeBoundaryScript1Partial);
        completedSegments = stringToChunk(i.toString(16));
        writeChunk(destination, request.boundaryPrefix);
        writeChunk(destination, completedSegments);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, request.segmentPrefix);
        writeChunk(destination, completedSegments);
        requiresStyleInsertion ? (writeChunk(destination, completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : writeChunk(destination, completeBoundaryScript3b);
        boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
        return writeBootstrap(destination, request) && boundary;
      }
      __name(flushCompletedBoundary, "flushCompletedBoundary");
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) return true;
        var hoistableState = boundary.contentState, segmentID = segment.id;
        if (-1 === segmentID) {
          if (-1 === (segment.id = boundary.rootSegmentID))
            throw Error(
              "A root segment ID must have been assigned by now. This is a bug in React."
            );
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        }
        if (segmentID === boundary.rootSegmentID)
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        flushSegmentContainer(request, destination, segment, hoistableState);
        boundary = request.resumableState;
        request = request.renderState;
        writeChunk(destination, request.startInlineScript);
        (boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, writeChunk(destination, completeSegmentScript1Full)) : writeChunk(destination, completeSegmentScript1Partial);
        writeChunk(destination, request.segmentPrefix);
        segmentID = stringToChunk(segmentID.toString(16));
        writeChunk(destination, segmentID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, request.placeholderPrefix);
        writeChunk(destination, segmentID);
        destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
        return destination;
      }
      __name(flushPartiallyCompletedSegment, "flushPartiallyCompletedSegment");
      function flushCompletedQueues(request, destination) {
        currentView = new Uint8Array(2048);
        writtenBytes = 0;
        try {
          if (!(0 < request.pendingRootTasks)) {
            var i, completedRootSegment = request.completedRootSegment;
            if (null !== completedRootSegment) {
              if (completedRootSegment.status === POSTPONED) return;
              var completedPreambleSegments = request.completedPreambleSegments;
              if (null === completedPreambleSegments) return;
              var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
              if (htmlChunks) {
                for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                  writeChunk(destination, htmlChunks[i$jscomp$0]);
                if (headChunks)
                  for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                    writeChunk(destination, headChunks[i$jscomp$0]);
                else
                  writeChunk(destination, startChunkForTag("head")), writeChunk(destination, endOfStartTag);
              } else if (headChunks)
                for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                  writeChunk(destination, headChunks[i$jscomp$0]);
              var charsetChunks = renderState.charsetChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
                writeChunk(destination, charsetChunks[i$jscomp$0]);
              charsetChunks.length = 0;
              renderState.preconnects.forEach(flushResource, destination);
              renderState.preconnects.clear();
              var viewportChunks = renderState.viewportChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
                writeChunk(destination, viewportChunks[i$jscomp$0]);
              viewportChunks.length = 0;
              renderState.fontPreloads.forEach(flushResource, destination);
              renderState.fontPreloads.clear();
              renderState.highImagePreloads.forEach(flushResource, destination);
              renderState.highImagePreloads.clear();
              renderState.styles.forEach(flushStylesInPreamble, destination);
              var importMapChunks = renderState.importMapChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
                writeChunk(destination, importMapChunks[i$jscomp$0]);
              importMapChunks.length = 0;
              renderState.bootstrapScripts.forEach(flushResource, destination);
              renderState.scripts.forEach(flushResource, destination);
              renderState.scripts.clear();
              renderState.bulkPreloads.forEach(flushResource, destination);
              renderState.bulkPreloads.clear();
              var hoistableChunks = renderState.hoistableChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
                writeChunk(destination, hoistableChunks[i$jscomp$0]);
              for (renderState = hoistableChunks.length = 0; renderState < completedPreambleSegments.length; renderState++) {
                var segments = completedPreambleSegments[renderState];
                for (preamble = 0; preamble < segments.length; preamble++)
                  flushSegment(request, destination, segments[preamble], null);
              }
              var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
              (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) && writeChunk(destination, endChunkForTag("head"));
              var bodyChunks = preamble$jscomp$0.bodyChunks;
              if (bodyChunks)
                for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                  writeChunk(destination, bodyChunks[completedPreambleSegments]);
              flushSegment(request, destination, completedRootSegment, null);
              request.completedRootSegment = null;
              writeBootstrap(destination, request.renderState);
            }
            var renderState$jscomp$0 = request.renderState;
            completedRootSegment = 0;
            var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;
            for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
              writeChunk(
                destination,
                viewportChunks$jscomp$0[completedRootSegment]
              );
            viewportChunks$jscomp$0.length = 0;
            renderState$jscomp$0.preconnects.forEach(flushResource, destination);
            renderState$jscomp$0.preconnects.clear();
            renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.fontPreloads.clear();
            renderState$jscomp$0.highImagePreloads.forEach(
              flushResource,
              destination
            );
            renderState$jscomp$0.highImagePreloads.clear();
            renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);
            renderState$jscomp$0.scripts.forEach(flushResource, destination);
            renderState$jscomp$0.scripts.clear();
            renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.bulkPreloads.clear();
            var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;
            for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
              writeChunk(
                destination,
                hoistableChunks$jscomp$0[completedRootSegment]
              );
            hoistableChunks$jscomp$0.length = 0;
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            for (i = 0; i < clientRenderedBoundaries.length; i++) {
              var boundary = clientRenderedBoundaries[i];
              renderState$jscomp$0 = destination;
              var resumableState = request.resumableState, renderState$jscomp$1 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage2 = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
              writeChunk(
                renderState$jscomp$0,
                renderState$jscomp$1.startInlineScript
              );
              (resumableState.instructions & SentClientRenderFunction) === NothingSent ? (resumableState.instructions |= SentClientRenderFunction, writeChunk(renderState$jscomp$0, clientRenderScript1Full)) : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);
              writeChunk(
                renderState$jscomp$0,
                renderState$jscomp$1.boundaryPrefix
              );
              writeChunk(renderState$jscomp$0, stringToChunk(id.toString(16)));
              writeChunk(renderState$jscomp$0, clientRenderScript1A);
              if (errorDigest || errorMessage2 || errorStack || errorComponentStack)
                writeChunk(
                  renderState$jscomp$0,
                  clientRenderErrorScriptArgInterstitial
                ), writeChunk(
                  renderState$jscomp$0,
                  stringToChunk(
                    escapeJSStringsForInstructionScripts(errorDigest || "")
                  )
                );
              if (errorMessage2 || errorStack || errorComponentStack)
                writeChunk(
                  renderState$jscomp$0,
                  clientRenderErrorScriptArgInterstitial
                ), writeChunk(
                  renderState$jscomp$0,
                  stringToChunk(
                    escapeJSStringsForInstructionScripts(errorMessage2 || "")
                  )
                );
              if (errorStack || errorComponentStack)
                writeChunk(
                  renderState$jscomp$0,
                  clientRenderErrorScriptArgInterstitial
                ), writeChunk(
                  renderState$jscomp$0,
                  stringToChunk(
                    escapeJSStringsForInstructionScripts(errorStack || "")
                  )
                );
              errorComponentStack && (writeChunk(
                renderState$jscomp$0,
                clientRenderErrorScriptArgInterstitial
              ), writeChunk(
                renderState$jscomp$0,
                stringToChunk(
                  escapeJSStringsForInstructionScripts(errorComponentStack)
                )
              ));
              var JSCompiler_inline_result = writeChunkAndReturn(
                renderState$jscomp$0,
                clientRenderScriptEnd
              );
              if (!JSCompiler_inline_result) {
                request.destination = null;
                i++;
                clientRenderedBoundaries.splice(0, i);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i);
            var completedBoundaries = request.completedBoundaries;
            for (i = 0; i < completedBoundaries.length; i++)
              if (!flushCompletedBoundary(
                request,
                destination,
                completedBoundaries[i]
              )) {
                request.destination = null;
                i++;
                completedBoundaries.splice(0, i);
                return;
              }
            completedBoundaries.splice(0, i);
            completeWriting(destination);
            currentView = new Uint8Array(2048);
            writtenBytes = 0;
            var partialBoundaries = request.partialBoundaries;
            for (i = 0; i < partialBoundaries.length; i++) {
              a: {
                clientRenderedBoundaries = request;
                boundary = destination;
                var boundary$jscomp$0 = partialBoundaries[i], completedSegments = boundary$jscomp$0.completedSegments;
                for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                  if (!flushPartiallyCompletedSegment(
                    clientRenderedBoundaries,
                    boundary,
                    boundary$jscomp$0,
                    completedSegments[JSCompiler_inline_result]
                  )) {
                    JSCompiler_inline_result++;
                    completedSegments.splice(0, JSCompiler_inline_result);
                    var JSCompiler_inline_result$jscomp$0 = false;
                    break a;
                  }
                completedSegments.splice(0, JSCompiler_inline_result);
                JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
                  boundary,
                  boundary$jscomp$0.contentState,
                  clientRenderedBoundaries.renderState
                );
              }
              if (!JSCompiler_inline_result$jscomp$0) {
                request.destination = null;
                i++;
                partialBoundaries.splice(0, i);
                return;
              }
            }
            partialBoundaries.splice(0, i);
            var largeBoundaries = request.completedBoundaries;
            for (i = 0; i < largeBoundaries.length; i++)
              if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {
                request.destination = null;
                i++;
                largeBoundaries.splice(0, i);
                return;
              }
            largeBoundaries.splice(0, i);
          }
        } finally {
          0 === request.allPendingTasks && 0 === request.pingedTasks.length && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length ? (request.flushScheduled = false, i = request.resumableState, i.hasBody && writeChunk(destination, endChunkForTag("body")), i.hasHtml && writeChunk(destination, endChunkForTag("html")), completeWriting(destination), 0 !== request.abortableTasks.size && console.error(
            "There was still abortable task at the root when we closed. This is a bug in React."
          ), request.status = CLOSED, destination.close(), request.destination = null) : completeWriting(destination);
        }
      }
      __name(flushCompletedQueues, "flushCompletedQueues");
      function startWork(request) {
        request.flushScheduled = null !== request.destination;
        supportsRequestStorage ? scheduleMicrotask(function() {
          return requestStorage.run(request, performWork, request);
        }) : scheduleMicrotask(function() {
          return performWork(request);
        });
        setTimeout(function() {
          10 === request.status && (request.status = 11);
          null === request.trackedPostpones && (supportsRequestStorage ? requestStorage.run(
            request,
            enqueueEarlyPreloadsAfterInitialWork,
            request
          ) : enqueueEarlyPreloadsAfterInitialWork(request));
        }, 0);
      }
      __name(startWork, "startWork");
      function enqueueEarlyPreloadsAfterInitialWork(request) {
        safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);
      }
      __name(enqueueEarlyPreloadsAfterInitialWork, "enqueueEarlyPreloadsAfterInitialWork");
      function enqueueFlush(request) {
        false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination && (request.flushScheduled = true, setTimeout(function() {
          var destination = request.destination;
          destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
        }, 0));
      }
      __name(enqueueFlush, "enqueueFlush");
      function startFlowing(request, destination) {
        if (13 === request.status)
          request.status = CLOSED, closeWithError(destination, request.fatalError);
        else if (request.status !== CLOSED && null === request.destination) {
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error) {
            destination = {}, logRecoverableError(request, error, destination, null), fatalError(request, error, destination, null);
          }
        }
      }
      __name(startFlowing, "startFlowing");
      function abort(request, reason) {
        if (11 === request.status || 10 === request.status) request.status = 12;
        try {
          var abortableTasks = request.abortableTasks;
          if (0 < abortableTasks.size) {
            var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
            request.fatalError = error;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, error);
            });
            abortableTasks.clear();
          }
          null !== request.destination && flushCompletedQueues(request, request.destination);
        } catch (error$4) {
          reason = {}, logRecoverableError(request, error$4, reason, null), fatalError(request, error$4, reason, null);
        }
      }
      __name(abort, "abort");
      function ensureCorrectIsomorphicReactVersion() {
        var isomorphicReactPackageVersion = React5.version;
        if ("19.1.1" !== isomorphicReactPackageVersion)
          throw Error(
            'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.1.1\nLearn more: https://react.dev/warnings/version-mismatch")
          );
      }
      __name(ensureCorrectIsomorphicReactVersion, "ensureCorrectIsomorphicReactVersion");
      var React5 = require_react(), ReactDOM = require_react_dom(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, isArrayImpl = Array.isArray, jsxPropsParents = /* @__PURE__ */ new WeakMap(), jsxChildrenParents = /* @__PURE__ */ new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), LocalPromise = Promise, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : function(callback) {
        LocalPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      }, currentView = null, writtenBytes = 0, textEncoder = new TextEncoder(), assign2 = Object.assign, hasOwnProperty = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      ), aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]), hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      }, ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties$1 = {}, rARIA$1 = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel$1 = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), didWarnValueNull = false, possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, matchHtmlRegExp = /["'&<>]/, uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals = React5.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
        pending: false,
        data: null,
        method: null,
        action: null
      }), previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: previousDispatcher.f,
        r: previousDispatcher.r,
        D: /* @__PURE__ */ __name(function(href) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              if (!resumableState.dnsResources.hasOwnProperty(href)) {
                resumableState.dnsResources[href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
                  JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
                JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.D(href);
        }, "D"),
        C: /* @__PURE__ */ __name(function(href, crossOrigin) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
              if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
                resumableState.connectResources[bucket][href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
                  JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
                  if ("string" === typeof crossOrigin) {
                    var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(
                      crossOrigin,
                      "crossOrigin"
                    );
                    JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
                  }
                  JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
                }
                JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
                  rel: "preconnect",
                  href,
                  crossOrigin
                }), renderState.preconnects.add(bucket));
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.C(href, crossOrigin);
        }, "C"),
        L: /* @__PURE__ */ __name(function(href, as2, options) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (as2 && href) {
              switch (as2) {
                case "image":
                  if (options) {
                    var imageSrcSet = options.imageSrcSet;
                    var imageSizes = options.imageSizes;
                    var fetchPriority = options.fetchPriority;
                  }
                  var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
                  if (resumableState.imageResources.hasOwnProperty(key)) return;
                  resumableState.imageResources[key] = PRELOAD_NO_CREDS;
                  resumableState = renderState.headers;
                  var header;
                  resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as2, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
                    resumableState,
                    assign2(
                      {
                        rel: "preload",
                        href: imageSrcSet ? void 0 : href,
                        as: as2
                      },
                      options
                    )
                  ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
                  break;
                case "style":
                  if (resumableState.styleResources.hasOwnProperty(href)) return;
                  imageSrcSet = [];
                  pushLinkImpl(
                    imageSrcSet,
                    assign2({ rel: "preload", href, as: as2 }, options)
                  );
                  resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  renderState.preloads.stylesheets.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  break;
                case "script":
                  if (resumableState.scriptResources.hasOwnProperty(href)) return;
                  imageSrcSet = [];
                  renderState.preloads.scripts.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  pushLinkImpl(
                    imageSrcSet,
                    assign2({ rel: "preload", href, as: as2 }, options)
                  );
                  resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  break;
                default:
                  if (resumableState.unknownResources.hasOwnProperty(as2)) {
                    if (imageSrcSet = resumableState.unknownResources[as2], imageSrcSet.hasOwnProperty(href))
                      return;
                  } else
                    imageSrcSet = {}, resumableState.unknownResources[as2] = imageSrcSet;
                  imageSrcSet[href] = PRELOAD_NO_CREDS;
                  if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as2 && (key = getPreloadAsHeader(href, as2, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                    renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
                  else
                    switch (resumableState = [], href = assign2(
                      { rel: "preload", href, as: as2 },
                      options
                    ), pushLinkImpl(resumableState, href), as2) {
                      case "font":
                        renderState.fontPreloads.add(resumableState);
                        break;
                      default:
                        renderState.bulkPreloads.add(resumableState);
                    }
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.L(href, as2, options);
        }, "L"),
        m: /* @__PURE__ */ __name(function(href, options) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              var as2 = options && "string" === typeof options.as ? options.as : "script";
              switch (as2) {
                case "script":
                  if (resumableState.moduleScriptResources.hasOwnProperty(href))
                    return;
                  as2 = [];
                  resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  renderState.preloads.moduleScripts.set(href, as2);
                  break;
                default:
                  if (resumableState.moduleUnknownResources.hasOwnProperty(as2)) {
                    var resources = resumableState.unknownResources[as2];
                    if (resources.hasOwnProperty(href)) return;
                  } else
                    resources = {}, resumableState.moduleUnknownResources[as2] = resources;
                  as2 = [];
                  resources[href] = PRELOAD_NO_CREDS;
              }
              pushLinkImpl(
                as2,
                assign2({ rel: "modulepreload", href }, options)
              );
              renderState.bulkPreloads.add(as2);
              enqueueFlush(request);
            }
          } else previousDispatcher.m(href, options);
        }, "m"),
        X: /* @__PURE__ */ __name(function(src, options) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.scriptResources.hasOwnProperty(
                src
              ) ? resumableState.scriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options = assign2({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
            }
          } else previousDispatcher.X(src, options);
        }, "X"),
        S: /* @__PURE__ */ __name(function(href, precedence, options) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              precedence = precedence || "default";
              var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
              resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
                precedence: stringToChunk(escapeTextForBrowser(precedence)),
                rules: [],
                hrefs: [],
                sheets: /* @__PURE__ */ new Map()
              }, renderState.styles.set(precedence, styleQueue)), precedence = {
                state: PENDING$1,
                props: assign2(
                  {
                    rel: "stylesheet",
                    href,
                    "data-precedence": precedence
                  },
                  options
                )
              }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
            }
          } else previousDispatcher.S(href, precedence, options);
        }, "S"),
        M: /* @__PURE__ */ __name(function(src, options) {
          var request = resolveRequest();
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options = assign2(
                { src, type: "module", async: true },
                options
              ), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
            }
          } else previousDispatcher.M(src, options);
        }, "M")
      };
      var NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, EXISTS = null, PRELOAD_NO_CREDS = [];
      Object.freeze(PRELOAD_NO_CREDS);
      stringToPrecomputedChunk('"></template>');
      var startInlineScript = stringToPrecomputedChunk("<script>"), endInlineScript = stringToPrecomputedChunk("<\/script>"), startScriptSrc = stringToPrecomputedChunk('<script src="'), startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'), scriptNonce = stringToPrecomputedChunk('" nonce="'), scriptIntegirty = stringToPrecomputedChunk('" integrity="'), scriptCrossOrigin = stringToPrecomputedChunk('" crossorigin="'), endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>'), scriptRegex = /(<\/|<)(s)(cript)/gi, importMapScriptStart = stringToPrecomputedChunk(
        '<script type="importmap">'
      ), importMapScriptEnd = stringToPrecomputedChunk("<\/script>");
      var didWarnForNewBooleanPropsWithEmptyValue = {};
      var NoContribution = 0, ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, textSeparator = stringToPrecomputedChunk("<!-- -->"), styleNameCache = /* @__PURE__ */ new Map(), styleAttributeStart = stringToPrecomputedChunk(' style="'), styleAssign = stringToPrecomputedChunk(":"), styleSeparator = stringToPrecomputedChunk(";"), attributeSeparator = stringToPrecomputedChunk(" "), attributeAssign = stringToPrecomputedChunk('="'), attributeEnd = stringToPrecomputedChunk('"'), attributeEmptyString = stringToPrecomputedChunk('=""'), actionJavaScriptURL = stringToPrecomputedChunk(
        escapeTextForBrowser(
          "javascript:throw new Error('React form unexpectedly submitted.')"
        )
      ), startHiddenInputChunk = stringToPrecomputedChunk('<input type="hidden"'), endOfStartTag = stringToPrecomputedChunk(">"), endOfStartTagSelfClosing = stringToPrecomputedChunk("/>"), didWarnDefaultInputValue = false, didWarnDefaultChecked = false, didWarnDefaultSelectValue = false, didWarnDefaultTextareaValue = false, didWarnInvalidOptionChildren = false, didWarnInvalidOptionInnerHTML = false, didWarnSelectedSetOnOption = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""'), formReplayingRuntimeScript = stringToPrecomputedChunk(
        `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`
      ), formStateMarkerIsMatching = stringToPrecomputedChunk("<!--F!-->"), formStateMarkerIsNotMatching = stringToPrecomputedChunk("<!--F-->"), styleRegex = /(<\/|<)(s)(tyle)/gi, leadingNewline = stringToPrecomputedChunk("\n"), VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map(), doctypeChunk = stringToPrecomputedChunk("<!DOCTYPE html>"), endTagCache = /* @__PURE__ */ new Map(), placeholder1 = stringToPrecomputedChunk('<template id="'), placeholder2 = stringToPrecomputedChunk('"></template>'), startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->"), startPendingSuspenseBoundary1 = stringToPrecomputedChunk(
        '<!--$?--><template id="'
      ), startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>'), startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->"), endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->"), clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template"), clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"'), clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="'), clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="'), clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="'), clientRenderedSuspenseBoundaryError1D = stringToPrecomputedChunk(' data-cstck="'), clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>"), boundaryPreambleContributionChunkStart = stringToPrecomputedChunk("<!--"), boundaryPreambleContributionChunkEnd = stringToPrecomputedChunk("-->"), startSegmentHTML = stringToPrecomputedChunk('<div hidden id="'), startSegmentHTML2 = stringToPrecomputedChunk('">'), endSegmentHTML = stringToPrecomputedChunk("</div>"), startSegmentSVG = stringToPrecomputedChunk(
        '<svg aria-hidden="true" style="display:none" id="'
      ), startSegmentSVG2 = stringToPrecomputedChunk('">'), endSegmentSVG = stringToPrecomputedChunk("</svg>"), startSegmentMathML = stringToPrecomputedChunk(
        '<math aria-hidden="true" style="display:none" id="'
      ), startSegmentMathML2 = stringToPrecomputedChunk('">'), endSegmentMathML = stringToPrecomputedChunk("</math>"), startSegmentTable = stringToPrecomputedChunk('<table hidden id="'), startSegmentTable2 = stringToPrecomputedChunk('">'), endSegmentTable = stringToPrecomputedChunk("</table>"), startSegmentTableBody = stringToPrecomputedChunk(
        '<table hidden><tbody id="'
      ), startSegmentTableBody2 = stringToPrecomputedChunk('">'), endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>"), startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="'), startSegmentTableRow2 = stringToPrecomputedChunk('">'), endSegmentTableRow = stringToPrecomputedChunk("</tr></table>"), startSegmentColGroup = stringToPrecomputedChunk(
        '<table hidden><colgroup id="'
      ), startSegmentColGroup2 = stringToPrecomputedChunk('">'), endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>"), completeSegmentScript1Full = stringToPrecomputedChunk(
        '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
      ), completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'), completeSegmentScript2 = stringToPrecomputedChunk('","'), completeSegmentScriptEnd = stringToPrecomputedChunk('")<\/script>');
      stringToPrecomputedChunk('<template data-rsi="" data-sid="');
      stringToPrecomputedChunk('" data-pid="');
      var completeBoundaryScript1Full = stringToPrecomputedChunk(
        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("'
      ), completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'), completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(
        '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
      ), completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(
        '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("'
      ), completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR("'), completeBoundaryScript2 = stringToPrecomputedChunk('","'), completeBoundaryScript3a = stringToPrecomputedChunk('",'), completeBoundaryScript3b = stringToPrecomputedChunk('"'), completeBoundaryScriptEnd = stringToPrecomputedChunk(")<\/script>");
      stringToPrecomputedChunk('<template data-rci="" data-bid="');
      stringToPrecomputedChunk('<template data-rri="" data-bid="');
      stringToPrecomputedChunk('" data-sid="');
      stringToPrecomputedChunk('" data-sty="');
      var clientRenderScript1Full = stringToPrecomputedChunk(
        '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
      ), clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'), clientRenderScript1A = stringToPrecomputedChunk('"'), clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","), clientRenderScriptEnd = stringToPrecomputedChunk(")<\/script>");
      stringToPrecomputedChunk('<template data-rxi="" data-bid="');
      stringToPrecomputedChunk('" data-dgst="');
      stringToPrecomputedChunk('" data-msg="');
      stringToPrecomputedChunk('" data-stck="');
      stringToPrecomputedChunk('" data-cstck="');
      var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g, regexForJSStringsInScripts = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen1 = stringToPrecomputedChunk(
        '<style media="not all" data-precedence="'
      ), lateStyleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="'), lateStyleTagResourceOpen3 = stringToPrecomputedChunk('">'), lateStyleTagTemplateClose = stringToPrecomputedChunk("</style>"), currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true, stylesheetFlushingQueue = [], styleTagResourceOpen1 = stringToPrecomputedChunk(
        '<style data-precedence="'
      ), styleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="'), spaceSeparator = stringToPrecomputedChunk(" "), styleTagResourceOpen3 = stringToPrecomputedChunk('">'), styleTagResourceClose = stringToPrecomputedChunk("</style>"), arrayFirstOpenBracket = stringToPrecomputedChunk("["), arraySubsequentOpenBracket = stringToPrecomputedChunk(",["), arrayInterstitial = stringToPrecomputedChunk(","), arrayCloseBracket = stringToPrecomputedChunk("]"), PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g, bind2 = Function.prototype.bind, supportsRequestStorage = "function" === typeof AsyncLocalStorage, requestStorage = supportsRequestStorage ? new AsyncLocalStorage() : null, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), emptyContextObject = {};
      Object.freeze(emptyContextObject);
      var rendererSigil = {};
      var currentActiveSnapshot = null, didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
      var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
      var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
      var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
      var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
      var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
      var classComponentUpdater = {
        enqueueSetState: /* @__PURE__ */ __name(function(inst, payload, callback) {
          var internals = inst._reactInternals;
          null === internals.queue ? warnNoop(inst, "setState") : (internals.queue.push(payload), void 0 !== callback && null !== callback && warnOnInvalidCallback(callback));
        }, "enqueueSetState"),
        enqueueReplaceState: /* @__PURE__ */ __name(function(inst, payload, callback) {
          inst = inst._reactInternals;
          inst.replace = true;
          inst.queue = [payload];
          void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        }, "enqueueReplaceState"),
        enqueueForceUpdate: /* @__PURE__ */ __name(function(inst, callback) {
          null === inst._reactInternals.queue ? warnNoop(inst, "forceUpdate") : void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        }, "enqueueForceUpdate")
      }, emptyTreeContext = { id: 1, overflow: "" }, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, SuspenseException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
      ), suspendedThenable = null, objectIs = "function" === typeof Object.is ? Object.is : is, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0, isInHookUserCodeInDev = false, currentHookNameInDev, HooksDispatcher = {
        readContext,
        use: /* @__PURE__ */ __name(function(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then)
              return unwrapThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE)
              return readContext(usable);
          }
          throw Error(
            "An unsupported type was passed to use(): " + String(usable)
          );
        }, "use"),
        useContext: /* @__PURE__ */ __name(function(context) {
          currentHookNameInDev = "useContext";
          resolveCurrentlyRenderingComponent();
          return context._currentValue;
        }, "useContext"),
        useMemo: useMemo2,
        useReducer,
        useRef: /* @__PURE__ */ __name(function(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          return null === previousRef ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook.memoizedState = initialValue) : previousRef;
        }, "useRef"),
        useState: /* @__PURE__ */ __name(function(initialState) {
          currentHookNameInDev = "useState";
          return useReducer(basicStateReducer, initialState);
        }, "useState"),
        useInsertionEffect: noop$1,
        useLayoutEffect: noop$1,
        useCallback: /* @__PURE__ */ __name(function(callback, deps) {
          return useMemo2(function() {
            return callback;
          }, deps);
        }, "useCallback"),
        useImperativeHandle: noop$1,
        useEffect: noop$1,
        useDebugValue: noop$1,
        useDeferredValue: /* @__PURE__ */ __name(function(value, initialValue) {
          resolveCurrentlyRenderingComponent();
          return void 0 !== initialValue ? initialValue : value;
        }, "useDeferredValue"),
        useTransition: /* @__PURE__ */ __name(function() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }, "useTransition"),
        useId: /* @__PURE__ */ __name(function() {
          var treeId = currentlyRenderingTask.treeContext;
          var overflow = treeId.overflow;
          treeId = treeId.id;
          treeId = (treeId & ~(1 << 32 - clz32(treeId) - 1)).toString(32) + overflow;
          var resumableState = currentResumableState;
          if (null === resumableState)
            throw Error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component."
            );
          overflow = localIdCounter++;
          treeId = "\xAB" + resumableState.idPrefix + "R" + treeId;
          0 < overflow && (treeId += "H" + overflow.toString(32));
          return treeId + "\xBB";
        }, "useId"),
        useSyncExternalStore: /* @__PURE__ */ __name(function(subscribe, getSnapshot, getServerSnapshot) {
          if (void 0 === getServerSnapshot)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          return getServerSnapshot();
        }, "useSyncExternalStore"),
        useOptimistic: /* @__PURE__ */ __name(function(passthrough) {
          resolveCurrentlyRenderingComponent();
          return [passthrough, unsupportedSetOptimisticState];
        }, "useOptimistic"),
        useActionState,
        useFormState: useActionState,
        useHostTransitionStatus: /* @__PURE__ */ __name(function() {
          resolveCurrentlyRenderingComponent();
          return NotPending;
        }, "useHostTransitionStatus"),
        useMemoCache: /* @__PURE__ */ __name(function(size) {
          for (var data4 = Array(size), i = 0; i < size; i++)
            data4[i] = REACT_MEMO_CACHE_SENTINEL;
          return data4;
        }, "useMemoCache"),
        useCacheRefresh: /* @__PURE__ */ __name(function() {
          return unsupportedRefresh;
        }, "useCacheRefresh")
      }, currentResumableState = null, currentTaskInDEV = null, DefaultAsyncDispatcher = {
        getCacheForType: /* @__PURE__ */ __name(function() {
          throw Error("Not implemented.");
        }, "getCacheForType"),
        getOwner: /* @__PURE__ */ __name(function() {
          return null === currentTaskInDEV ? null : currentTaskInDEV.componentStack;
        }, "getOwner")
      }, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      disabledLog.__reactDisabledLog = true;
      var prefix3, suffix, reentry = false;
      var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
      var callComponent = {
        react_stack_bottom_frame: /* @__PURE__ */ __name(function(Component, props, secondArg) {
          return Component(props, secondArg);
        }, "react_stack_bottom_frame")
      }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
        react_stack_bottom_frame: /* @__PURE__ */ __name(function(instance) {
          return instance.render();
        }, "react_stack_bottom_frame")
      }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callLazyInit = {
        react_stack_bottom_frame: /* @__PURE__ */ __name(function(lazy) {
          var init2 = lazy._init;
          return init2(lazy._payload);
        }, "react_stack_bottom_frame")
      }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), lastResetTime = 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        var getCurrentTime = /* @__PURE__ */ __name(function() {
          return localPerformance.now();
        }, "getCurrentTime");
      } else {
        var localDate = Date;
        getCurrentTime = /* @__PURE__ */ __name(function() {
          return localDate.now();
        }, "getCurrentTime");
      }
      var CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, POSTPONED = 5, CLOSED = 14, currentRequest = null, didWarnAboutBadClass = {}, didWarnAboutContextTypes = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = false, didWarnAboutGenerators = false, didWarnAboutMaps = false;
      ensureCorrectIsomorphicReactVersion();
      ensureCorrectIsomorphicReactVersion();
      exports.prerender = function(children, options) {
        return new Promise(function(resolve, reject) {
          var onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;
          onHeaders && (onHeadersImpl = /* @__PURE__ */ __name(function(headersDescriptor) {
            onHeaders(new Headers(headersDescriptor));
          }, "onHeadersImpl"));
          var resources = createResumableState(
            options ? options.identifierPrefix : void 0,
            options ? options.unstable_externalRuntimeSrc : void 0,
            options ? options.bootstrapScriptContent : void 0,
            options ? options.bootstrapScripts : void 0,
            options ? options.bootstrapModules : void 0
          ), request = createPrerenderRequest(
            children,
            resources,
            createRenderState(
              resources,
              void 0,
              options ? options.unstable_externalRuntimeSrc : void 0,
              options ? options.importMap : void 0,
              onHeadersImpl,
              options ? options.maxHeadersLength : void 0
            ),
            createRootFormatContext(options ? options.namespaceURI : void 0),
            options ? options.progressiveChunkSize : void 0,
            options ? options.onError : void 0,
            function() {
              var result = {
                prelude: new ReadableStream(
                  {
                    type: "bytes",
                    pull: /* @__PURE__ */ __name(function(controller) {
                      startFlowing(request, controller);
                    }, "pull"),
                    cancel: /* @__PURE__ */ __name(function(reason) {
                      request.destination = null;
                      abort(request, reason);
                    }, "cancel")
                  },
                  { highWaterMark: 0 }
                )
              };
              resolve(result);
            },
            void 0,
            void 0,
            reject,
            options ? options.onPostpone : void 0
          );
          if (options && options.signal) {
            var signal = options.signal;
            if (signal.aborted) abort(request, signal.reason);
            else {
              var listener = /* @__PURE__ */ __name(function() {
                abort(request, signal.reason);
                signal.removeEventListener("abort", listener);
              }, "listener");
              signal.addEventListener("abort", listener);
            }
          }
          startWork(request);
        });
      };
      exports.renderToReadableStream = function(children, options) {
        return new Promise(function(resolve, reject) {
          var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
            onAllReady = res;
            onFatalError = rej;
          }), onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;
          onHeaders && (onHeadersImpl = /* @__PURE__ */ __name(function(headersDescriptor) {
            onHeaders(new Headers(headersDescriptor));
          }, "onHeadersImpl"));
          var resumableState = createResumableState(
            options ? options.identifierPrefix : void 0,
            options ? options.unstable_externalRuntimeSrc : void 0,
            options ? options.bootstrapScriptContent : void 0,
            options ? options.bootstrapScripts : void 0,
            options ? options.bootstrapModules : void 0
          ), request = createRequest(
            children,
            resumableState,
            createRenderState(
              resumableState,
              options ? options.nonce : void 0,
              options ? options.unstable_externalRuntimeSrc : void 0,
              options ? options.importMap : void 0,
              onHeadersImpl,
              options ? options.maxHeadersLength : void 0
            ),
            createRootFormatContext(options ? options.namespaceURI : void 0),
            options ? options.progressiveChunkSize : void 0,
            options ? options.onError : void 0,
            onAllReady,
            function() {
              var stream = new ReadableStream(
                {
                  type: "bytes",
                  pull: /* @__PURE__ */ __name(function(controller) {
                    startFlowing(request, controller);
                  }, "pull"),
                  cancel: /* @__PURE__ */ __name(function(reason) {
                    request.destination = null;
                    abort(request, reason);
                  }, "cancel")
                },
                { highWaterMark: 0 }
              );
              stream.allReady = allReady;
              resolve(stream);
            },
            function(error) {
              allReady.catch(function() {
              });
              reject(error);
            },
            onFatalError,
            options ? options.onPostpone : void 0,
            options ? options.formState : void 0
          );
          if (options && options.signal) {
            var signal = options.signal;
            if (signal.aborted) abort(request, signal.reason);
            else {
              var listener = /* @__PURE__ */ __name(function() {
                abort(request, signal.reason);
                signal.removeEventListener("abort", listener);
              }, "listener");
              signal.addEventListener("abort", listener);
            }
          }
          startWork(request);
        });
      };
      exports.version = "19.1.1";
    })();
  }
});

// node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
var require_react_dom_server_legacy_browser_development = __commonJS({
  "node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js"(exports) {
    "use strict";
    (function() {
      function styleReplacer(match, prefix4, s, suffix2) {
        return "" + prefix4 + ("s" === s ? "\\73 " : "\\53 ") + suffix2;
      }
      __name(styleReplacer, "styleReplacer");
      function scriptReplacer(match, prefix4, s, suffix2) {
        return "" + prefix4 + ("s" === s ? "\\u0073" : "\\u0053") + suffix2;
      }
      __name(scriptReplacer, "scriptReplacer");
      function objectName(object) {
        return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
          return p0;
        });
      }
      __name(objectName, "objectName");
      function describeKeyForErrorMessage(key) {
        var encodedKey = JSON.stringify(key);
        return '"' + key + '"' === encodedKey ? key : encodedKey;
      }
      __name(describeKeyForErrorMessage, "describeKeyForErrorMessage");
      function describeValueForErrorMessage(value) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(
              10 >= value.length ? value : value.slice(0, 10) + "..."
            );
          case "object":
            if (isArrayImpl(value)) return "[...]";
            if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
              return "client";
            value = objectName(value);
            return "Object" === value ? "{...}" : value;
          case "function":
            return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
          default:
            return String(value);
        }
      }
      __name(describeValueForErrorMessage, "describeValueForErrorMessage");
      function describeElementType(type2) {
        if ("string" === typeof type2) return type2;
        switch (type2) {
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if ("object" === typeof type2)
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeElementType(type2.render);
            case REACT_MEMO_TYPE:
              return describeElementType(type2.type);
            case REACT_LAZY_TYPE:
              var payload = type2._payload;
              type2 = type2._init;
              try {
                return describeElementType(type2(payload));
              } catch (x) {
              }
          }
        return "";
      }
      __name(describeElementType, "describeElementType");
      function describeObjectForErrorMessage(objectOrArray, expandedName) {
        var objKind = objectName(objectOrArray);
        if ("Object" !== objKind && "Array" !== objKind) return objKind;
        var start = -1, length = 0;
        if (isArrayImpl(objectOrArray))
          if (jsxChildrenParents.has(objectOrArray)) {
            var type2 = jsxChildrenParents.get(objectOrArray);
            objKind = "<" + describeElementType(type2) + ">";
            for (var i = 0; i < objectOrArray.length; i++) {
              var value = objectOrArray[i];
              value = "string" === typeof value ? value : "object" === typeof value && null !== value ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
              "" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
            }
            objKind += "</" + describeElementType(type2) + ">";
          } else {
            objKind = "[";
            for (type2 = 0; type2 < objectOrArray.length; type2++)
              0 < type2 && (objKind += ", "), i = objectOrArray[type2], i = "object" === typeof i && null !== i ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), "" + type2 === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + "...";
            objKind += "]";
          }
        else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
          objKind = "<" + describeElementType(objectOrArray.type) + "/>";
        else {
          if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
          if (jsxPropsParents.has(objectOrArray)) {
            objKind = jsxPropsParents.get(objectOrArray);
            objKind = "<" + (describeElementType(objKind) || "...");
            type2 = Object.keys(objectOrArray);
            for (i = 0; i < type2.length; i++) {
              objKind += " ";
              value = type2[i];
              objKind += describeKeyForErrorMessage(value) + "=";
              var _value2 = objectOrArray[value];
              var _substr2 = value === expandedName && "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
              "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
              value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
            }
            objKind += ">";
          } else {
            objKind = "{";
            type2 = Object.keys(objectOrArray);
            for (i = 0; i < type2.length; i++)
              0 < i && (objKind += ", "), value = type2[i], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = "object" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
            objKind += "}";
          }
        }
        return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), "\n  " + objKind + "\n  " + objectOrArray) : "\n  " + objKind;
      }
      __name(describeObjectForErrorMessage, "describeObjectForErrorMessage");
      function murmurhash3_32_gc(key, seed) {
        var remainder = key.length & 3;
        var bytes = key.length - remainder;
        var h1 = seed;
        for (seed = 0; seed < bytes; ) {
          var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
          ++seed;
          k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
          h1 ^= k1;
          h1 = h1 << 13 | h1 >>> 19;
          h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
          h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
          case 2:
            k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
          case 1:
            k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
        }
        h1 ^= key.length;
        h1 ^= h1 >>> 16;
        h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        return (h1 ^ h1 >>> 16) >>> 0;
      }
      __name(murmurhash3_32_gc, "murmurhash3_32_gc");
      function typeName(value) {
        return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
      }
      __name(typeName, "typeName");
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), false;
        } catch (e2) {
          return true;
        }
      }
      __name(willCoercionThrow, "willCoercionThrow");
      function testStringCoercion(value) {
        return "" + value;
      }
      __name(testStringCoercion, "testStringCoercion");
      function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
            attributeName,
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkAttributeStringCoercion, "checkAttributeStringCoercion");
      function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
            propName,
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkCSSPropertyStringCoercion, "checkCSSPropertyStringCoercion");
      function checkHtmlStringCoercion(value) {
        if (willCoercionThrow(value))
          return console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(value)
          ), testStringCoercion(value);
      }
      __name(checkHtmlStringCoercion, "checkHtmlStringCoercion");
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
          return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        console.error("Invalid attribute name: `%s`", attributeName);
        return false;
      }
      __name(isAttributeNameSafe, "isAttributeNameSafe");
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
        ) : console.error(
          "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
        ));
        props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
          "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
        );
      }
      __name(checkControlledValueProps, "checkControlledValueProps");
      function validateProperty$1(tagName, name) {
        if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
          return true;
        if (rARIACamel$1.test(name)) {
          tagName = "aria-" + name.slice(4).toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
              name
            ), warnedProperties$1[name] = true;
          if (name !== tagName)
            return console.error(
              "Invalid ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true;
        }
        if (rARIA$1.test(name)) {
          tagName = name.toLowerCase();
          tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
          if (null == tagName) return warnedProperties$1[name] = true, false;
          name !== tagName && (console.error(
            "Unknown ARIA attribute `%s`. Did you mean `%s`?",
            name,
            tagName
          ), warnedProperties$1[name] = true);
        }
        return true;
      }
      __name(validateProperty$1, "validateProperty$1");
      function validateProperties$2(type2, props) {
        var invalidProps = [], key;
        for (key in props)
          validateProperty$1(type2, key) || invalidProps.push(key);
        props = invalidProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === invalidProps.length ? console.error(
          "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type2
        ) : 1 < invalidProps.length && console.error(
          "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
          props,
          type2
        );
      }
      __name(validateProperties$2, "validateProperties$2");
      function validateProperty(tagName, name, value, eventRegistry) {
        if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
          return true;
        var lowerCasedName = name.toLowerCase();
        if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
          return console.error(
            "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
          ), warnedProperties[name] = true;
        if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
          return true;
        if (null != eventRegistry) {
          tagName = eventRegistry.possibleRegistrationNames;
          if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
            return true;
          eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
          if (null != eventRegistry)
            return console.error(
              "Invalid event handler property `%s`. Did you mean `%s`?",
              name,
              eventRegistry
            ), warnedProperties[name] = true;
          if (EVENT_NAME_REGEX.test(name))
            return console.error(
              "Unknown event handler property `%s`. It will be ignored.",
              name
            ), warnedProperties[name] = true;
        } else if (EVENT_NAME_REGEX.test(name))
          return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
            "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
            name
          ), warnedProperties[name] = true;
        if (rARIA.test(name) || rARIACamel.test(name)) return true;
        if ("innerhtml" === lowerCasedName)
          return console.error(
            "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
          ), warnedProperties[name] = true;
        if ("aria" === lowerCasedName)
          return console.error(
            "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
          ), warnedProperties[name] = true;
        if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
          return console.error(
            "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
            typeof value
          ), warnedProperties[name] = true;
        if ("number" === typeof value && isNaN(value))
          return console.error(
            "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
            name
          ), warnedProperties[name] = true;
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
          if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
            return console.error(
              "Invalid DOM property `%s`. Did you mean `%s`?",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
        } else if (name !== lowerCasedName)
          return console.error(
            "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
            name,
            lowerCasedName
          ), warnedProperties[name] = true;
        switch (name) {
          case "dangerouslySetInnerHTML":
          case "children":
          case "style":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            return true;
          case "innerText":
          case "textContent":
            return true;
        }
        switch (typeof value) {
          case "boolean":
            switch (name) {
              case "autoFocus":
              case "checked":
              case "multiple":
              case "muted":
              case "selected":
              case "contentEditable":
              case "spellCheck":
              case "draggable":
              case "value":
              case "autoReverse":
              case "externalResourcesRequired":
              case "focusable":
              case "preserveAlpha":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "capture":
              case "download":
              case "inert":
                return true;
              default:
                lowerCasedName = name.toLowerCase().slice(0, 5);
                if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                  return true;
                value ? console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                  value,
                  name,
                  name,
                  value,
                  name
                ) : console.error(
                  'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                  value,
                  name,
                  name,
                  value,
                  name,
                  name,
                  name
                );
                return warnedProperties[name] = true;
            }
          case "function":
          case "symbol":
            return warnedProperties[name] = true, false;
          case "string":
            if ("false" === value || "true" === value) {
              switch (name) {
                case "checked":
                case "selected":
                case "multiple":
                case "muted":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "inert":
                  break;
                default:
                  return true;
              }
              console.error(
                "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                value,
                name,
                "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                name,
                value
              );
              warnedProperties[name] = true;
            }
        }
        return true;
      }
      __name(validateProperty, "validateProperty");
      function warnUnknownProperties(type2, props, eventRegistry) {
        var unknownProps = [], key;
        for (key in props)
          validateProperty(type2, key, props[key], eventRegistry) || unknownProps.push(key);
        props = unknownProps.map(function(prop) {
          return "`" + prop + "`";
        }).join(", ");
        1 === unknownProps.length ? console.error(
          "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type2
        ) : 1 < unknownProps.length && console.error(
          "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
          props,
          type2
        );
      }
      __name(warnUnknownProperties, "warnUnknownProperties");
      function camelize(string) {
        return string.replace(hyphenPattern, function(_, character) {
          return character.toUpperCase();
        });
      }
      __name(camelize, "camelize");
      function escapeTextForBrowser(text) {
        if ("boolean" === typeof text || "number" === typeof text || "bigint" === typeof text)
          return "" + text;
        checkHtmlStringCoercion(text);
        text = "" + text;
        var match = matchHtmlRegExp.exec(text);
        if (match) {
          var html = "", index, lastIndex = 0;
          for (index = match.index; index < text.length; index++) {
            switch (text.charCodeAt(index)) {
              case 34:
                match = "&quot;";
                break;
              case 38:
                match = "&amp;";
                break;
              case 39:
                match = "&#x27;";
                break;
              case 60:
                match = "&lt;";
                break;
              case 62:
                match = "&gt;";
                break;
              default:
                continue;
            }
            lastIndex !== index && (html += text.slice(lastIndex, index));
            lastIndex = index + 1;
            html += match;
          }
          text = lastIndex !== index ? html + text.slice(lastIndex, index) : html;
        }
        return text;
      }
      __name(escapeTextForBrowser, "escapeTextForBrowser");
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      __name(sanitizeURL, "sanitizeURL");
      function escapeEntireInlineScriptContent(scriptText) {
        checkHtmlStringCoercion(scriptText);
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      __name(escapeEntireInlineScriptContent, "escapeEntireInlineScriptContent");
      function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        return {
          idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
          nextFormID: 0,
          streamingFormat: 0,
          bootstrapScriptContent,
          bootstrapScripts,
          bootstrapModules,
          instructions: NothingSent,
          hasBody: false,
          hasHtml: false,
          unknownResources: {},
          dnsResources: {},
          connectResources: { default: {}, anonymous: {}, credentials: {} },
          imageResources: {},
          styleResources: {},
          scriptResources: {},
          moduleUnknownResources: {},
          moduleScriptResources: {}
        };
      }
      __name(createResumableState, "createResumableState");
      function createPreambleState() {
        return {
          htmlChunks: null,
          headChunks: null,
          bodyChunks: null,
          contribution: NoContribution
        };
      }
      __name(createPreambleState, "createPreambleState");
      function createFormatContext(insertionMode, selectedValue, tagScope) {
        return {
          insertionMode,
          selectedValue,
          tagScope
        };
      }
      __name(createFormatContext, "createFormatContext");
      function getChildFormatContext(parentContext, type2, props) {
        switch (type2) {
          case "noscript":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 1
            );
          case "select":
            return createFormatContext(
              HTML_MODE,
              null != props.value ? props.value : props.defaultValue,
              parentContext.tagScope
            );
          case "svg":
            return createFormatContext(SVG_MODE, null, parentContext.tagScope);
          case "picture":
            return createFormatContext(
              HTML_MODE,
              null,
              parentContext.tagScope | 2
            );
          case "math":
            return createFormatContext(MATHML_MODE, null, parentContext.tagScope);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null, parentContext.tagScope);
          case "table":
            return createFormatContext(
              HTML_TABLE_MODE,
              null,
              parentContext.tagScope
            );
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(
              HTML_TABLE_BODY_MODE,
              null,
              parentContext.tagScope
            );
          case "colgroup":
            return createFormatContext(
              HTML_COLGROUP_MODE,
              null,
              parentContext.tagScope
            );
          case "tr":
            return createFormatContext(
              HTML_TABLE_ROW_MODE,
              null,
              parentContext.tagScope
            );
          case "head":
            if (parentContext.insertionMode < HTML_MODE)
              return createFormatContext(
                HTML_HEAD_MODE,
                null,
                parentContext.tagScope
              );
            break;
          case "html":
            if (parentContext.insertionMode === ROOT_HTML_MODE)
              return createFormatContext(
                HTML_HTML_MODE,
                null,
                parentContext.tagScope
              );
        }
        return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext(HTML_MODE, null, parentContext.tagScope) : parentContext;
      }
      __name(getChildFormatContext, "getChildFormatContext");
      function pushStyleAttribute(target, style) {
        if ("object" !== typeof style)
          throw Error(
            "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
          );
        var isFirst = true, styleName;
        for (styleName in style)
          if (hasOwnProperty.call(style, styleName)) {
            var styleValue = style[styleName];
            if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
              if (0 === styleName.indexOf("--")) {
                var nameChunk = escapeTextForBrowser(styleName);
                checkCSSPropertyStringCoercion(styleValue, styleName);
                styleValue = escapeTextForBrowser(("" + styleValue).trim());
              } else {
                nameChunk = styleName;
                var value = styleValue;
                if (-1 < nameChunk.indexOf("-")) {
                  var name = nameChunk;
                  warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                    "Unsupported style property %s. Did you mean %s?",
                    name,
                    camelize(name.replace(msPattern$1, "ms-"))
                  ));
                } else if (badVendoredStyleNamePattern.test(nameChunk))
                  name = nameChunk, warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error(
                    "Unsupported vendor-prefixed style property %s. Did you mean %s?",
                    name,
                    name.charAt(0).toUpperCase() + name.slice(1)
                  ));
                else if (badStyleValueWithSemicolonPattern.test(value)) {
                  name = nameChunk;
                  var value$jscomp$0 = value;
                  warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = true, console.error(
                    `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
                    name,
                    value$jscomp$0.replace(
                      badStyleValueWithSemicolonPattern,
                      ""
                    )
                  ));
                }
                "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
                  "`NaN` is an invalid value for the `%s` css style property.",
                  nameChunk
                )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
                  "`Infinity` is an invalid value for the `%s` css style property.",
                  nameChunk
                )));
                nameChunk = styleName;
                value = styleNameCache.get(nameChunk);
                void 0 !== value ? nameChunk = value : (value = escapeTextForBrowser(
                  nameChunk.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
                ), styleNameCache.set(nameChunk, value), nameChunk = value);
                "number" === typeof styleValue ? styleValue = 0 === styleValue || unitlessNumbers.has(styleName) ? "" + styleValue : styleValue + "px" : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = escapeTextForBrowser(
                  ("" + styleValue).trim()
                ));
              }
              isFirst ? (isFirst = false, target.push(
                styleAttributeStart,
                nameChunk,
                styleAssign,
                styleValue
              )) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
            }
          }
        isFirst || target.push(attributeEnd);
      }
      __name(pushStyleAttribute, "pushStyleAttribute");
      function pushBooleanAttribute(target, name, value) {
        value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name, attributeEmptyString);
      }
      __name(pushBooleanAttribute, "pushBooleanAttribute");
      function pushStringAttribute(target, name, value) {
        "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(
          attributeSeparator,
          name,
          attributeAssign,
          escapeTextForBrowser(value),
          attributeEnd
        );
      }
      __name(pushStringAttribute, "pushStringAttribute");
      function pushAdditionalFormField(value, key) {
        this.push('<input type="hidden"');
        validateAdditionalFormField(value);
        pushStringAttribute(this, "name", key);
        pushStringAttribute(this, "value", value);
        this.push(endOfStartTagSelfClosing);
      }
      __name(pushAdditionalFormField, "pushAdditionalFormField");
      function validateAdditionalFormField(value) {
        if ("string" !== typeof value)
          throw Error(
            "File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration."
          );
      }
      __name(validateAdditionalFormField, "validateAdditionalFormField");
      function getCustomFormFields(resumableState, formAction) {
        if ("function" === typeof formAction.$$FORM_ACTION) {
          var id = resumableState.nextFormID++;
          resumableState = resumableState.idPrefix + id;
          try {
            var customFields = formAction.$$FORM_ACTION(resumableState);
            if (customFields) {
              var formData = customFields.data;
              null != formData && formData.forEach(validateAdditionalFormField);
            }
            return customFields;
          } catch (x) {
            if ("object" === typeof x && null !== x && "function" === typeof x.then)
              throw x;
            console.error(
              "Failed to serialize an action for progressive enhancement:\n%s",
              x
            );
          }
        }
        return null;
      }
      __name(getCustomFormFields, "getCustomFormFields");
      function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
        var formData = null;
        if ("function" === typeof formAction) {
          null === name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          ));
          null === formEncType && null === formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          ));
          null === formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ));
          var customFields = getCustomFormFields(resumableState, formAction);
          null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(
            attributeSeparator,
            "formAction",
            attributeAssign,
            actionJavaScriptURL,
            attributeEnd
          ), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));
        }
        null != name && pushAttribute(target, "name", name);
        null != formAction && pushAttribute(target, "formAction", formAction);
        null != formEncType && pushAttribute(target, "formEncType", formEncType);
        null != formMethod && pushAttribute(target, "formMethod", formMethod);
        null != formTarget && pushAttribute(target, "formTarget", formTarget);
        return formData;
      }
      __name(pushFormActionAttribute, "pushFormActionAttribute");
      function pushAttribute(target, name, value) {
        switch (name) {
          case "className":
            pushStringAttribute(target, "class", value);
            break;
          case "tabIndex":
            pushStringAttribute(target, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            pushStringAttribute(target, name, value);
            break;
          case "style":
            pushStyleAttribute(target, value);
            break;
          case "src":
          case "href":
            if ("" === value) {
              "src" === name ? console.error(
                'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name,
                name
              ) : console.error(
                'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                name,
                name
              );
              break;
            }
          case "action":
          case "formAction":
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              name,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "ref":
            break;
          case "autoFocus":
          case "multiple":
          case "muted":
            pushBooleanAttribute(target, name.toLowerCase(), value);
            break;
          case "xlinkHref":
            if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
              break;
            checkAttributeStringCoercion(value, name);
            value = sanitizeURL("" + value);
            target.push(
              attributeSeparator,
              "xlink:href",
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              name,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "inert":
            "" !== value || didWarnForNewBooleanPropsWithEmptyValue[name] || (didWarnForNewBooleanPropsWithEmptyValue[name] = true, console.error(
              "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
              name
            ));
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, name, attributeEmptyString);
            break;
          case "capture":
          case "download":
            true === value ? target.push(attributeSeparator, name, attributeEmptyString) : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(
              attributeSeparator,
              name,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(
              attributeSeparator,
              name,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "rowSpan":
          case "start":
            "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(
              attributeSeparator,
              name,
              attributeAssign,
              escapeTextForBrowser(value),
              attributeEnd
            );
            break;
          case "xlinkActuate":
            pushStringAttribute(target, "xlink:actuate", value);
            break;
          case "xlinkArcrole":
            pushStringAttribute(target, "xlink:arcrole", value);
            break;
          case "xlinkRole":
            pushStringAttribute(target, "xlink:role", value);
            break;
          case "xlinkShow":
            pushStringAttribute(target, "xlink:show", value);
            break;
          case "xlinkTitle":
            pushStringAttribute(target, "xlink:title", value);
            break;
          case "xlinkType":
            pushStringAttribute(target, "xlink:type", value);
            break;
          case "xmlBase":
            pushStringAttribute(target, "xml:base", value);
            break;
          case "xmlLang":
            pushStringAttribute(target, "xml:lang", value);
            break;
          case "xmlSpace":
            pushStringAttribute(target, "xml:space", value);
            break;
          default:
            if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
              if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {
                switch (typeof value) {
                  case "function":
                  case "symbol":
                    return;
                  case "boolean":
                    var prefix4 = name.toLowerCase().slice(0, 5);
                    if ("data-" !== prefix4 && "aria-" !== prefix4) return;
                }
                target.push(
                  attributeSeparator,
                  name,
                  attributeAssign,
                  escapeTextForBrowser(value),
                  attributeEnd
                );
              }
            }
        }
      }
      __name(pushAttribute, "pushAttribute");
      function pushInnerHTML(target, innerHTML, children) {
        if (null != innerHTML) {
          if (null != children)
            throw Error(
              "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
            );
          if ("object" !== typeof innerHTML || !("__html" in innerHTML))
            throw Error(
              "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
            );
          innerHTML = innerHTML.__html;
          null !== innerHTML && void 0 !== innerHTML && (checkHtmlStringCoercion(innerHTML), target.push("" + innerHTML));
        }
      }
      __name(pushInnerHTML, "pushInnerHTML");
      function checkSelectProp(props, propName) {
        var value = props[propName];
        null != value && (value = isArrayImpl(value), props.multiple && !value ? console.error(
          "The `%s` prop supplied to <select> must be an array if `multiple` is true.",
          propName
        ) : !props.multiple && value && console.error(
          "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.",
          propName
        ));
      }
      __name(checkSelectProp, "checkSelectProp");
      function flattenOptionChildren(children) {
        var content = "";
        React5.Children.forEach(children, function(child) {
          null != child && (content += child, didWarnInvalidOptionChildren || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || (didWarnInvalidOptionChildren = true, console.error(
            "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
          )));
        });
        return content;
      }
      __name(flattenOptionChildren, "flattenOptionChildren");
      function injectFormReplayingRuntime(resumableState, renderState) {
        (resumableState.instructions & 16) === NothingSent && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(
          renderState.startInlineScript,
          formReplayingRuntimeScript,
          "<\/script>"
        ));
      }
      __name(injectFormReplayingRuntime, "injectFormReplayingRuntime");
      function pushLinkImpl(target, props) {
        target.push(startChunkForTag("link"));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      __name(pushLinkImpl, "pushLinkImpl");
      function escapeStyleTextContent(styleText) {
        checkHtmlStringCoercion(styleText);
        return ("" + styleText).replace(styleRegex, styleReplacer);
      }
      __name(escapeStyleTextContent, "escapeStyleTextContent");
      function pushSelfClosing(target, props, tag) {
        target.push(startChunkForTag(tag));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      __name(pushSelfClosing, "pushSelfClosing");
      function pushTitleImpl(target, props) {
        target.push(startChunkForTag("title"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
        "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser("" + props));
        pushInnerHTML(target, innerHTML, children);
        target.push(endChunkForTag("title"));
        return null;
      }
      __name(pushTitleImpl, "pushTitleImpl");
      function pushScriptImpl(target, props) {
        target.push(startChunkForTag("script"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        null != children && "string" !== typeof children && (props = "number" === typeof children ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error(
          "A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.",
          props
        ));
        pushInnerHTML(target, innerHTML, children);
        "string" === typeof children && target.push(escapeEntireInlineScriptContent(children));
        target.push(endChunkForTag("script"));
        return null;
      }
      __name(pushScriptImpl, "pushScriptImpl");
      function pushStartSingletonElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return tag;
      }
      __name(pushStartSingletonElement, "pushStartSingletonElement");
      function pushStartGenericElement(target, props, tag) {
        target.push(startChunkForTag(tag));
        var innerHTML = tag = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  tag = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, propKey, propValue);
              }
          }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, tag);
        return "string" === typeof tag ? (target.push(escapeTextForBrowser(tag)), null) : tag;
      }
      __name(pushStartGenericElement, "pushStartGenericElement");
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (void 0 === tagStartChunk) {
          if (!VALID_TAG_REGEX.test(tag)) throw Error("Invalid tag: " + tag);
          tagStartChunk = "<" + tag;
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      __name(startChunkForTag, "startChunkForTag");
      function pushStartInstance(target$jscomp$0, type2, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {
        validateProperties$2(type2, props);
        "input" !== type2 && "textarea" !== type2 && "select" !== type2 || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type2 && props.multiple ? console.error(
          "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
          type2
        ) : console.error(
          "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
          type2
        ));
        b: if (-1 === type2.indexOf("-")) var JSCompiler_inline_result = false;
        else
          switch (type2) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              JSCompiler_inline_result = false;
              break b;
            default:
              JSCompiler_inline_result = true;
          }
        JSCompiler_inline_result || "string" === typeof props.is || warnUnknownProperties(type2, props, null);
        !props.suppressContentEditableWarning && props.contentEditable && null != props.children && console.error(
          "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
        );
        formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && -1 === type2.indexOf("-") && type2.toLowerCase() !== type2 && console.error(
          "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
          type2
        );
        switch (type2) {
          case "div":
          case "span":
          case "svg":
          case "path":
            break;
          case "a":
            target$jscomp$0.push(startChunkForTag("a"));
            var children = null, innerHTML = null, propKey;
            for (propKey in props)
              if (hasOwnProperty.call(props, propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "children":
                      children = propValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML = propValue;
                      break;
                    case "href":
                      "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                      break;
                    default:
                      pushAttribute(target$jscomp$0, propKey, propValue);
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML, children);
            if ("string" === typeof children) {
              target$jscomp$0.push(escapeTextForBrowser(children));
              var JSCompiler_inline_result$jscomp$0 = null;
            } else JSCompiler_inline_result$jscomp$0 = children;
            return JSCompiler_inline_result$jscomp$0;
          case "g":
          case "p":
          case "li":
            break;
          case "select":
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultSelectValue || (console.error(
              "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultSelectValue = true);
            target$jscomp$0.push(startChunkForTag("select"));
            var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
            for (propKey$jscomp$0 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$0)) {
                var propValue$jscomp$0 = props[propKey$jscomp$0];
                if (null != propValue$jscomp$0)
                  switch (propKey$jscomp$0) {
                    case "children":
                      children$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$0 = propValue$jscomp$0;
                      break;
                    case "defaultValue":
                    case "value":
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$0,
                        propValue$jscomp$0
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
            return children$jscomp$0;
          case "option":
            var selectedValue = formatContext.selectedValue;
            target$jscomp$0.push(startChunkForTag("option"));
            var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
            for (propKey$jscomp$1 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$1)) {
                var propValue$jscomp$1 = props[propKey$jscomp$1];
                if (null != propValue$jscomp$1)
                  switch (propKey$jscomp$1) {
                    case "children":
                      children$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "selected":
                      selected = propValue$jscomp$1;
                      didWarnSelectedSetOnOption || (console.error(
                        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
                      ), didWarnSelectedSetOnOption = true);
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$1 = propValue$jscomp$1;
                      break;
                    case "value":
                      value = propValue$jscomp$1;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$1,
                        propValue$jscomp$1
                      );
                  }
              }
            if (null != selectedValue) {
              if (null !== value) {
                checkAttributeStringCoercion(value, "value");
                var stringValue = "" + value;
              } else
                null === innerHTML$jscomp$1 || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = true, console.error(
                  "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
                )), stringValue = flattenOptionChildren(children$jscomp$1);
              if (isArrayImpl(selectedValue))
                for (var i = 0; i < selectedValue.length; i++) {
                  if (checkAttributeStringCoercion(selectedValue[i], "value"), "" + selectedValue[i] === stringValue) {
                    target$jscomp$0.push(' selected=""');
                    break;
                  }
                }
              else
                checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(' selected=""');
            } else selected && target$jscomp$0.push(' selected=""');
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
            return children$jscomp$1;
          case "textarea":
            checkControlledValueProps("textarea", props);
            void 0 === props.value || void 0 === props.defaultValue || didWarnDefaultTextareaValue || (console.error(
              "Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnDefaultTextareaValue = true);
            target$jscomp$0.push(startChunkForTag("textarea"));
            var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
            for (propKey$jscomp$2 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$2)) {
                var propValue$jscomp$2 = props[propKey$jscomp$2];
                if (null != propValue$jscomp$2)
                  switch (propKey$jscomp$2) {
                    case "children":
                      children$jscomp$2 = propValue$jscomp$2;
                      break;
                    case "value":
                      value$jscomp$0 = propValue$jscomp$2;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$jscomp$2;
                      break;
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$2,
                        propValue$jscomp$2
                      );
                  }
              }
            null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
            target$jscomp$0.push(endOfStartTag);
            if (null != children$jscomp$2) {
              console.error(
                "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
              );
              if (null != value$jscomp$0)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children$jscomp$2)) {
                if (1 < children$jscomp$2.length)
                  throw Error("<textarea> can only have at most one child.");
                checkHtmlStringCoercion(children$jscomp$2[0]);
                value$jscomp$0 = "" + children$jscomp$2[0];
              }
              checkHtmlStringCoercion(children$jscomp$2);
              value$jscomp$0 = "" + children$jscomp$2;
            }
            "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);
            null !== value$jscomp$0 && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(escapeTextForBrowser("" + value$jscomp$0)));
            return null;
          case "input":
            checkControlledValueProps("input", props);
            target$jscomp$0.push(startChunkForTag("input"));
            var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
            for (propKey$jscomp$3 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$3)) {
                var propValue$jscomp$3 = props[propKey$jscomp$3];
                if (null != propValue$jscomp$3)
                  switch (propKey$jscomp$3) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    case "name":
                      name = propValue$jscomp$3;
                      break;
                    case "formAction":
                      formAction = propValue$jscomp$3;
                      break;
                    case "formEncType":
                      formEncType = propValue$jscomp$3;
                      break;
                    case "formMethod":
                      formMethod = propValue$jscomp$3;
                      break;
                    case "formTarget":
                      formTarget = propValue$jscomp$3;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$jscomp$3;
                      break;
                    case "defaultValue":
                      defaultValue$jscomp$0 = propValue$jscomp$3;
                      break;
                    case "checked":
                      checked = propValue$jscomp$3;
                      break;
                    case "value":
                      value$jscomp$1 = propValue$jscomp$3;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$3,
                        propValue$jscomp$3
                      );
                  }
              }
            null === formAction || "image" === props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'An input can only specify a formAction along with type="submit" or type="image".'
            ));
            var formData = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction,
              formEncType,
              formMethod,
              formTarget,
              name
            );
            null === checked || null === defaultChecked || didWarnDefaultChecked || (console.error(
              "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultChecked = true);
            null === value$jscomp$1 || null === defaultValue$jscomp$0 || didWarnDefaultInputValue || (console.error(
              "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              "A component",
              props.type
            ), didWarnDefaultInputValue = true);
            null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
            null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
            target$jscomp$0.push(endOfStartTagSelfClosing);
            null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
            return null;
          case "button":
            target$jscomp$0.push(startChunkForTag("button"));
            var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
            for (propKey$jscomp$4 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$4)) {
                var propValue$jscomp$4 = props[propKey$jscomp$4];
                if (null != propValue$jscomp$4)
                  switch (propKey$jscomp$4) {
                    case "children":
                      children$jscomp$3 = propValue$jscomp$4;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$2 = propValue$jscomp$4;
                      break;
                    case "name":
                      name$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formAction":
                      formAction$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formEncType":
                      formEncType$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formMethod":
                      formMethod$jscomp$0 = propValue$jscomp$4;
                      break;
                    case "formTarget":
                      formTarget$jscomp$0 = propValue$jscomp$4;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$4,
                        propValue$jscomp$4
                      );
                  }
              }
            null === formAction$jscomp$0 || null == props.type || "submit" === props.type || didWarnFormActionType || (didWarnFormActionType = true, console.error(
              'A button can only specify a formAction along with type="submit" or no type.'
            ));
            var formData$jscomp$0 = pushFormActionAttribute(
              target$jscomp$0,
              resumableState,
              renderState,
              formAction$jscomp$0,
              formEncType$jscomp$0,
              formMethod$jscomp$0,
              formTarget$jscomp$0,
              name$jscomp$0
            );
            target$jscomp$0.push(endOfStartTag);
            null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
            if ("string" === typeof children$jscomp$3) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));
              var JSCompiler_inline_result$jscomp$1 = null;
            } else JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
            return JSCompiler_inline_result$jscomp$1;
          case "form":
            target$jscomp$0.push(startChunkForTag("form"));
            var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
            for (propKey$jscomp$5 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$5)) {
                var propValue$jscomp$5 = props[propKey$jscomp$5];
                if (null != propValue$jscomp$5)
                  switch (propKey$jscomp$5) {
                    case "children":
                      children$jscomp$4 = propValue$jscomp$5;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$3 = propValue$jscomp$5;
                      break;
                    case "action":
                      formAction$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "encType":
                      formEncType$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "method":
                      formMethod$jscomp$1 = propValue$jscomp$5;
                      break;
                    case "target":
                      formTarget$jscomp$1 = propValue$jscomp$5;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$5,
                        propValue$jscomp$5
                      );
                  }
              }
            var formData$jscomp$1 = null, formActionName = null;
            if ("function" === typeof formAction$jscomp$1) {
              null === formEncType$jscomp$1 && null === formMethod$jscomp$1 || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              ));
              null === formTarget$jscomp$1 || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ));
              var customFields = getCustomFormFields(
                resumableState,
                formAction$jscomp$1
              );
              null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
                attributeSeparator,
                "action",
                attributeAssign,
                actionJavaScriptURL,
                attributeEnd
              ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
            }
            null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
            null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
            null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
            null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
            target$jscomp$0.push(endOfStartTag);
            null !== formActionName && (target$jscomp$0.push('<input type="hidden"'), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), null != formData$jscomp$1 && formData$jscomp$1.forEach(
              pushAdditionalFormField,
              target$jscomp$0
            ));
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
            if ("string" === typeof children$jscomp$4) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));
              var JSCompiler_inline_result$jscomp$2 = null;
            } else JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
            return JSCompiler_inline_result$jscomp$2;
          case "menuitem":
            target$jscomp$0.push(startChunkForTag("menuitem"));
            for (var propKey$jscomp$6 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$6)) {
                var propValue$jscomp$6 = props[propKey$jscomp$6];
                if (null != propValue$jscomp$6)
                  switch (propKey$jscomp$6) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "menuitems cannot have `children` nor `dangerouslySetInnerHTML`."
                      );
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$6,
                        propValue$jscomp$6
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            return null;
          case "object":
            target$jscomp$0.push(startChunkForTag("object"));
            var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
            for (propKey$jscomp$7 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$7)) {
                var propValue$jscomp$7 = props[propKey$jscomp$7];
                if (null != propValue$jscomp$7)
                  switch (propKey$jscomp$7) {
                    case "children":
                      children$jscomp$5 = propValue$jscomp$7;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$4 = propValue$jscomp$7;
                      break;
                    case "data":
                      checkAttributeStringCoercion(propValue$jscomp$7, "data");
                      var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                      if ("" === sanitizedValue) {
                        console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          propKey$jscomp$7,
                          propKey$jscomp$7
                        );
                        break;
                      }
                      target$jscomp$0.push(
                        attributeSeparator,
                        "data",
                        attributeAssign,
                        escapeTextForBrowser(sanitizedValue),
                        attributeEnd
                      );
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$7,
                        propValue$jscomp$7
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
            if ("string" === typeof children$jscomp$5) {
              target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));
              var JSCompiler_inline_result$jscomp$3 = null;
            } else JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
            return JSCompiler_inline_result$jscomp$3;
          case "title":
            var insertionMode = formatContext.insertionMode, noscriptTagInScope = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
              Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.",
                children$jscomp$6.length
              ) : "function" === typeof child || "symbol" === typeof child ? console.error(
                "React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.",
                "function" === typeof child ? "a Function" : "a Sybmol"
              ) : child && child.toString === {}.toString && (null != child.$$typeof ? console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML."
              ) : console.error(
                "React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."
              ));
            }
            if (insertionMode === SVG_MODE || noscriptTagInScope || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(
                target$jscomp$0,
                props
              );
            else
              isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = void 0);
            return JSCompiler_inline_result$jscomp$4;
          case "link":
            var rel = props.rel, href = props.href, precedence = props.precedence;
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
              "stylesheet" === rel && "string" === typeof props.precedence && ("string" === typeof href && href || console.error(
                'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.',
                null === href ? "`null`" : void 0 === href ? "`undefined`" : "" === href ? "an empty string" : 'something with type "' + typeof href + '"'
              ));
              pushLinkImpl(target$jscomp$0, props);
              var JSCompiler_inline_result$jscomp$5 = null;
            } else if ("stylesheet" === props.rel)
              if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError) {
                if ("string" === typeof precedence) {
                  if (null != props.disabled)
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.'
                    );
                  else if (props.onLoad || props.onError) {
                    var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
                    console.error(
                      'React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                      propDescription,
                      propDescription
                    );
                  }
                }
                JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                  target$jscomp$0,
                  props
                );
              } else {
                var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(
                  href
                ) ? resumableState.styleResources[href] : void 0;
                if (resourceState !== EXISTS) {
                  resumableState.styleResources[href] = EXISTS;
                  styleQueue || (styleQueue = {
                    precedence: escapeTextForBrowser(precedence),
                    rules: [],
                    hrefs: [],
                    sheets: /* @__PURE__ */ new Map()
                  }, renderState.styles.set(precedence, styleQueue));
                  var resource = {
                    state: PENDING$1,
                    props: assign2({}, props, {
                      "data-precedence": props.precedence,
                      precedence: null
                    })
                  };
                  if (resourceState) {
                    2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                    var preloadResource = renderState.preloads.stylesheets.get(href);
                    preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
                  }
                  styleQueue.sheets.set(href, resource);
                  hoistableState && hoistableState.stylesheets.add(resource);
                } else if (styleQueue) {
                  var _resource = styleQueue.sheets.get(href);
                  _resource && hoistableState && hoistableState.stylesheets.add(_resource);
                }
                textEmbedded && target$jscomp$0.push("<!-- -->");
                JSCompiler_inline_result$jscomp$5 = null;
              }
            else
              props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl(
                target$jscomp$0,
                props
              ) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$5 = isFallback ? null : pushLinkImpl(renderState.hoistableChunks, props));
            return JSCompiler_inline_result$jscomp$5;
          case "script":
            var asyncProp = props.async;
            if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(
                target$jscomp$0,
                props
              );
            else {
              var key = props.src;
              if ("module" === props.type) {
                var resources = resumableState.moduleScriptResources;
                var preloads = renderState.preloads.moduleScripts;
              } else
                resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
              var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
              if (resourceState$jscomp$0 !== EXISTS) {
                resources[key] = EXISTS;
                var scriptProps = props;
                if (resourceState$jscomp$0) {
                  2 === resourceState$jscomp$0.length && (scriptProps = assign2({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
                  var preloadResource$jscomp$0 = preloads.get(key);
                  preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
                }
                var resource$jscomp$0 = [];
                renderState.scripts.add(resource$jscomp$0);
                pushScriptImpl(resource$jscomp$0, scriptProps);
              }
              textEmbedded && target$jscomp$0.push("<!-- -->");
              JSCompiler_inline_result$jscomp$6 = null;
            }
            return JSCompiler_inline_result$jscomp$6;
          case "style":
            var insertionMode$jscomp$0 = formatContext.insertionMode, noscriptTagInScope$jscomp$0 = !!(formatContext.tagScope & 1);
            if (hasOwnProperty.call(props, "children")) {
              var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
              ("function" === typeof child$jscomp$0 || "symbol" === typeof child$jscomp$0 || Array.isArray(child$jscomp$0)) && console.error(
                "React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.",
                "function" === typeof child$jscomp$0 ? "a Function" : "symbol" === typeof child$jscomp$0 ? "a Sybmol" : "an Array"
              );
            }
            var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href;
            if (insertionMode$jscomp$0 === SVG_MODE || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
              target$jscomp$0.push(startChunkForTag("style"));
              var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
              for (propKey$jscomp$8 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$8)) {
                  var propValue$jscomp$8 = props[propKey$jscomp$8];
                  if (null != propValue$jscomp$8)
                    switch (propKey$jscomp$8) {
                      case "children":
                        children$jscomp$8 = propValue$jscomp$8;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$5 = propValue$jscomp$8;
                        break;
                      default:
                        pushAttribute(
                          target$jscomp$0,
                          propKey$jscomp$8,
                          propValue$jscomp$8
                        );
                    }
                }
              target$jscomp$0.push(endOfStartTag);
              var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
              "function" !== typeof child$jscomp$1 && "symbol" !== typeof child$jscomp$1 && null !== child$jscomp$1 && void 0 !== child$jscomp$1 && target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$5,
                children$jscomp$8
              );
              target$jscomp$0.push(endChunkForTag("style"));
              var JSCompiler_inline_result$jscomp$7 = null;
            } else {
              href$jscomp$0.includes(" ") && console.error(
                'React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".',
                href$jscomp$0
              );
              var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0;
              if (resourceState$jscomp$1 !== EXISTS) {
                resumableState.styleResources[href$jscomp$0] = EXISTS;
                resourceState$jscomp$1 && console.error(
                  'React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.',
                  href$jscomp$0
                );
                styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(
                  escapeTextForBrowser(href$jscomp$0)
                ) : (styleQueue$jscomp$0 = {
                  precedence: escapeTextForBrowser(precedence$jscomp$0),
                  rules: [],
                  hrefs: [escapeTextForBrowser(href$jscomp$0)],
                  sheets: /* @__PURE__ */ new Map()
                }, renderState.styles.set(
                  precedence$jscomp$0,
                  styleQueue$jscomp$0
                ));
                var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
                for (propKey$jscomp$9 in props)
                  if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                    var propValue$jscomp$9 = props[propKey$jscomp$9];
                    if (null != propValue$jscomp$9)
                      switch (propKey$jscomp$9) {
                        case "children":
                          children$jscomp$9 = propValue$jscomp$9;
                          break;
                        case "dangerouslySetInnerHTML":
                          innerHTML$jscomp$6 = propValue$jscomp$9;
                      }
                  }
                var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
                "function" !== typeof child$jscomp$2 && "symbol" !== typeof child$jscomp$2 && null !== child$jscomp$2 && void 0 !== child$jscomp$2 && target.push(escapeStyleTextContent(child$jscomp$2));
                pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);
              }
              styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
              textEmbedded && target$jscomp$0.push("<!-- -->");
              JSCompiler_inline_result$jscomp$7 = void 0;
            }
            return JSCompiler_inline_result$jscomp$7;
          case "meta":
            if (formatContext.insertionMode === SVG_MODE || formatContext.tagScope & 1 || null != props.itemProp)
              var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(
                target$jscomp$0,
                props,
                "meta"
              );
            else
              textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$8 = isFallback ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(
                renderState.hoistableChunks,
                props,
                "meta"
              );
            return JSCompiler_inline_result$jscomp$8;
          case "listing":
          case "pre":
            target$jscomp$0.push(startChunkForTag(type2));
            var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
            for (propKey$jscomp$10 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$10)) {
                var propValue$jscomp$10 = props[propKey$jscomp$10];
                if (null != propValue$jscomp$10)
                  switch (propKey$jscomp$10) {
                    case "children":
                      children$jscomp$10 = propValue$jscomp$10;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$7 = propValue$jscomp$10;
                      break;
                    default:
                      pushAttribute(
                        target$jscomp$0,
                        propKey$jscomp$10,
                        propValue$jscomp$10
                      );
                  }
              }
            target$jscomp$0.push(endOfStartTag);
            if (null != innerHTML$jscomp$7) {
              if (null != children$jscomp$10)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
                throw Error(
                  "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                );
              var html = innerHTML$jscomp$7.__html;
              null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline, html) : (checkHtmlStringCoercion(html), target$jscomp$0.push("" + html)));
            }
            "string" === typeof children$jscomp$10 && "\n" === children$jscomp$10[0] && target$jscomp$0.push(leadingNewline);
            return children$jscomp$10;
          case "img":
            var src = props.src, srcSet = props.srcSet;
            if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet) && "low" !== props.fetchPriority && false === !!(formatContext.tagScope & 3) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
              var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
              if (resource$jscomp$1) {
                if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
                  promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
              } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
                resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
                var input = props.crossOrigin;
                var crossOrigin = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
                var headers = renderState.headers, header;
                headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
                  imageSrcSet: props.srcSet,
                  imageSizes: props.sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  nonce: props.nonce,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.refererPolicy
                }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
                  rel: "preload",
                  as: "image",
                  href: srcSet ? void 0 : src,
                  imageSrcSet: srcSet,
                  imageSizes: sizes,
                  crossOrigin,
                  integrity: props.integrity,
                  type: props.type,
                  fetchPriority: props.fetchPriority,
                  referrerPolicy: props.referrerPolicy
                }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
              }
            }
            return pushSelfClosing(target$jscomp$0, props, "img");
          case "base":
          case "area":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "param":
          case "source":
          case "track":
          case "wbr":
            return pushSelfClosing(target$jscomp$0, props, type2);
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            break;
          case "head":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble = preambleState || renderState.preamble;
              if (preamble.headChunks)
                throw Error("The `<head>` tag may only be rendered once.");
              preamble.headChunks = [];
              var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
                preamble.headChunks,
                props,
                "head"
              );
            } else
              JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "head"
              );
            return JSCompiler_inline_result$jscomp$9;
          case "body":
            if (formatContext.insertionMode < HTML_MODE) {
              var preamble$jscomp$0 = preambleState || renderState.preamble;
              if (preamble$jscomp$0.bodyChunks)
                throw Error("The `<body>` tag may only be rendered once.");
              preamble$jscomp$0.bodyChunks = [];
              var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
                preamble$jscomp$0.bodyChunks,
                props,
                "body"
              );
            } else
              JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "body"
              );
            return JSCompiler_inline_result$jscomp$10;
          case "html":
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              var preamble$jscomp$1 = preambleState || renderState.preamble;
              if (preamble$jscomp$1.htmlChunks)
                throw Error("The `<html>` tag may only be rendered once.");
              preamble$jscomp$1.htmlChunks = [doctypeChunk];
              var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
                preamble$jscomp$1.htmlChunks,
                props,
                "html"
              );
            } else
              JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
                target$jscomp$0,
                props,
                "html"
              );
            return JSCompiler_inline_result$jscomp$11;
          default:
            if (-1 !== type2.indexOf("-")) {
              target$jscomp$0.push(startChunkForTag(type2));
              var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
              for (propKey$jscomp$11 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$11)) {
                  var propValue$jscomp$11 = props[propKey$jscomp$11];
                  if (null != propValue$jscomp$11) {
                    var attributeName = propKey$jscomp$11;
                    switch (propKey$jscomp$11) {
                      case "children":
                        children$jscomp$11 = propValue$jscomp$11;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$8 = propValue$jscomp$11;
                        break;
                      case "style":
                        pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                        break;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "ref":
                        break;
                      case "className":
                        attributeName = "class";
                      default:
                        if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                          if (true === propValue$jscomp$11)
                            propValue$jscomp$11 = "";
                          else if ("object" === typeof propValue$jscomp$11)
                            continue;
                          target$jscomp$0.push(
                            attributeSeparator,
                            attributeName,
                            attributeAssign,
                            escapeTextForBrowser(propValue$jscomp$11),
                            attributeEnd
                          );
                        }
                    }
                  }
                }
              target$jscomp$0.push(endOfStartTag);
              pushInnerHTML(
                target$jscomp$0,
                innerHTML$jscomp$8,
                children$jscomp$11
              );
              return children$jscomp$11;
            }
        }
        return pushStartGenericElement(target$jscomp$0, props, type2);
      }
      __name(pushStartInstance, "pushStartInstance");
      function endChunkForTag(tag) {
        var chunk3 = endTagCache.get(tag);
        void 0 === chunk3 && (chunk3 = "</" + tag + ">", endTagCache.set(tag, chunk3));
        return chunk3;
      }
      __name(endChunkForTag, "endChunkForTag");
      function hoistPreambleState(renderState, preambleState) {
        renderState = renderState.preamble;
        null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);
        null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);
        null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);
      }
      __name(hoistPreambleState, "hoistPreambleState");
      function writeBootstrap(destination, renderState) {
        renderState = renderState.bootstrapChunks;
        for (var i = 0; i < renderState.length - 1; i++)
          destination.push(renderState[i]);
        return i < renderState.length ? (i = renderState[i], renderState.length = 0, destination.push(i)) : true;
      }
      __name(writeBootstrap, "writeBootstrap");
      function writeStartPendingSuspenseBoundary(destination, renderState, id) {
        destination.push(startPendingSuspenseBoundary1);
        if (null === id)
          throw Error(
            "An ID must have been assigned before we can complete the boundary."
          );
        destination.push(renderState.boundaryPrefix);
        renderState = id.toString(16);
        destination.push(renderState);
        return destination.push(startPendingSuspenseBoundary2);
      }
      __name(writeStartPendingSuspenseBoundary, "writeStartPendingSuspenseBoundary");
      function writePreambleContribution(destination, preambleState) {
        preambleState = preambleState.contribution;
        preambleState !== NoContribution && (destination.push(boundaryPreambleContributionChunkStart), destination.push("" + preambleState), destination.push(boundaryPreambleContributionChunkEnd));
      }
      __name(writePreambleContribution, "writePreambleContribution");
      function writeStartSegment(destination, renderState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return destination.push(startSegmentHTML), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentHTML2);
          case SVG_MODE:
            return destination.push(startSegmentSVG), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentSVG2);
          case MATHML_MODE:
            return destination.push(startSegmentMathML), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentMathML2);
          case HTML_TABLE_MODE:
            return destination.push(startSegmentTable), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTable2);
          case HTML_TABLE_BODY_MODE:
            return destination.push(startSegmentTableBody), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableBody2);
          case HTML_TABLE_ROW_MODE:
            return destination.push(startSegmentTableRow), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableRow2);
          case HTML_COLGROUP_MODE:
            return destination.push(startSegmentColGroup), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentColGroup2);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      __name(writeStartSegment, "writeStartSegment");
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_HTML_MODE:
          case HTML_HEAD_MODE:
          case HTML_MODE:
            return destination.push(endSegmentHTML);
          case SVG_MODE:
            return destination.push(endSegmentSVG);
          case MATHML_MODE:
            return destination.push(endSegmentMathML);
          case HTML_TABLE_MODE:
            return destination.push(endSegmentTable);
          case HTML_TABLE_BODY_MODE:
            return destination.push(endSegmentTableBody);
          case HTML_TABLE_ROW_MODE:
            return destination.push(endSegmentTableRow);
          case HTML_COLGROUP_MODE:
            return destination.push(endSegmentColGroup);
          default:
            throw Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      __name(writeEndSegment, "writeEndSegment");
      function escapeJSStringsForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInInstructionScripts,
          function(match) {
            switch (match) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      __name(escapeJSStringsForInstructionScripts, "escapeJSStringsForInstructionScripts");
      function escapeJSObjectForInstructionScripts(input) {
        return JSON.stringify(input).replace(
          regexForJSStringsInScripts,
          function(match) {
            switch (match) {
              case "&":
                return "\\u0026";
              case ">":
                return "\\u003e";
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default:
                throw Error(
                  "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
                );
            }
          }
        );
      }
      __name(escapeJSObjectForInstructionScripts, "escapeJSObjectForInstructionScripts");
      function flushStyleTagsLateForBoundary(styleQueue) {
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        0 < rules.length && 0 === hrefs.length && console.error(
          "React expected to have at least one href for an a hoistable style but found none. This is a bug in React."
        );
        var i = 0;
        if (hrefs.length) {
          this.push(lateStyleTagResourceOpen1);
          this.push(styleQueue.precedence);
          for (this.push(lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)
            this.push(hrefs[i]), this.push(spaceSeparator);
          this.push(hrefs[i]);
          this.push(lateStyleTagResourceOpen3);
          for (i = 0; i < rules.length; i++) this.push(rules[i]);
          destinationHasCapacity = this.push(lateStyleTagTemplateClose);
          currentlyRenderingBoundaryHasStylesToHoist = true;
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      __name(flushStyleTagsLateForBoundary, "flushStyleTagsLateForBoundary");
      function hasStylesToHoist(stylesheet) {
        return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
      }
      __name(hasStylesToHoist, "hasStylesToHoist");
      function writeHoistablesForBoundary(destination, hoistableState, renderState) {
        currentlyRenderingBoundaryHasStylesToHoist = false;
        destinationHasCapacity = true;
        hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
        hoistableState.stylesheets.forEach(hasStylesToHoist);
        currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
        return destinationHasCapacity;
      }
      __name(writeHoistablesForBoundary, "writeHoistablesForBoundary");
      function flushResource(resource) {
        for (var i = 0; i < resource.length; i++) this.push(resource[i]);
        resource.length = 0;
      }
      __name(flushResource, "flushResource");
      function flushStyleInPreamble(stylesheet) {
        pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
        for (var i = 0; i < stylesheetFlushingQueue.length; i++)
          this.push(stylesheetFlushingQueue[i]);
        stylesheetFlushingQueue.length = 0;
        stylesheet.state = PREAMBLE;
      }
      __name(flushStyleInPreamble, "flushStyleInPreamble");
      function flushStylesInPreamble(styleQueue) {
        var hasStylesheets = 0 < styleQueue.sheets.size;
        styleQueue.sheets.forEach(flushStyleInPreamble, this);
        styleQueue.sheets.clear();
        var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
        if (!hasStylesheets || hrefs.length) {
          this.push(styleTagResourceOpen1);
          this.push(styleQueue.precedence);
          styleQueue = 0;
          if (hrefs.length) {
            for (this.push(styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++)
              this.push(hrefs[styleQueue]), this.push(spaceSeparator);
            this.push(hrefs[styleQueue]);
          }
          this.push(styleTagResourceOpen3);
          for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
            this.push(rules[styleQueue]);
          this.push(styleTagResourceClose);
          rules.length = 0;
          hrefs.length = 0;
        }
      }
      __name(flushStylesInPreamble, "flushStylesInPreamble");
      function preloadLateStyle(stylesheet) {
        if (stylesheet.state === PENDING$1) {
          stylesheet.state = PRELOADED;
          var props = stylesheet.props;
          pushLinkImpl(stylesheetFlushingQueue, {
            rel: "preload",
            as: "style",
            href: stylesheet.props.href,
            crossOrigin: props.crossOrigin,
            fetchPriority: props.fetchPriority,
            integrity: props.integrity,
            media: props.media,
            hrefLang: props.hrefLang,
            referrerPolicy: props.referrerPolicy
          });
          for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
            this.push(stylesheetFlushingQueue[stylesheet]);
          stylesheetFlushingQueue.length = 0;
        }
      }
      __name(preloadLateStyle, "preloadLateStyle");
      function preloadLateStyles(styleQueue) {
        styleQueue.sheets.forEach(preloadLateStyle, this);
        styleQueue.sheets.clear();
      }
      __name(preloadLateStyles, "preloadLateStyles");
      function writeStyleResourceDependenciesInJS(destination, hoistableState) {
        destination.push(arrayFirstOpenBracket);
        var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
        hoistableState.stylesheets.forEach(function(resource) {
          if (resource.state !== PREAMBLE)
            if (resource.state === LATE)
              destination.push(nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), resource = escapeJSObjectForInstructionScripts("" + resource), destination.push(resource), destination.push(arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
            else {
              destination.push(nextArrayOpenBrackChunk);
              var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
              coercedHref = escapeJSObjectForInstructionScripts(coercedHref);
              destination.push(coercedHref);
              checkAttributeStringCoercion(precedence, "precedence");
              precedence = "" + precedence;
              destination.push(arrayInterstitial);
              precedence = escapeJSObjectForInstructionScripts(precedence);
              destination.push(precedence);
              for (var propKey in props)
                if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
                  switch (propKey) {
                    case "href":
                    case "rel":
                    case "precedence":
                    case "data-precedence":
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        "link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      writeStyleResourceAttributeInJS(
                        destination,
                        propKey,
                        precedence
                      );
                  }
              destination.push(arrayCloseBracket);
              nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
              resource.state = LATE;
            }
        });
        destination.push(arrayCloseBracket);
      }
      __name(writeStyleResourceDependenciesInJS, "writeStyleResourceDependenciesInJS");
      function writeStyleResourceAttributeInJS(destination, name, value) {
        var attributeName = name.toLowerCase();
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        switch (name) {
          case "innerHTML":
          case "dangerouslySetInnerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "style":
          case "ref":
            return;
          case "className":
            attributeName = "class";
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
            break;
          case "hidden":
            if (false === value) return;
            name = "";
            break;
          case "src":
          case "href":
            value = sanitizeURL(value);
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
            break;
          default:
            if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe(name))
              return;
            checkAttributeStringCoercion(value, attributeName);
            name = "" + value;
        }
        destination.push(arrayInterstitial);
        attributeName = escapeJSObjectForInstructionScripts(attributeName);
        destination.push(attributeName);
        destination.push(arrayInterstitial);
        attributeName = escapeJSObjectForInstructionScripts(name);
        destination.push(attributeName);
      }
      __name(writeStyleResourceAttributeInJS, "writeStyleResourceAttributeInJS");
      function createHoistableState() {
        return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set() };
      }
      __name(createHoistableState, "createHoistableState");
      function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
        (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error(
          'Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue',
          href
        );
        resumableState.scriptResources[href] = EXISTS;
        resumableState.moduleScriptResources[href] = EXISTS;
        resumableState = [];
        pushLinkImpl(resumableState, props);
        renderState.bootstrapScripts.add(resumableState);
      }
      __name(preloadBootstrapScriptOrModule, "preloadBootstrapScriptOrModule");
      function adoptPreloadCredentials(target, preloadState) {
        null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
        null == target.integrity && (target.integrity = preloadState[1]);
      }
      __name(adoptPreloadCredentials, "adoptPreloadCredentials");
      function getPreloadAsHeader(href, as2, params) {
        href = escapeHrefForLinkHeaderURLContext(href);
        as2 = escapeStringForLinkHeaderQuotedParamValueContext(as2, "as");
        as2 = "<" + href + '>; rel=preload; as="' + as2 + '"';
        for (var paramName in params)
          hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as2 += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext(
            href,
            paramName
          ) + '"'));
        return as2;
      }
      __name(getPreloadAsHeader, "getPreloadAsHeader");
      function escapeHrefForLinkHeaderURLContext(hrefInput) {
        checkAttributeStringCoercion(hrefInput, "href");
        return ("" + hrefInput).replace(
          regexForHrefInLinkHeaderURLContext,
          escapeHrefForLinkHeaderURLContextReplacer
        );
      }
      __name(escapeHrefForLinkHeaderURLContext, "escapeHrefForLinkHeaderURLContext");
      function escapeHrefForLinkHeaderURLContextReplacer(match) {
        switch (match) {
          case "<":
            return "%3C";
          case ">":
            return "%3E";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      __name(escapeHrefForLinkHeaderURLContextReplacer, "escapeHrefForLinkHeaderURLContextReplacer");
      function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {
        willCoercionThrow(value) && (console.error(
          "The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.",
          name,
          typeName(value)
        ), testStringCoercion(value));
        return ("" + value).replace(
          regexForLinkHeaderQuotedParamValueContext,
          escapeStringForLinkHeaderQuotedParamValueContextReplacer
        );
      }
      __name(escapeStringForLinkHeaderQuotedParamValueContext, "escapeStringForLinkHeaderQuotedParamValueContext");
      function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
        switch (match) {
          case '"':
            return "%22";
          case "'":
            return "%27";
          case ";":
            return "%3B";
          case ",":
            return "%2C";
          case "\n":
            return "%0A";
          case "\r":
            return "%0D";
          default:
            throw Error(
              "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
      __name(escapeStringForLinkHeaderQuotedParamValueContextReplacer, "escapeStringForLinkHeaderQuotedParamValueContextReplacer");
      function hoistStyleQueueDependency(styleQueue) {
        this.styles.add(styleQueue);
      }
      __name(hoistStyleQueueDependency, "hoistStyleQueueDependency");
      function hoistStylesheetDependency(stylesheet) {
        this.stylesheets.add(stylesheet);
      }
      __name(hoistStylesheetDependency, "hoistStylesheetDependency");
      function createRenderState(resumableState, generateStaticMarkup) {
        var idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
        void 0 !== bootstrapScriptContent && bootstrapChunks.push(
          "<script>",
          escapeEntireInlineScriptContent(bootstrapScriptContent),
          "<\/script>"
        );
        idPrefix = {
          placeholderPrefix: idPrefix + "P:",
          segmentPrefix: idPrefix + "S:",
          boundaryPrefix: idPrefix + "B:",
          startInlineScript: "<script>",
          preamble: createPreambleState(),
          externalRuntimeScript: null,
          bootstrapChunks,
          importMapChunks: [],
          onHeaders: void 0,
          headers: null,
          resets: {
            font: {},
            dns: {},
            connect: { default: {}, anonymous: {}, credentials: {} },
            image: {},
            style: {}
          },
          charsetChunks: [],
          viewportChunks: [],
          hoistableChunks: [],
          preconnects: /* @__PURE__ */ new Set(),
          fontPreloads: /* @__PURE__ */ new Set(),
          highImagePreloads: /* @__PURE__ */ new Set(),
          styles: /* @__PURE__ */ new Map(),
          bootstrapScripts: /* @__PURE__ */ new Set(),
          scripts: /* @__PURE__ */ new Set(),
          bulkPreloads: /* @__PURE__ */ new Set(),
          preloads: {
            images: /* @__PURE__ */ new Map(),
            stylesheets: /* @__PURE__ */ new Map(),
            scripts: /* @__PURE__ */ new Map(),
            moduleScripts: /* @__PURE__ */ new Map()
          },
          nonce: void 0,
          hoistableState: null,
          stylesToHoist: false
        };
        if (void 0 !== bootstrapScripts)
          for (bootstrapScriptContent = 0; bootstrapScriptContent < bootstrapScripts.length; bootstrapScriptContent++) {
            var scriptConfig = bootstrapScripts[bootstrapScriptContent], src, crossOrigin = void 0, integrity = void 0, props = {
              rel: "preload",
              as: "script",
              fetchPriority: "low",
              nonce: void 0
            };
            "string" === typeof scriptConfig ? props.href = src = scriptConfig : (props.href = src = scriptConfig.src, props.integrity = integrity = "string" === typeof scriptConfig.integrity ? scriptConfig.integrity : void 0, props.crossOrigin = crossOrigin = "string" === typeof scriptConfig || null == scriptConfig.crossOrigin ? void 0 : "use-credentials" === scriptConfig.crossOrigin ? "use-credentials" : "");
            preloadBootstrapScriptOrModule(resumableState, idPrefix, src, props);
            bootstrapChunks.push('<script src="', escapeTextForBrowser(src));
            "string" === typeof integrity && bootstrapChunks.push(
              '" integrity="',
              escapeTextForBrowser(integrity)
            );
            "string" === typeof crossOrigin && bootstrapChunks.push(
              '" crossorigin="',
              escapeTextForBrowser(crossOrigin)
            );
            bootstrapChunks.push('" async=""><\/script>');
          }
        if (void 0 !== bootstrapModules)
          for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
            bootstrapScriptContent = bootstrapModules[bootstrapScripts], crossOrigin = src = void 0, integrity = {
              rel: "modulepreload",
              fetchPriority: "low",
              nonce: void 0
            }, "string" === typeof bootstrapScriptContent ? integrity.href = scriptConfig = bootstrapScriptContent : (integrity.href = scriptConfig = bootstrapScriptContent.src, integrity.integrity = crossOrigin = "string" === typeof bootstrapScriptContent.integrity ? bootstrapScriptContent.integrity : void 0, integrity.crossOrigin = src = "string" === typeof bootstrapScriptContent || null == bootstrapScriptContent.crossOrigin ? void 0 : "use-credentials" === bootstrapScriptContent.crossOrigin ? "use-credentials" : ""), preloadBootstrapScriptOrModule(
              resumableState,
              idPrefix,
              scriptConfig,
              integrity
            ), bootstrapChunks.push(
              '<script type="module" src="',
              escapeTextForBrowser(scriptConfig)
            ), "string" === typeof crossOrigin && bootstrapChunks.push(
              '" integrity="',
              escapeTextForBrowser(crossOrigin)
            ), "string" === typeof src && bootstrapChunks.push(
              '" crossorigin="',
              escapeTextForBrowser(src)
            ), bootstrapChunks.push('" async=""><\/script>');
        return {
          placeholderPrefix: idPrefix.placeholderPrefix,
          segmentPrefix: idPrefix.segmentPrefix,
          boundaryPrefix: idPrefix.boundaryPrefix,
          startInlineScript: idPrefix.startInlineScript,
          preamble: idPrefix.preamble,
          externalRuntimeScript: idPrefix.externalRuntimeScript,
          bootstrapChunks: idPrefix.bootstrapChunks,
          importMapChunks: idPrefix.importMapChunks,
          onHeaders: idPrefix.onHeaders,
          headers: idPrefix.headers,
          resets: idPrefix.resets,
          charsetChunks: idPrefix.charsetChunks,
          viewportChunks: idPrefix.viewportChunks,
          hoistableChunks: idPrefix.hoistableChunks,
          preconnects: idPrefix.preconnects,
          fontPreloads: idPrefix.fontPreloads,
          highImagePreloads: idPrefix.highImagePreloads,
          styles: idPrefix.styles,
          bootstrapScripts: idPrefix.bootstrapScripts,
          scripts: idPrefix.scripts,
          bulkPreloads: idPrefix.bulkPreloads,
          preloads: idPrefix.preloads,
          stylesToHoist: idPrefix.stylesToHoist,
          generateStaticMarkup
        };
      }
      __name(createRenderState, "createRenderState");
      function pushTextInstance(target, text, renderState, textEmbedded) {
        if (renderState.generateStaticMarkup)
          return target.push(escapeTextForBrowser(text)), false;
        "" === text ? target = textEmbedded : (textEmbedded && target.push("<!-- -->"), target.push(escapeTextForBrowser(text)), target = true);
        return target;
      }
      __name(pushTextInstance, "pushTextInstance");
      function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {
        renderState.generateStaticMarkup || lastPushedText && textEmbedded && target.push("<!-- -->");
      }
      __name(pushSegmentFinale, "pushSegmentFinale");
      function getComponentNameFromType(type2) {
        if (null == type2) return null;
        if ("function" === typeof type2)
          return type2.$$typeof === REACT_CLIENT_REFERENCE ? null : type2.displayName || type2.name || null;
        if ("string" === typeof type2) return type2;
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type2)
          switch ("number" === typeof type2.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type2.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type2.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type2._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type2.render;
              type2 = type2.displayName;
              type2 || (type2 = innerType.displayName || innerType.name || "", type2 = "" !== type2 ? "ForwardRef(" + type2 + ")" : "ForwardRef");
              return type2;
            case REACT_MEMO_TYPE:
              return innerType = type2.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type2._payload;
              type2 = type2._init;
              try {
                return getComponentNameFromType(type2(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      __name(getComponentNameFromType, "getComponentNameFromType");
      function popToNearestCommonAncestor(prev, next) {
        if (prev !== next) {
          prev.context._currentValue2 = prev.parentValue;
          prev = prev.parent;
          var parentNext = next.parent;
          if (null === prev) {
            if (null !== parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
          } else {
            if (null === parentNext)
              throw Error(
                "The stacks must reach the root at the same time. This is a bug in React."
              );
            popToNearestCommonAncestor(prev, parentNext);
          }
          next.context._currentValue2 = next.value;
        }
      }
      __name(popToNearestCommonAncestor, "popToNearestCommonAncestor");
      function popAllPrevious(prev) {
        prev.context._currentValue2 = prev.parentValue;
        prev = prev.parent;
        null !== prev && popAllPrevious(prev);
      }
      __name(popAllPrevious, "popAllPrevious");
      function pushAllNext(next) {
        var parentNext = next.parent;
        null !== parentNext && pushAllNext(parentNext);
        next.context._currentValue2 = next.value;
      }
      __name(pushAllNext, "pushAllNext");
      function popPreviousToCommonLevel(prev, next) {
        prev.context._currentValue2 = prev.parentValue;
        prev = prev.parent;
        if (null === prev)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
      }
      __name(popPreviousToCommonLevel, "popPreviousToCommonLevel");
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (null === parentNext)
          throw Error(
            "The depth must equal at least at zero before reaching the root. This is a bug in React."
          );
        prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
        next.context._currentValue2 = next.value;
      }
      __name(popNextToCommonLevel, "popNextToCommonLevel");
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
      }
      __name(switchContext, "switchContext");
      function warnOnInvalidCallback(callback) {
        if (null !== callback && "function" !== typeof callback) {
          var key = String(callback);
          didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ));
        }
      }
      __name(warnOnInvalidCallback, "warnOnInvalidCallback");
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType(publicInstance) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnAboutNoopUpdateForComponent[warningKey] || (console.error(
          "Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.",
          callerName,
          publicInstance
        ), didWarnAboutNoopUpdateForComponent[warningKey] = true);
      }
      __name(warnNoop, "warnNoop");
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        baseContext = baseContext.overflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          return {
            id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
            overflow: length + baseContext
          };
        }
        return {
          id: 1 << length | index << baseLength | baseIdWithLeadingBit,
          overflow: baseContext
        };
      }
      __name(pushTreeContext, "pushTreeContext");
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      __name(clz32Fallback, "clz32Fallback");
      function noop$2() {
      }
      __name(noop$2, "noop$2");
      function trackUsedThenable(thenableState2, thenable, index) {
        index = thenableState2[index];
        void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            "string" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            ));
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      __name(trackUsedThenable, "trackUsedThenable");
      function getSuspendedThenable() {
        if (null === suspendedThenable)
          throw Error(
            "Expected a suspended thenable. This is a bug in React. Please file an issue."
          );
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      __name(getSuspendedThenable, "getSuspendedThenable");
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      __name(is, "is");
      function resolveCurrentlyRenderingComponent() {
        if (null === currentlyRenderingComponent)
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        isInHookUserCodeInDev && console.error(
          "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
        );
        return currentlyRenderingComponent;
      }
      __name(resolveCurrentlyRenderingComponent, "resolveCurrentlyRenderingComponent");
      function createHook() {
        if (0 < numberOfReRenders)
          throw Error("Rendered more hooks than during the previous render");
        return { memoizedState: null, queue: null, next: null };
      }
      __name(createHook, "createHook");
      function createWorkInProgressHook() {
        null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
        return workInProgressHook;
      }
      __name(createWorkInProgressHook, "createWorkInProgressHook");
      function getThenableStateAfterSuspending() {
        var state2 = thenableState;
        thenableState = null;
        return state2;
      }
      __name(getThenableStateAfterSuspending, "getThenableStateAfterSuspending");
      function resetHooksState() {
        isInHookUserCodeInDev = false;
        currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        workInProgressHook = renderPhaseUpdates = null;
      }
      __name(resetHooksState, "resetHooksState");
      function readContext(context) {
        isInHookUserCodeInDev && console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
        return context._currentValue2;
      }
      __name(readContext, "readContext");
      function basicStateReducer(state2, action) {
        return "function" === typeof action ? action(state2) : action;
      }
      __name(basicStateReducer, "basicStateReducer");
      function useReducer(reducer, initialArg, init2) {
        reducer !== basicStateReducer && (currentHookNameInDev = "useReducer");
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          init2 = workInProgressHook.queue;
          initialArg = init2.dispatch;
          if (null !== renderPhaseUpdates) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(init2);
            if (void 0 !== firstRenderPhaseUpdate) {
              renderPhaseUpdates.delete(init2);
              init2 = workInProgressHook.memoizedState;
              do {
                var action = firstRenderPhaseUpdate.action;
                isInHookUserCodeInDev = true;
                init2 = reducer(init2, action);
                isInHookUserCodeInDev = false;
                firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
              } while (null !== firstRenderPhaseUpdate);
              workInProgressHook.memoizedState = init2;
              return [init2, initialArg];
            }
          }
          return [workInProgressHook.memoizedState, initialArg];
        }
        isInHookUserCodeInDev = true;
        reducer = reducer === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init2 ? init2(initialArg) : initialArg;
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = reducer;
        reducer = workInProgressHook.queue = { last: null, dispatch: null };
        reducer = reducer.dispatch = dispatchAction.bind(
          null,
          currentlyRenderingComponent,
          reducer
        );
        return [workInProgressHook.memoizedState, reducer];
      }
      __name(useReducer, "useReducer");
      function useMemo2(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        if (null !== workInProgressHook) {
          var prevState = workInProgressHook.memoizedState;
          if (null !== prevState && null !== deps) {
            a: {
              var JSCompiler_inline_result = prevState[1];
              if (null === JSCompiler_inline_result)
                console.error(
                  "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
                  currentHookNameInDev
                ), JSCompiler_inline_result = false;
              else {
                deps.length !== JSCompiler_inline_result.length && console.error(
                  "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
                  currentHookNameInDev,
                  "[" + deps.join(", ") + "]",
                  "[" + JSCompiler_inline_result.join(", ") + "]"
                );
                for (var i = 0; i < JSCompiler_inline_result.length && i < deps.length; i++)
                  if (!objectIs(deps[i], JSCompiler_inline_result[i])) {
                    JSCompiler_inline_result = false;
                    break a;
                  }
                JSCompiler_inline_result = true;
              }
            }
            if (JSCompiler_inline_result) return prevState[0];
          }
        }
        isInHookUserCodeInDev = true;
        nextCreate = nextCreate();
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = [nextCreate, deps];
        return nextCreate;
      }
      __name(useMemo2, "useMemo");
      function dispatchAction(componentIdentity, queue, action) {
        if (25 <= numberOfReRenders)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (componentIdentity === currentlyRenderingComponent)
          if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
            renderPhaseUpdates.set(queue, componentIdentity);
          else {
            for (queue = action; null !== queue.next; ) queue = queue.next;
            queue.next = componentIdentity;
          }
      }
      __name(dispatchAction, "dispatchAction");
      function unsupportedStartTransition() {
        throw Error("startTransition cannot be called during server rendering.");
      }
      __name(unsupportedStartTransition, "unsupportedStartTransition");
      function unsupportedSetOptimisticState() {
        throw Error("Cannot update optimistic state while rendering.");
      }
      __name(unsupportedSetOptimisticState, "unsupportedSetOptimisticState");
      function useActionState(action, initialState, permalink) {
        resolveCurrentlyRenderingComponent();
        var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
        if ("function" === typeof action.$$FORM_ACTION) {
          var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
          request = request.formState;
          var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
          if (null !== request && "function" === typeof isSignatureEqual) {
            var postbackKey = request[1];
            isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
              JSON.stringify([
                componentKeyPath,
                null,
                actionStateHookIndex
              ]),
              0
            ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
          }
          var boundAction = action.bind(null, initialState);
          action = /* @__PURE__ */ __name(function(payload) {
            boundAction(payload);
          }, "action");
          "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix4) {
            prefix4 = boundAction.$$FORM_ACTION(prefix4);
            void 0 !== permalink && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix4.action = permalink);
            var formData = prefix4.data;
            formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
              JSON.stringify([
                componentKeyPath,
                null,
                actionStateHookIndex
              ]),
              0
            )), formData.append("$ACTION_KEY", nextPostbackStateKey));
            return prefix4;
          });
          return [initialState, action, false];
        }
        var _boundAction = action.bind(null, initialState);
        return [
          initialState,
          function(payload) {
            _boundAction(payload);
          },
          false
        ];
      }
      __name(useActionState, "useActionState");
      function unwrapThenable(thenable) {
        var index = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index);
      }
      __name(unwrapThenable, "unwrapThenable");
      function unsupportedRefresh() {
        throw Error("Cache cannot be refreshed during server rendering.");
      }
      __name(unsupportedRefresh, "unsupportedRefresh");
      function noop$1() {
      }
      __name(noop$1, "noop$1");
      function disabledLog() {
      }
      __name(disabledLog, "disabledLog");
      function disableLogs() {
        if (0 === disabledDepth) {
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd;
          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
      __name(disableLogs, "disableLogs");
      function reenableLogs() {
        disabledDepth--;
        if (0 === disabledDepth) {
          var props = { configurable: true, enumerable: true, writable: true };
          Object.defineProperties(console, {
            log: assign2({}, props, { value: prevLog }),
            info: assign2({}, props, { value: prevInfo }),
            warn: assign2({}, props, { value: prevWarn }),
            error: assign2({}, props, { value: prevError }),
            group: assign2({}, props, { value: prevGroup }),
            groupCollapsed: assign2({}, props, { value: prevGroupCollapsed }),
            groupEnd: assign2({}, props, { value: prevGroupEnd })
          });
        }
        0 > disabledDepth && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      __name(reenableLogs, "reenableLogs");
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix3)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix3 = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix3 + name + suffix;
      }
      __name(describeBuiltInComponentFrame, "describeBuiltInComponentFrame");
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return "";
        var frame = componentFrameCache.get(fn);
        if (void 0 !== frame) return frame;
        reentry = true;
        frame = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher2 = null;
        previousDispatcher2 = ReactSharedInternals.H;
        ReactSharedInternals.H = null;
        disableLogs();
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: /* @__PURE__ */ __name(function() {
              try {
                if (construct) {
                  var Fake = /* @__PURE__ */ __name(function() {
                    throw Error();
                  }, "Fake");
                  Object.defineProperty(Fake.prototype, "props", {
                    set: /* @__PURE__ */ __name(function() {
                      throw Error();
                    }, "set")
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$0) {
                      control = x$0;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$1) {
                    control = x$1;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }, "DetermineComponentFrameRoot")
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            ); )
              _RunInRootFrame$Deter++;
            if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
              for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                _RunInRootFrame$Deter--;
            for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
              if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                  do
                    if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                      var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                      fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                      "function" === typeof fn && componentFrameCache.set(fn, _frame);
                      return _frame;
                    }
                  while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                }
                break;
              }
          }
        } finally {
          reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
        }
        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
        "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
        return sampleLines;
      }
      __name(describeNativeComponentFrame, "describeNativeComponentFrame");
      function formatOwnerStack(error) {
        var prevPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        error = error.stack;
        Error.prepareStackTrace = prevPrepareStackTrace;
        error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
        prevPrepareStackTrace = error.indexOf("\n");
        -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
        prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
        -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
          "\n",
          prevPrepareStackTrace
        ));
        if (-1 !== prevPrepareStackTrace)
          error = error.slice(0, prevPrepareStackTrace);
        else return "";
        return error;
      }
      __name(formatOwnerStack, "formatOwnerStack");
      function describeComponentStackByType(type2) {
        if ("string" === typeof type2) return describeBuiltInComponentFrame(type2);
        if ("function" === typeof type2)
          return type2.prototype && type2.prototype.isReactComponent ? describeNativeComponentFrame(type2, true) : describeNativeComponentFrame(type2, false);
        if ("object" === typeof type2 && null !== type2) {
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeNativeComponentFrame(type2.render, false);
            case REACT_MEMO_TYPE:
              return describeNativeComponentFrame(type2.type, false);
            case REACT_LAZY_TYPE:
              var lazyComponent = type2, payload = lazyComponent._payload;
              lazyComponent = lazyComponent._init;
              try {
                type2 = lazyComponent(payload);
              } catch (x) {
                return describeBuiltInComponentFrame("Lazy");
              }
              return describeComponentStackByType(type2);
          }
          if ("string" === typeof type2.name)
            return payload = type2.env, describeBuiltInComponentFrame(
              type2.name + (payload ? " [" + payload + "]" : "")
            );
        }
        switch (type2) {
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
        }
        return "";
      }
      __name(describeComponentStackByType, "describeComponentStackByType");
      function defaultErrorHandler(error) {
        if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
          var JSCompiler_inline_result = error.environmentName;
          error = [error].slice(0);
          "string" === typeof error[0] ? error.splice(
            0,
            1,
            "[%s] " + error[0],
            " " + JSCompiler_inline_result + " "
          ) : error.splice(0, 0, "[%s] ", " " + JSCompiler_inline_result + " ");
          error.unshift(console);
          JSCompiler_inline_result = bind2.apply(console.error, error);
          JSCompiler_inline_result();
        } else console.error(error);
        return null;
      }
      __name(defaultErrorHandler, "defaultErrorHandler");
      function noop2() {
      }
      __name(noop2, "noop");
      function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var abortSet = /* @__PURE__ */ new Set();
        this.destination = null;
        this.flushScheduled = false;
        this.resumableState = resumableState;
        this.renderState = renderState;
        this.rootFormatContext = rootFormatContext;
        this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
        this.status = 10;
        this.fatalError = null;
        this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
        this.completedPreambleSegments = this.completedRootSegment = null;
        this.abortableTasks = abortSet;
        this.pingedTasks = [];
        this.clientRenderedBoundaries = [];
        this.completedBoundaries = [];
        this.partialBoundaries = [];
        this.trackedPostpones = null;
        this.onError = void 0 === onError2 ? defaultErrorHandler : onError2;
        this.onPostpone = void 0 === onPostpone ? noop2 : onPostpone;
        this.onAllReady = void 0 === onAllReady ? noop2 : onAllReady;
        this.onShellReady = void 0 === onShellReady ? noop2 : onShellReady;
        this.onShellError = void 0 === onShellError ? noop2 : onShellError;
        this.onFatalError = void 0 === onFatalError ? noop2 : onFatalError;
        this.formState = void 0 === formState ? null : formState;
        this.didWarnForKey = null;
      }
      __name(RequestInstance, "RequestInstance");
      function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
        var now = getCurrentTime();
        1e3 < now - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = now);
        resumableState = new RequestInstance(
          resumableState,
          renderState,
          rootFormatContext,
          progressiveChunkSize,
          onError2,
          onAllReady,
          onShellReady,
          onShellError,
          onFatalError,
          onPostpone,
          formState
        );
        renderState = createPendingSegment(
          resumableState,
          0,
          null,
          rootFormatContext,
          false,
          false
        );
        renderState.parentFlushed = true;
        children = createRenderTask(
          resumableState,
          null,
          children,
          -1,
          null,
          renderState,
          null,
          null,
          resumableState.abortableTasks,
          null,
          rootFormatContext,
          null,
          emptyTreeContext,
          null,
          false,
          emptyContextObject,
          null
        );
        pushComponentStack(children);
        resumableState.pingedTasks.push(children);
        return resumableState;
      }
      __name(createRequest, "createRequest");
      function pingTask(request, task) {
        request.pingedTasks.push(task);
        1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, performWork(request));
      }
      __name(pingTask, "pingTask");
      function createSuspenseBoundary(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
        return {
          status: PENDING,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null,
          contentState: createHoistableState(),
          fallbackState: createHoistableState(),
          contentPreamble,
          fallbackPreamble,
          trackedContentKeyPath: null,
          trackedFallbackNode: null,
          errorMessage: null,
          errorStack: null,
          errorComponentStack: null
        };
      }
      __name(createSuspenseBoundary, "createSuspenseBoundary");
      function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        var task = {
          replay: null,
          node,
          childIndex,
          ping: /* @__PURE__ */ __name(function() {
            return pingTask(request, task);
          }, "ping"),
          blockedBoundary,
          blockedSegment,
          blockedPreamble,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      __name(createRenderTask, "createRenderTask");
      function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, componentStack, isFallback, legacyContext, debugTask) {
        request.allPendingTasks++;
        null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        replay.pendingTasks++;
        var task = {
          replay,
          node,
          childIndex,
          ping: /* @__PURE__ */ __name(function() {
            return pingTask(request, task);
          }, "ping"),
          blockedBoundary,
          blockedSegment: null,
          blockedPreamble: null,
          hoistableState,
          abortSet,
          keyPath,
          formatContext,
          context,
          treeContext,
          componentStack,
          thenableState: thenableState2,
          isFallback
        };
        task.debugTask = debugTask;
        abortSet.add(task);
        return task;
      }
      __name(createReplayTask, "createReplayTask");
      function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          parentFlushed: false,
          id: -1,
          index,
          chunks: [],
          children: [],
          preambleChildren: [],
          parentFormatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      __name(createPendingSegment, "createPendingSegment");
      function getCurrentStackInDEV() {
        if (null === currentTaskInDEV || null === currentTaskInDEV.componentStack)
          return "";
        var componentStack = currentTaskInDEV.componentStack;
        try {
          var info = "";
          if ("string" === typeof componentStack.type)
            info += describeBuiltInComponentFrame(componentStack.type);
          else if ("function" === typeof componentStack.type) {
            if (!componentStack.owner) {
              var JSCompiler_temp_const = info, fn = componentStack.type, name = fn ? fn.displayName || fn.name : "";
              var JSCompiler_inline_result = name ? describeBuiltInComponentFrame(name) : "";
              info = JSCompiler_temp_const + JSCompiler_inline_result;
            }
          } else
            componentStack.owner || (info += describeComponentStackByType(componentStack.type));
          for (; componentStack; )
            JSCompiler_temp_const = null, null != componentStack.debugStack ? JSCompiler_temp_const = formatOwnerStack(
              componentStack.debugStack
            ) : (JSCompiler_inline_result = componentStack, null != JSCompiler_inline_result.stack && (JSCompiler_temp_const = "string" !== typeof JSCompiler_inline_result.stack ? JSCompiler_inline_result.stack = formatOwnerStack(
              JSCompiler_inline_result.stack
            ) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += "\n" + JSCompiler_temp_const);
          var JSCompiler_inline_result$jscomp$0 = info;
        } catch (x) {
          JSCompiler_inline_result$jscomp$0 = "\nError generating stack: " + x.message + "\n" + x.stack;
        }
        return JSCompiler_inline_result$jscomp$0;
      }
      __name(getCurrentStackInDEV, "getCurrentStackInDEV");
      function pushServerComponentStack(task, debugInfo) {
        if (null != debugInfo)
          for (var i = 0; i < debugInfo.length; i++) {
            var componentInfo = debugInfo[i];
            "string" === typeof componentInfo.name && void 0 !== componentInfo.debugStack && (task.componentStack = {
              parent: task.componentStack,
              type: componentInfo,
              owner: componentInfo.owner,
              stack: componentInfo.debugStack
            }, task.debugTask = componentInfo.debugTask);
          }
      }
      __name(pushServerComponentStack, "pushServerComponentStack");
      function pushComponentStack(task) {
        var node = task.node;
        if ("object" === typeof node && null !== node)
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var type2 = node.type, owner = node._owner, stack = node._debugStack;
              pushServerComponentStack(task, node._debugInfo);
              task.debugTask = node._debugTask;
              task.componentStack = {
                parent: task.componentStack,
                type: type2,
                owner,
                stack
              };
              break;
            case REACT_LAZY_TYPE:
              pushServerComponentStack(task, node._debugInfo);
              break;
            default:
              "function" === typeof node.then && pushServerComponentStack(task, node._debugInfo);
          }
      }
      __name(pushComponentStack, "pushComponentStack");
      function getThrownInfo(node$jscomp$0) {
        var errorInfo = {};
        node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
          configurable: true,
          enumerable: true,
          get: /* @__PURE__ */ __name(function() {
            try {
              var info = "", node = node$jscomp$0;
              do
                info += describeComponentStackByType(node.type), node = node.parent;
              while (node);
              var stack = info;
            } catch (x) {
              stack = "\nError generating stack: " + x.message + "\n" + x.stack;
            }
            Object.defineProperty(errorInfo, "componentStack", {
              value: stack
            });
            return stack;
          }, "get")
        });
        return errorInfo;
      }
      __name(getThrownInfo, "getThrownInfo");
      function encodeErrorForBoundary(boundary, digest, error, thrownInfo, wasAborted) {
        boundary.errorDigest = digest;
        error instanceof Error ? (digest = String(error.message), error = String(error.stack)) : (digest = "object" === typeof error && null !== error ? describeObjectForErrorMessage(error) : String(error), error = null);
        wasAborted = wasAborted ? "Switched to client rendering because the server rendering aborted due to:\n\n" : "Switched to client rendering because the server rendering errored:\n\n";
        boundary.errorMessage = wasAborted + digest;
        boundary.errorStack = null !== error ? wasAborted + error : null;
        boundary.errorComponentStack = thrownInfo.componentStack;
      }
      __name(encodeErrorForBoundary, "encodeErrorForBoundary");
      function logRecoverableError(request, error, errorInfo, debugTask) {
        request = request.onError;
        error = debugTask ? debugTask.run(request.bind(null, error, errorInfo)) : request(error, errorInfo);
        if (null != error && "string" !== typeof error)
          console.error(
            'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead',
            typeof error
          );
        else return error;
      }
      __name(logRecoverableError, "logRecoverableError");
      function fatalError(request, error, errorInfo, debugTask) {
        errorInfo = request.onShellError;
        var onFatalError = request.onFatalError;
        debugTask ? (debugTask.run(errorInfo.bind(null, error)), debugTask.run(onFatalError.bind(null, error))) : (errorInfo(error), onFatalError(error));
        null !== request.destination ? (request.status = CLOSED, request.destination.destroy(error)) : (request.status = 13, request.fatalError = error);
      }
      __name(fatalError, "fatalError");
      function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
        var prevThenableState = task.thenableState;
        task.thenableState = null;
        currentlyRenderingComponent = {};
        currentlyRenderingTask = task;
        currentlyRenderingRequest = request;
        currentlyRenderingKeyPath = keyPath;
        isInHookUserCodeInDev = false;
        actionStateCounter = localIdCounter = 0;
        actionStateMatchingIndex = -1;
        thenableIndexCounter = 0;
        thenableState = prevThenableState;
        for (request = callComponentInDEV(Component, props, secondArg); didScheduleRenderPhaseUpdate; )
          didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
        resetHooksState();
        return request;
      }
      __name(renderWithHooks, "renderWithHooks");
      function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
        var didEmitActionStateMarkers = false;
        if (0 !== actionStateCount && null !== request.formState) {
          var segment = task.blockedSegment;
          if (null !== segment) {
            didEmitActionStateMarkers = true;
            segment = segment.chunks;
            for (var i = 0; i < actionStateCount; i++)
              i === actionStateMatchingIndex2 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
          }
        }
        actionStateCount = task.keyPath;
        task.keyPath = keyPath;
        hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
        task.keyPath = actionStateCount;
      }
      __name(finishFunctionComponent, "finishFunctionComponent");
      function renderElement(request, task, keyPath, type2, props, ref) {
        if ("function" === typeof type2)
          if (type2.prototype && type2.prototype.isReactComponent) {
            var newProps = props;
            if ("ref" in props) {
              newProps = {};
              for (var propName in props)
                "ref" !== propName && (newProps[propName] = props[propName]);
            }
            var defaultProps = type2.defaultProps;
            if (defaultProps) {
              newProps === props && (newProps = assign2({}, newProps, props));
              for (var _propName in defaultProps)
                void 0 === newProps[_propName] && (newProps[_propName] = defaultProps[_propName]);
            }
            var resolvedProps = newProps;
            var context = emptyContextObject, contextType = type2.contextType;
            if ("contextType" in type2 && null !== contextType && (void 0 === contextType || contextType.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(type2)) {
              didWarnAboutInvalidateContextType.add(type2);
              var addendum = void 0 === contextType ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof contextType ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              console.error(
                "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
                getComponentNameFromType(type2) || "Component",
                addendum
              );
            }
            "object" === typeof contextType && null !== contextType && (context = contextType._currentValue2);
            var instance = new type2(resolvedProps, context);
            if ("function" === typeof type2.getDerivedStateFromProps && (null === instance.state || void 0 === instance.state)) {
              var componentName = getComponentNameFromType(type2) || "Component";
              didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error(
                "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
                componentName,
                null === instance.state ? "null" : "undefined",
                componentName
              ));
            }
            if ("function" === typeof type2.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate) {
              var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
              "function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning ? foundWillMountName = "componentWillMount" : "function" === typeof instance.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount");
              "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" === typeof instance.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
              "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
                var _componentName = getComponentNameFromType(type2) || "Component", newApiName = "function" === typeof type2.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(
                  _componentName
                ), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _componentName,
                  newApiName,
                  null !== foundWillMountName ? "\n  " + foundWillMountName : "",
                  null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            var name = getComponentNameFromType(type2) || "Component";
            instance.render || (type2.prototype && "function" === typeof type2.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              name
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              name
            ));
            !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              name
            );
            instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              name
            );
            instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              name
            );
            type2.childContextTypes && !didWarnAboutChildContextTypes.has(type2) && (didWarnAboutChildContextTypes.add(type2), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              name
            ));
            type2.contextTypes && !didWarnAboutContextTypes$1.has(type2) && (didWarnAboutContextTypes$1.add(type2), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              name
            ));
            "function" === typeof instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              name
            );
            type2.prototype && type2.prototype.isPureReactComponent && "undefined" !== typeof instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(type2) || "A pure component"
            );
            "function" === typeof instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              name
            );
            "function" === typeof instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              name
            );
            "function" === typeof instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              name
            );
            "function" === typeof instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              name
            );
            var hasMutatedProps = instance.props !== resolvedProps;
            void 0 !== instance.props && hasMutatedProps && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              name
            );
            instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              name,
              name
            );
            "function" !== typeof instance.getSnapshotBeforeUpdate || "function" === typeof instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type2) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type2), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(type2)
            ));
            "function" === typeof instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name
            );
            "function" === typeof instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              name
            );
            "function" === typeof type2.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              name
            );
            var state2 = instance.state;
            state2 && ("object" !== typeof state2 || isArrayImpl(state2)) && console.error("%s.state: must be set to an object or null", name);
            "function" === typeof instance.getChildContext && "object" !== typeof type2.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              name
            );
            var initialState = void 0 !== instance.state ? instance.state : null;
            instance.updater = classComponentUpdater;
            instance.props = resolvedProps;
            instance.state = initialState;
            var internalInstance = { queue: [], replace: false };
            instance._reactInternals = internalInstance;
            var contextType$jscomp$0 = type2.contextType;
            instance.context = "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 ? contextType$jscomp$0._currentValue2 : emptyContextObject;
            if (instance.state === resolvedProps) {
              var componentName$jscomp$0 = getComponentNameFromType(type2) || "Component";
              didWarnAboutDirectlyAssigningPropsToState.has(
                componentName$jscomp$0
              ) || (didWarnAboutDirectlyAssigningPropsToState.add(
                componentName$jscomp$0
              ), console.error(
                "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                componentName$jscomp$0
              ));
            }
            var getDerivedStateFromProps = type2.getDerivedStateFromProps;
            if ("function" === typeof getDerivedStateFromProps) {
              var partialState = getDerivedStateFromProps(
                resolvedProps,
                initialState
              );
              if (void 0 === partialState) {
                var componentName$jscomp$1 = getComponentNameFromType(type2) || "Component";
                didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error(
                  "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
                  componentName$jscomp$1
                ));
              }
              var JSCompiler_inline_result = null === partialState || void 0 === partialState ? initialState : assign2({}, initialState, partialState);
              instance.state = JSCompiler_inline_result;
            }
            if ("function" !== typeof type2.getDerivedStateFromProps && "function" !== typeof instance.getSnapshotBeforeUpdate && ("function" === typeof instance.UNSAFE_componentWillMount || "function" === typeof instance.componentWillMount)) {
              var oldState = instance.state;
              if ("function" === typeof instance.componentWillMount) {
                if (true !== instance.componentWillMount.__suppressDeprecationWarning) {
                  var componentName$jscomp$2 = getComponentNameFromType(type2) || "Unknown";
                  didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn(
                    "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName$jscomp$2
                  ), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = true);
                }
                instance.componentWillMount();
              }
              "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount();
              oldState !== instance.state && (console.error(
                "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
                getComponentNameFromType(type2) || "Component"
              ), classComponentUpdater.enqueueReplaceState(
                instance,
                instance.state,
                null
              ));
              if (null !== internalInstance.queue && 0 < internalInstance.queue.length) {
                var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
                internalInstance.queue = null;
                internalInstance.replace = false;
                if (oldReplace && 1 === oldQueue.length)
                  instance.state = oldQueue[0];
                else {
                  for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                    var partial = oldQueue[i], partialState$jscomp$0 = "function" === typeof partial ? partial.call(
                      instance,
                      nextState,
                      resolvedProps,
                      void 0
                    ) : partial;
                    null != partialState$jscomp$0 && (dontMutate ? (dontMutate = false, nextState = assign2(
                      {},
                      nextState,
                      partialState$jscomp$0
                    )) : assign2(nextState, partialState$jscomp$0));
                  }
                  instance.state = nextState;
                }
              } else internalInstance.queue = null;
            }
            var nextChildren = callRenderInDEV(instance);
            if (12 === request.status) throw null;
            instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error(
              "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
              getComponentNameFromType(type2) || "a component"
            ), didWarnAboutReassigningProps = true);
            var prevKeyPath = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, nextChildren, -1);
            task.keyPath = prevKeyPath;
          } else {
            if (type2.prototype && "function" === typeof type2.prototype.render) {
              var componentName$jscomp$3 = getComponentNameFromType(type2) || "Unknown";
              didWarnAboutBadClass[componentName$jscomp$3] || (console.error(
                "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                componentName$jscomp$3,
                componentName$jscomp$3
              ), didWarnAboutBadClass[componentName$jscomp$3] = true);
            }
            var value = renderWithHooks(
              request,
              task,
              keyPath,
              type2,
              props,
              void 0
            );
            if (12 === request.status) throw null;
            var hasId = 0 !== localIdCounter, actionStateCount = actionStateCounter, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;
            if (type2.contextTypes) {
              var _componentName$jscomp$0 = getComponentNameFromType(type2) || "Unknown";
              didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = true, console.error(
                "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
                _componentName$jscomp$0
              ));
            }
            type2 && type2.childContextTypes && console.error(
              "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
              type2.displayName || type2.name || "Component"
            );
            if ("function" === typeof type2.getDerivedStateFromProps) {
              var _componentName2 = getComponentNameFromType(type2) || "Unknown";
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] || (console.error(
                "%s: Function components do not support getDerivedStateFromProps.",
                _componentName2
              ), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true);
            }
            if ("object" === typeof type2.contextType && null !== type2.contextType) {
              var _componentName3 = getComponentNameFromType(type2) || "Unknown";
              didWarnAboutContextTypeOnFunctionComponent[_componentName3] || (console.error(
                "%s: Function components do not support contextType.",
                _componentName3
              ), didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true);
            }
            finishFunctionComponent(
              request,
              task,
              keyPath,
              value,
              hasId,
              actionStateCount,
              actionStateMatchingIndex$jscomp$0
            );
          }
        else if ("string" === typeof type2) {
          var segment = task.blockedSegment;
          if (null === segment) {
            var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
            task.formatContext = getChildFormatContext(prevContext, type2, props);
            task.keyPath = keyPath;
            renderNode(request, task, children, -1);
            task.formatContext = prevContext;
            task.keyPath = prevKeyPath$jscomp$0;
          } else {
            var _children = pushStartInstance(
              segment.chunks,
              type2,
              props,
              request.resumableState,
              request.renderState,
              task.blockedPreamble,
              task.hoistableState,
              task.formatContext,
              segment.lastPushedText,
              task.isFallback
            );
            segment.lastPushedText = false;
            var _prevContext = task.formatContext, _prevKeyPath2 = task.keyPath;
            task.keyPath = keyPath;
            if ((task.formatContext = getChildFormatContext(
              _prevContext,
              type2,
              props
            )).insertionMode === HTML_HEAD_MODE) {
              var preambleSegment = createPendingSegment(
                request,
                0,
                null,
                task.formatContext,
                false,
                false
              );
              segment.preambleChildren.push(preambleSegment);
              var preambleTask = createRenderTask(
                request,
                null,
                _children,
                -1,
                task.blockedBoundary,
                preambleSegment,
                task.blockedPreamble,
                task.hoistableState,
                request.abortableTasks,
                task.keyPath,
                task.formatContext,
                task.context,
                task.treeContext,
                task.componentStack,
                task.isFallback,
                emptyContextObject,
                task.debugTask
              );
              pushComponentStack(preambleTask);
              request.pingedTasks.push(preambleTask);
            } else renderNode(request, task, _children, -1);
            task.formatContext = _prevContext;
            task.keyPath = _prevKeyPath2;
            a: {
              var target = segment.chunks, resumableState = request.resumableState;
              switch (type2) {
                case "title":
                case "style":
                case "script":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "img":
                case "input":
                case "keygen":
                case "link":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                  break a;
                case "body":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE) {
                    resumableState.hasBody = true;
                    break a;
                  }
                  break;
                case "html":
                  if (_prevContext.insertionMode === ROOT_HTML_MODE) {
                    resumableState.hasHtml = true;
                    break a;
                  }
                  break;
                case "head":
                  if (_prevContext.insertionMode <= HTML_HTML_MODE) break a;
              }
              target.push(endChunkForTag(type2));
            }
            segment.lastPushedText = false;
          }
        } else {
          switch (type2) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE:
              var prevKeyPath$jscomp$1 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = prevKeyPath$jscomp$1;
              return;
            case REACT_ACTIVITY_TYPE:
              if ("hidden" !== props.mode) {
                var prevKeyPath$jscomp$2 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, props.children, -1);
                task.keyPath = prevKeyPath$jscomp$2;
              }
              return;
            case REACT_SUSPENSE_LIST_TYPE:
              var _prevKeyPath3 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive(request, task, props.children, -1);
              task.keyPath = _prevKeyPath3;
              return;
            case REACT_VIEW_TRANSITION_TYPE:
            case REACT_SCOPE_TYPE:
              throw Error(
                "ReactDOMServer does not yet support scope components."
              );
            case REACT_SUSPENSE_TYPE:
              a: if (null !== task.replay) {
                var _prevKeyPath = task.keyPath;
                task.keyPath = keyPath;
                var _content = props.children;
                try {
                  renderNode(request, task, _content, -1);
                } finally {
                  task.keyPath = _prevKeyPath;
                }
              } else {
                var prevKeyPath$jscomp$3 = task.keyPath, parentBoundary = task.blockedBoundary, parentPreamble = task.blockedPreamble, parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set();
                var newBoundary = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  createPreambleState(),
                  createPreambleState()
                ) : createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  null,
                  null
                );
                null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
                var boundarySegment = createPendingSegment(
                  request,
                  parentSegment.chunks.length,
                  newBoundary,
                  task.formatContext,
                  false,
                  false
                );
                parentSegment.children.push(boundarySegment);
                parentSegment.lastPushedText = false;
                var contentRootSegment = createPendingSegment(
                  request,
                  0,
                  null,
                  task.formatContext,
                  false,
                  false
                );
                contentRootSegment.parentFlushed = true;
                if (null !== request.trackedPostpones) {
                  var fallbackKeyPath = [
                    keyPath[0],
                    "Suspense Fallback",
                    keyPath[2]
                  ], fallbackReplayNode = [
                    fallbackKeyPath[1],
                    fallbackKeyPath[2],
                    [],
                    null
                  ];
                  request.trackedPostpones.workingMap.set(
                    fallbackKeyPath,
                    fallbackReplayNode
                  );
                  newBoundary.trackedFallbackNode = fallbackReplayNode;
                  task.blockedSegment = boundarySegment;
                  task.blockedPreamble = newBoundary.fallbackPreamble;
                  task.keyPath = fallbackKeyPath;
                  boundarySegment.status = 6;
                  try {
                    renderNode(request, task, fallback, -1), pushSegmentFinale(
                      boundarySegment.chunks,
                      request.renderState,
                      boundarySegment.lastPushedText,
                      boundarySegment.textEmbedded
                    ), boundarySegment.status = COMPLETED;
                  } catch (thrownValue) {
                    throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
                  } finally {
                    task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$3;
                  }
                  var suspendedPrimaryTask = createRenderTask(
                    request,
                    null,
                    content,
                    -1,
                    newBoundary,
                    contentRootSegment,
                    newBoundary.contentPreamble,
                    newBoundary.contentState,
                    task.abortSet,
                    keyPath,
                    task.formatContext,
                    task.context,
                    task.treeContext,
                    task.componentStack,
                    task.isFallback,
                    emptyContextObject,
                    task.debugTask
                  );
                  pushComponentStack(suspendedPrimaryTask);
                  request.pingedTasks.push(suspendedPrimaryTask);
                } else {
                  task.blockedBoundary = newBoundary;
                  task.blockedPreamble = newBoundary.contentPreamble;
                  task.hoistableState = newBoundary.contentState;
                  task.blockedSegment = contentRootSegment;
                  task.keyPath = keyPath;
                  contentRootSegment.status = 6;
                  try {
                    if (renderNode(request, task, content, -1), pushSegmentFinale(
                      contentRootSegment.chunks,
                      request.renderState,
                      contentRootSegment.lastPushedText,
                      contentRootSegment.textEmbedded
                    ), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && newBoundary.status === PENDING) {
                      newBoundary.status = COMPLETED;
                      0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                      break a;
                    }
                  } catch (thrownValue$2) {
                    newBoundary.status = CLIENT_RENDERED;
                    if (12 === request.status) {
                      contentRootSegment.status = 3;
                      var error = request.fatalError;
                    } else
                      contentRootSegment.status = 4, error = thrownValue$2;
                    var thrownInfo = getThrownInfo(task.componentStack);
                    var errorDigest = logRecoverableError(
                      request,
                      error,
                      thrownInfo,
                      task.debugTask
                    );
                    encodeErrorForBoundary(
                      newBoundary,
                      errorDigest,
                      error,
                      thrownInfo,
                      false
                    );
                    untrackBoundary(request, newBoundary);
                  } finally {
                    task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$3;
                  }
                  var suspendedFallbackTask = createRenderTask(
                    request,
                    null,
                    fallback,
                    -1,
                    parentBoundary,
                    boundarySegment,
                    newBoundary.fallbackPreamble,
                    newBoundary.fallbackState,
                    fallbackAbortSet,
                    [keyPath[0], "Suspense Fallback", keyPath[2]],
                    task.formatContext,
                    task.context,
                    task.treeContext,
                    task.componentStack,
                    true,
                    emptyContextObject,
                    task.debugTask
                  );
                  pushComponentStack(suspendedFallbackTask);
                  request.pingedTasks.push(suspendedFallbackTask);
                }
              }
              return;
          }
          if ("object" === typeof type2 && null !== type2)
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                if ("ref" in props) {
                  var propsWithoutRef = {};
                  for (var key in props)
                    "ref" !== key && (propsWithoutRef[key] = props[key]);
                } else propsWithoutRef = props;
                var children$jscomp$0 = renderWithHooks(
                  request,
                  task,
                  keyPath,
                  type2.render,
                  propsWithoutRef,
                  ref
                );
                finishFunctionComponent(
                  request,
                  task,
                  keyPath,
                  children$jscomp$0,
                  0 !== localIdCounter,
                  actionStateCounter,
                  actionStateMatchingIndex
                );
                return;
              case REACT_MEMO_TYPE:
                renderElement(request, task, keyPath, type2.type, props, ref);
                return;
              case REACT_PROVIDER_TYPE:
              case REACT_CONTEXT_TYPE:
                var value$jscomp$0 = props.value, children$jscomp$1 = props.children;
                var prevSnapshot = task.context;
                var prevKeyPath$jscomp$4 = task.keyPath;
                var prevValue = type2._currentValue2;
                type2._currentValue2 = value$jscomp$0;
                void 0 !== type2._currentRenderer2 && null !== type2._currentRenderer2 && type2._currentRenderer2 !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type2._currentRenderer2 = rendererSigil;
                var prevNode = currentActiveSnapshot, newNode = {
                  parent: prevNode,
                  depth: null === prevNode ? 0 : prevNode.depth + 1,
                  context: type2,
                  parentValue: prevValue,
                  value: value$jscomp$0
                };
                currentActiveSnapshot = newNode;
                task.context = newNode;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, children$jscomp$1, -1);
                var prevSnapshot$jscomp$0 = currentActiveSnapshot;
                if (null === prevSnapshot$jscomp$0)
                  throw Error(
                    "Tried to pop a Context at the root of the app. This is a bug in React."
                  );
                prevSnapshot$jscomp$0.context !== type2 && console.error(
                  "The parent context is not the expected context. This is probably a bug in React."
                );
                prevSnapshot$jscomp$0.context._currentValue2 = prevSnapshot$jscomp$0.parentValue;
                void 0 !== type2._currentRenderer2 && null !== type2._currentRenderer2 && type2._currentRenderer2 !== rendererSigil && console.error(
                  "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
                );
                type2._currentRenderer2 = rendererSigil;
                var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot = prevSnapshot$jscomp$0.parent;
                task.context = JSCompiler_inline_result$jscomp$0;
                task.keyPath = prevKeyPath$jscomp$4;
                prevSnapshot !== task.context && console.error(
                  "Popping the context provider did not return back to the original snapshot. This is a bug in React."
                );
                return;
              case REACT_CONSUMER_TYPE:
                var context$jscomp$0 = type2._context, render = props.children;
                "function" !== typeof render && console.error(
                  "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
                );
                var newChildren = render(context$jscomp$0._currentValue2), prevKeyPath$jscomp$5 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive(request, task, newChildren, -1);
                task.keyPath = prevKeyPath$jscomp$5;
                return;
              case REACT_LAZY_TYPE:
                var Component = callLazyInitInDEV(type2);
                if (12 === request.status) throw null;
                renderElement(request, task, keyPath, Component, props, ref);
                return;
            }
          var info = "";
          if (void 0 === type2 || "object" === typeof type2 && null !== type2 && 0 === Object.keys(type2).length)
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          throw Error(
            "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == type2 ? type2 : typeof type2) + "." + info)
          );
        }
      }
      __name(renderElement, "renderElement");
      function resumeNode(request, task, segmentId, node, childIndex) {
        var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
          request,
          0,
          null,
          task.formatContext,
          false,
          false
        );
        resumedSegment.id = segmentId;
        resumedSegment.parentFlushed = true;
        try {
          task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = COMPLETED, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
        } finally {
          task.replay = prevReplay, task.blockedSegment = null;
        }
      }
      __name(resumeNode, "resumeNode");
      function replayElement(request, task, keyPath, name, keyOrIndex, childIndex, type2, props, ref, replay) {
        childIndex = replay.nodes;
        for (var i = 0; i < childIndex.length; i++) {
          var node = childIndex[i];
          if (keyOrIndex === node[1]) {
            if (4 === node.length) {
              if (null !== name && name !== node[0])
                throw Error(
                  "Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering."
                );
              var childNodes = node[2];
              node = node[3];
              name = task.node;
              task.replay = { nodes: childNodes, slots: node, pendingTasks: 1 };
              try {
                renderElement(request, task, keyPath, type2, props, ref);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x) {
                if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                  throw task.node === name && (task.replay = replay), x;
                task.replay.pendingTasks--;
                type2 = getThrownInfo(task.componentStack);
                props = request;
                request = task.blockedBoundary;
                keyPath = x;
                ref = node;
                node = logRecoverableError(props, keyPath, type2, task.debugTask);
                abortRemainingReplayNodes(
                  props,
                  request,
                  childNodes,
                  ref,
                  keyPath,
                  node,
                  type2,
                  false
                );
              }
              task.replay = replay;
            } else {
              if (type2 !== REACT_SUSPENSE_TYPE)
                throw Error(
                  "Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type2) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering."
                );
              a: {
                replay = void 0;
                type2 = node[5];
                ref = node[2];
                name = node[3];
                keyOrIndex = null === node[4] ? [] : node[4][2];
                node = null === node[4] ? null : node[4][3];
                var prevKeyPath = task.keyPath, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                props = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  createPreambleState(),
                  createPreambleState()
                ) : createSuspenseBoundary(
                  request,
                  fallbackAbortSet,
                  null,
                  null
                );
                props.parentFlushed = true;
                props.rootSegmentID = type2;
                task.blockedBoundary = props;
                task.hoistableState = props.contentState;
                task.keyPath = keyPath;
                task.replay = { nodes: ref, slots: name, pendingTasks: 1 };
                try {
                  renderNode(request, task, content, -1);
                  if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                    throw Error(
                      "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                    );
                  task.replay.pendingTasks--;
                  if (0 === props.pendingTasks && props.status === PENDING) {
                    props.status = COMPLETED;
                    request.completedBoundaries.push(props);
                    break a;
                  }
                } catch (error) {
                  props.status = CLIENT_RENDERED, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                    request,
                    error,
                    childNodes,
                    task.debugTask
                  ), encodeErrorForBoundary(props, replay, error, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                } finally {
                  task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;
                }
                props = createReplayTask(
                  request,
                  null,
                  { nodes: keyOrIndex, slots: node, pendingTasks: 0 },
                  fallback,
                  -1,
                  parentBoundary,
                  props.fallbackState,
                  fallbackAbortSet,
                  [keyPath[0], "Suspense Fallback", keyPath[2]],
                  task.formatContext,
                  task.context,
                  task.treeContext,
                  task.componentStack,
                  true,
                  emptyContextObject,
                  task.debugTask
                );
                pushComponentStack(props);
                request.pingedTasks.push(props);
              }
            }
            childIndex.splice(i, 1);
            break;
          }
        }
      }
      __name(replayElement, "replayElement");
      function renderNodeDestructive(request, task, node, childIndex) {
        null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack(task), retryNode(request, task), task.componentStack = node, task.debugTask = childIndex);
      }
      __name(renderNodeDestructive, "renderNodeDestructive");
      function retryNode(request, task) {
        var node = task.node, childIndex = task.childIndex;
        if (null !== node) {
          if ("object" === typeof node) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = node.type, key = node.key;
                node = node.props;
                var refProp = node.ref;
                refProp = void 0 !== refProp ? refProp : null;
                var debugTask = task.debugTask, name = getComponentNameFromType(type2);
                key = null == key ? -1 === childIndex ? 0 : childIndex : key;
                var keyPath = [task.keyPath, name, key];
                null !== task.replay ? debugTask ? debugTask.run(
                  replayElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    name,
                    key,
                    childIndex,
                    type2,
                    node,
                    refProp,
                    task.replay
                  )
                ) : replayElement(
                  request,
                  task,
                  keyPath,
                  name,
                  key,
                  childIndex,
                  type2,
                  node,
                  refProp,
                  task.replay
                ) : debugTask ? debugTask.run(
                  renderElement.bind(
                    null,
                    request,
                    task,
                    keyPath,
                    type2,
                    node,
                    refProp
                  )
                ) : renderElement(request, task, keyPath, type2, node, refProp);
                return;
              case REACT_PORTAL_TYPE:
                throw Error(
                  "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render."
                );
              case REACT_LAZY_TYPE:
                node = callLazyInitInDEV(node);
                if (12 === request.status) throw null;
                renderNodeDestructive(request, task, node, childIndex);
                return;
            }
            if (isArrayImpl(node)) {
              renderChildrenArray(request, task, node, childIndex);
              return;
            }
            null === node || "object" !== typeof node ? key = null : (type2 = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], key = "function" === typeof type2 ? type2 : null);
            if (key && (type2 = key.call(node))) {
              if (type2 === node) {
                if (-1 !== childIndex || null === task.componentStack || "function" !== typeof task.componentStack.type || "[object GeneratorFunction]" !== Object.prototype.toString.call(task.componentStack.type) || "[object Generator]" !== Object.prototype.toString.call(type2))
                  didWarnAboutGenerators || console.error(
                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                  ), didWarnAboutGenerators = true;
              } else
                node.entries !== key || didWarnAboutMaps || (console.error(
                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                ), didWarnAboutMaps = true);
              node = type2.next();
              if (!node.done) {
                key = [];
                do
                  key.push(node.value), node = type2.next();
                while (!node.done);
                renderChildrenArray(request, task, key, childIndex);
              }
              return;
            }
            if ("function" === typeof node.then)
              return task.thenableState = null, renderNodeDestructive(
                request,
                task,
                unwrapThenable(node),
                childIndex
              );
            if (node.$$typeof === REACT_CONTEXT_TYPE)
              return renderNodeDestructive(
                request,
                task,
                node._currentValue2,
                childIndex
              );
            request = Object.prototype.toString.call(node);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === request ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          "string" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            node,
            request.renderState,
            task.lastPushedText
          ))) : "number" === typeof node || "bigint" === typeof node ? (task = task.blockedSegment, null !== task && (task.lastPushedText = pushTextInstance(
            task.chunks,
            "" + node,
            request.renderState,
            task.lastPushedText
          ))) : ("function" === typeof node && (request = node.displayName || node.name || "Component", console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.",
            request,
            request
          )), "symbol" === typeof node && console.error(
            "Symbols are not valid as a React child.\n  %s",
            String(node)
          ));
        }
      }
      __name(retryNode, "retryNode");
      function renderChildrenArray(request, task, children, childIndex) {
        var prevKeyPath = task.keyPath, previousComponentStack = task.componentStack;
        var previousDebugTask = task.debugTask;
        pushServerComponentStack(task, task.node._debugInfo);
        if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
          for (var replay = task.replay, replayNodes = replay.nodes, j = 0; j < replayNodes.length; j++) {
            var node = replayNodes[j];
            if (node[1] === childIndex) {
              childIndex = node[2];
              node = node[3];
              task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
              try {
                renderChildrenArray(request, task, children, -1);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(
                    "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                  );
                task.replay.pendingTasks--;
              } catch (x) {
                if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                  throw x;
                task.replay.pendingTasks--;
                var thrownInfo = getThrownInfo(task.componentStack);
                children = task.blockedBoundary;
                var error = x, resumeSlots = node;
                node = logRecoverableError(
                  request,
                  error,
                  thrownInfo,
                  task.debugTask
                );
                abortRemainingReplayNodes(
                  request,
                  children,
                  childIndex,
                  resumeSlots,
                  error,
                  node,
                  thrownInfo,
                  false
                );
              }
              task.replay = replay;
              replayNodes.splice(j, 1);
              break;
            }
          }
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        replay = task.treeContext;
        replayNodes = children.length;
        if (null !== task.replay && (j = task.replay.slots, null !== j && "object" === typeof j)) {
          for (childIndex = 0; childIndex < replayNodes; childIndex++)
            node = children[childIndex], task.treeContext = pushTreeContext(
              replay,
              replayNodes,
              childIndex
            ), error = j[childIndex], "number" === typeof error ? (resumeNode(request, task, error, node, childIndex), delete j[childIndex]) : renderNode(request, task, node, childIndex);
          task.treeContext = replay;
          task.keyPath = prevKeyPath;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          return;
        }
        for (j = 0; j < replayNodes; j++) {
          childIndex = children[j];
          resumeSlots = request;
          node = task;
          error = childIndex;
          if (null !== error && "object" === typeof error && (error.$$typeof === REACT_ELEMENT_TYPE || error.$$typeof === REACT_PORTAL_TYPE) && error._store && (!error._store.validated && null == error.key || 2 === error._store.validated)) {
            if ("object" !== typeof error._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            error._store.validated = 1;
            thrownInfo = resumeSlots.didWarnForKey;
            null == thrownInfo && (thrownInfo = resumeSlots.didWarnForKey = /* @__PURE__ */ new WeakSet());
            resumeSlots = node.componentStack;
            if (null !== resumeSlots && !thrownInfo.has(resumeSlots)) {
              thrownInfo.add(resumeSlots);
              var componentName = getComponentNameFromType(error.type);
              thrownInfo = error._owner;
              var parentOwner = resumeSlots.owner;
              resumeSlots = "";
              if (parentOwner && "undefined" !== typeof parentOwner.type) {
                var name = getComponentNameFromType(parentOwner.type);
                name && (resumeSlots = "\n\nCheck the render method of `" + name + "`.");
              }
              resumeSlots || componentName && (resumeSlots = "\n\nCheck the top-level render call using <" + componentName + ">.");
              componentName = "";
              null != thrownInfo && parentOwner !== thrownInfo && (parentOwner = null, "undefined" !== typeof thrownInfo.type ? parentOwner = getComponentNameFromType(thrownInfo.type) : "string" === typeof thrownInfo.name && (parentOwner = thrownInfo.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
              thrownInfo = node.componentStack;
              node.componentStack = {
                parent: node.componentStack,
                type: error.type,
                owner: error._owner,
                stack: error._debugStack
              };
              console.error(
                'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                resumeSlots,
                componentName
              );
              node.componentStack = thrownInfo;
            }
          }
          task.treeContext = pushTreeContext(replay, replayNodes, j);
          renderNode(request, task, childIndex, j);
        }
        task.treeContext = replay;
        task.keyPath = prevKeyPath;
        task.componentStack = previousComponentStack;
        task.debugTask = previousDebugTask;
      }
      __name(renderChildrenArray, "renderChildrenArray");
      function untrackBoundary(request, boundary) {
        request = request.trackedPostpones;
        null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
      }
      __name(untrackBoundary, "untrackBoundary");
      function spawnNewSuspendedReplayTask(request, task, thenableState2) {
        return createReplayTask(
          request,
          thenableState2,
          task.replay,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      __name(spawnNewSuspendedReplayTask, "spawnNewSuspendedReplayTask");
      function spawnNewSuspendedRenderTask(request, task, thenableState2) {
        var segment = task.blockedSegment, newSegment = createPendingSegment(
          request,
          segment.chunks.length,
          null,
          task.formatContext,
          segment.lastPushedText,
          true
        );
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        return createRenderTask(
          request,
          thenableState2,
          task.node,
          task.childIndex,
          task.blockedBoundary,
          newSegment,
          task.blockedPreamble,
          task.hoistableState,
          task.abortSet,
          task.keyPath,
          task.formatContext,
          task.context,
          task.treeContext,
          task.componentStack,
          task.isFallback,
          emptyContextObject,
          task.debugTask
        );
      }
      __name(spawnNewSuspendedRenderTask, "spawnNewSuspendedRenderTask");
      function renderNode(request, task, node, childIndex) {
        var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, previousDebugTask = task.debugTask, segment = task.blockedSegment;
        if (null === segment)
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue) {
            if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedReplayTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedReplayTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        else {
          var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
          try {
            return renderNodeDestructive(request, task, node, childIndex);
          } catch (thrownValue$3) {
            if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException ? getSuspendedThenable() : thrownValue$3, "object" === typeof node && null !== node) {
              if ("function" === typeof node.then) {
                childIndex = getThenableStateAfterSuspending();
                request = spawnNewSuspendedRenderTask(
                  request,
                  task,
                  childIndex
                ).ping;
                node.then(request, request);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
              if ("Maximum call stack size exceeded" === node.message) {
                node = getThenableStateAfterSuspending();
                node = spawnNewSuspendedRenderTask(request, task, node);
                request.pingedTasks.push(node);
                task.formatContext = previousFormatContext;
                task.context = previousContext;
                task.keyPath = previousKeyPath;
                task.treeContext = previousTreeContext;
                task.componentStack = previousComponentStack;
                task.debugTask = previousDebugTask;
                switchContext(previousContext);
                return;
              }
            }
          }
        }
        task.formatContext = previousFormatContext;
        task.context = previousContext;
        task.keyPath = previousKeyPath;
        task.treeContext = previousTreeContext;
        switchContext(previousContext);
        throw node;
      }
      __name(renderNode, "renderNode");
      function abortTaskSoft(task) {
        var boundary = task.blockedBoundary;
        task = task.blockedSegment;
        null !== task && (task.status = 3, finishedTask(this, boundary, task));
      }
      __name(abortTaskSoft, "abortTaskSoft");
      function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted) {
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (4 === node.length)
            abortRemainingReplayNodes(
              request$jscomp$0,
              boundary,
              node[2],
              node[3],
              error$jscomp$0,
              errorDigest$jscomp$0,
              errorInfo$jscomp$0,
              aborted
            );
          else {
            var request = request$jscomp$0;
            node = node[5];
            var error = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted, resumedBoundary = createSuspenseBoundary(
              request,
              /* @__PURE__ */ new Set(),
              null,
              null
            );
            resumedBoundary.parentFlushed = true;
            resumedBoundary.rootSegmentID = node;
            resumedBoundary.status = CLIENT_RENDERED;
            encodeErrorForBoundary(
              resumedBoundary,
              errorDigest,
              error,
              errorInfo,
              wasAborted
            );
            resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
          }
        }
        nodes.length = 0;
        if (null !== slots) {
          if (null === boundary)
            throw Error(
              "We should not have any resumable nodes in the shell. This is a bug in React."
            );
          boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(
            boundary,
            errorDigest$jscomp$0,
            error$jscomp$0,
            errorInfo$jscomp$0,
            aborted
          ), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
          if ("object" === typeof slots)
            for (var index in slots) delete slots[index];
        }
      }
      __name(abortRemainingReplayNodes, "abortRemainingReplayNodes");
      function abortTask(task, request, error) {
        var boundary = task.blockedBoundary, segment = task.blockedSegment;
        if (null !== segment) {
          if (6 === segment.status) return;
          segment.status = 3;
        }
        segment = getThrownInfo(task.componentStack);
        if (null === boundary) {
          if (13 !== request.status && request.status !== CLOSED) {
            boundary = task.replay;
            if (null === boundary) {
              logRecoverableError(request, error, segment, null);
              fatalError(request, error, segment, null);
              return;
            }
            boundary.pendingTasks--;
            0 === boundary.pendingTasks && 0 < boundary.nodes.length && (task = logRecoverableError(request, error, segment, null), abortRemainingReplayNodes(
              request,
              null,
              boundary.nodes,
              boundary.slots,
              error,
              task,
              segment,
              true
            ));
            request.pendingRootTasks--;
            0 === request.pendingRootTasks && completeShell(request);
          }
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, task = logRecoverableError(request, error, segment, null), boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary, task, error, segment, true), untrackBoundary(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, error);
          }), boundary.fallbackAbortableTasks.clear();
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      __name(abortTask, "abortTask");
      function safelyEmitEarlyPreloads(request, shellComplete) {
        try {
          var renderState = request.renderState, onHeaders = renderState.onHeaders;
          if (onHeaders) {
            var headers = renderState.headers;
            if (headers) {
              renderState.headers = null;
              var linkHeader = headers.preconnects;
              headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
              headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
              if (!shellComplete) {
                var queueIter = renderState.styles.values(), queueStep = queueIter.next();
                b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                  for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                    var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                    var header = getPreloadAsHeader(
                      props$jscomp$0.href,
                      "style",
                      {
                        crossOrigin: props$jscomp$0.crossOrigin,
                        integrity: props$jscomp$0.integrity,
                        nonce: props$jscomp$0.nonce,
                        type: props$jscomp$0.type,
                        fetchPriority: props$jscomp$0.fetchPriority,
                        referrerPolicy: props$jscomp$0.referrerPolicy,
                        media: props$jscomp$0.media
                      }
                    );
                    if (0 <= (headers.remainingCapacity -= header.length + 2))
                      renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                    else break b;
                  }
              }
              linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
            }
          }
        } catch (error) {
          logRecoverableError(request, error, {}, null);
        }
      }
      __name(safelyEmitEarlyPreloads, "safelyEmitEarlyPreloads");
      function completeShell(request) {
        null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
        null === request.trackedPostpones && preparePreamble(request);
        request.onShellError = noop2;
        request = request.onShellReady;
        request();
      }
      __name(completeShell, "completeShell");
      function completeAll(request) {
        safelyEmitEarlyPreloads(
          request,
          null === request.trackedPostpones ? true : null === request.completedRootSegment || request.completedRootSegment.status !== POSTPONED
        );
        preparePreamble(request);
        request = request.onAllReady;
        request();
      }
      __name(completeAll, "completeAll");
      function queueCompletedSegment(boundary, segment) {
        if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          childSegment.status === COMPLETED && queueCompletedSegment(boundary, childSegment);
        } else boundary.completedSegments.push(segment);
      }
      __name(queueCompletedSegment, "queueCompletedSegment");
      function finishedTask(request, boundary, segment) {
        if (null === boundary) {
          if (null !== segment && segment.parentFlushed) {
            if (null !== request.completedRootSegment)
              throw Error(
                "There can only be one root segment. This is a bug in React."
              );
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          0 === request.pendingRootTasks && completeShell(request);
        } else
          boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED && (0 === boundary.pendingTasks ? (boundary.status === PENDING && (boundary.status = COMPLETED), null !== segment && segment.parentFlushed && segment.status === COMPLETED && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED && (boundary.fallbackAbortableTasks.forEach(
            abortTaskSoft,
            request
          ), boundary.fallbackAbortableTasks.clear(), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request))) : null !== segment && segment.parentFlushed && segment.status === COMPLETED && (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)));
        request.allPendingTasks--;
        0 === request.allPendingTasks && completeAll(request);
      }
      __name(finishedTask, "finishedTask");
      function performWork(request$jscomp$2) {
        if (request$jscomp$2.status !== CLOSED && 13 !== request$jscomp$2.status) {
          var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = HooksDispatcher;
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          var prevRequest = currentRequest;
          currentRequest = request$jscomp$2;
          var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
          ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
          var prevResumableState = currentResumableState;
          currentResumableState = request$jscomp$2.resumableState;
          try {
            var pingedTasks = request$jscomp$2.pingedTasks, i;
            for (i = 0; i < pingedTasks.length; i++) {
              var request = request$jscomp$2, task = pingedTasks[i], segment = task.blockedSegment;
              if (null === segment) {
                var prevTaskInDEV = void 0, request$jscomp$0 = request;
                request = task;
                if (0 !== request.replay.pendingTasks) {
                  switchContext(request.context);
                  prevTaskInDEV = currentTaskInDEV;
                  currentTaskInDEV = request;
                  try {
                    "number" === typeof request.replay.slots ? resumeNode(
                      request$jscomp$0,
                      request,
                      request.replay.slots,
                      request.node,
                      request.childIndex
                    ) : retryNode(request$jscomp$0, request);
                    if (1 === request.replay.pendingTasks && 0 < request.replay.nodes.length)
                      throw Error(
                        "Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering."
                      );
                    request.replay.pendingTasks--;
                    request.abortSet.delete(request);
                    finishedTask(request$jscomp$0, request.blockedBoundary, null);
                  } catch (thrownValue) {
                    resetHooksState();
                    var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                    if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                      var ping3 = request.ping;
                      x.then(ping3, ping3);
                      request.thenableState = getThenableStateAfterSuspending();
                    } else {
                      request.replay.pendingTasks--;
                      request.abortSet.delete(request);
                      var errorInfo = getThrownInfo(request.componentStack), errorDigest = void 0, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                      errorDigest = logRecoverableError(
                        request$jscomp$1,
                        error$jscomp$0,
                        errorInfo$jscomp$0,
                        request.debugTask
                      );
                      abortRemainingReplayNodes(
                        request$jscomp$1,
                        boundary,
                        replayNodes,
                        resumeSlots,
                        error$jscomp$0,
                        errorDigest,
                        errorInfo$jscomp$0,
                        false
                      );
                      request$jscomp$0.pendingRootTasks--;
                      0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                      request$jscomp$0.allPendingTasks--;
                      0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                    }
                  } finally {
                    currentTaskInDEV = prevTaskInDEV;
                  }
                }
              } else if (request$jscomp$0 = prevTaskInDEV = void 0, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
                request$jscomp$1.status = 6;
                switchContext(errorDigest.context);
                request$jscomp$0 = currentTaskInDEV;
                currentTaskInDEV = errorDigest;
                var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
                try {
                  retryNode(request, errorDigest), pushSegmentFinale(
                    request$jscomp$1.chunks,
                    request.renderState,
                    request$jscomp$1.lastPushedText,
                    request$jscomp$1.textEmbedded
                  ), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedTask(
                    request,
                    errorDigest.blockedBoundary,
                    request$jscomp$1
                  );
                } catch (thrownValue) {
                  resetHooksState();
                  request$jscomp$1.children.length = childrenLength;
                  request$jscomp$1.chunks.length = chunkLength;
                  var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
                  if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                    request$jscomp$1.status = PENDING;
                    errorDigest.thenableState = getThenableStateAfterSuspending();
                    var ping$jscomp$0 = errorDigest.ping;
                    x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                  } else {
                    var errorInfo$jscomp$1 = getThrownInfo(
                      errorDigest.componentStack
                    );
                    errorDigest.abortSet.delete(errorDigest);
                    request$jscomp$1.status = 4;
                    var boundary$jscomp$0 = errorDigest.blockedBoundary, debugTask = errorDigest.debugTask;
                    prevTaskInDEV = logRecoverableError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    );
                    null === boundary$jscomp$0 ? fatalError(
                      request,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      debugTask
                    ) : (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED && (boundary$jscomp$0.status = CLIENT_RENDERED, encodeErrorForBoundary(
                      boundary$jscomp$0,
                      prevTaskInDEV,
                      x$jscomp$0,
                      errorInfo$jscomp$1,
                      false
                    ), untrackBoundary(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(
                      boundary$jscomp$0
                    ), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request)));
                    request.allPendingTasks--;
                    0 === request.allPendingTasks && completeAll(request);
                  }
                } finally {
                  currentTaskInDEV = request$jscomp$0;
                }
              }
            }
            pingedTasks.splice(0, i);
            null !== request$jscomp$2.destination && flushCompletedQueues(
              request$jscomp$2,
              request$jscomp$2.destination
            );
          } catch (error) {
            pingedTasks = {}, logRecoverableError(request$jscomp$2, error, pingedTasks, null), fatalError(request$jscomp$2, error, pingedTasks, null);
          } finally {
            currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
          }
        }
      }
      __name(performWork, "performWork");
      function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
        segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
        for (var pendingPreambles = false, i = 0; i < segment.children.length; i++)
          pendingPreambles = preparePreambleFromSegment(
            request,
            segment.children[i],
            collectedPreambleSegments
          ) || pendingPreambles;
        return pendingPreambles;
      }
      __name(preparePreambleFromSubtree, "preparePreambleFromSubtree");
      function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
        var boundary = segment.boundary;
        if (null === boundary)
          return preparePreambleFromSubtree(
            request,
            segment,
            collectedPreambleSegments
          );
        var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
        if (null === preamble || null === fallbackPreamble) return false;
        switch (boundary.status) {
          case COMPLETED:
            hoistPreambleState(request.renderState, preamble);
            segment = boundary.completedSegments[0];
            if (!segment)
              throw Error(
                "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
              );
            return preparePreambleFromSubtree(
              request,
              segment,
              collectedPreambleSegments
            );
          case POSTPONED:
            if (null !== request.trackedPostpones) return true;
          case CLIENT_RENDERED:
            if (segment.status === COMPLETED)
              return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
                request,
                segment,
                collectedPreambleSegments
              );
          default:
            return true;
        }
      }
      __name(preparePreambleFromSegment, "preparePreambleFromSegment");
      function preparePreamble(request) {
        if (request.completedRootSegment && null === request.completedPreambleSegments) {
          var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment(
            request,
            request.completedRootSegment,
            collectedPreambleSegments
          ), preamble = request.renderState.preamble;
          if (false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks)
            request.completedPreambleSegments = collectedPreambleSegments;
        }
      }
      __name(preparePreamble, "preparePreamble");
      function flushSubtree(request, destination, segment, hoistableState) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING:
            segment.id = request.nextSegmentId++;
          case POSTPONED:
            return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, destination.push(placeholder1), destination.push(request.placeholderPrefix), request = hoistableState.toString(16), destination.push(request), destination.push(placeholder2);
          case COMPLETED:
            segment.status = FLUSHED;
            var r = true, chunks = segment.chunks, chunkIdx = 0;
            segment = segment.children;
            for (var childIdx = 0; childIdx < segment.length; childIdx++) {
              for (r = segment[childIdx]; chunkIdx < r.index; chunkIdx++)
                destination.push(chunks[chunkIdx]);
              r = flushSegment(request, destination, r, hoistableState);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++)
              destination.push(chunks[chunkIdx]);
            chunkIdx < chunks.length && (r = destination.push(chunks[chunkIdx]));
            return r;
          default:
            throw Error(
              "Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React."
            );
        }
      }
      __name(flushSubtree, "flushSubtree");
      function flushSegment(request, destination, segment, hoistableState) {
        var boundary = segment.boundary;
        if (null === boundary)
          return flushSubtree(request, destination, segment, hoistableState);
        boundary.parentFlushed = true;
        if (boundary.status === CLIENT_RENDERED) {
          if (!request.renderState.generateStaticMarkup) {
            var errorDigest = boundary.errorDigest, errorMessage2 = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
            destination.push(startClientRenderedSuspenseBoundary);
            destination.push(clientRenderedSuspenseBoundaryError1);
            errorDigest && (destination.push(clientRenderedSuspenseBoundaryError1A), errorDigest = escapeTextForBrowser(errorDigest), destination.push(errorDigest), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            errorMessage2 && (destination.push(clientRenderedSuspenseBoundaryError1B), errorMessage2 = escapeTextForBrowser(errorMessage2), destination.push(errorMessage2), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            errorStack && (destination.push(clientRenderedSuspenseBoundaryError1C), errorStack = escapeTextForBrowser(errorStack), destination.push(errorStack), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            errorComponentStack && (destination.push(clientRenderedSuspenseBoundaryError1D), errorComponentStack = escapeTextForBrowser(errorComponentStack), destination.push(errorComponentStack), destination.push(
              clientRenderedSuspenseBoundaryErrorAttrInterstitial
            ));
            destination.push(clientRenderedSuspenseBoundaryError2);
          }
          flushSubtree(request, destination, segment, hoistableState);
          request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.fallbackPreamble) && writePreambleContribution(destination, request), destination = destination.push(endSuspenseBoundary));
          return destination;
        }
        if (boundary.status !== COMPLETED)
          return boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency, hoistableState), boundary.stylesheets.forEach(
            hoistStylesheetDependency,
            hoistableState
          )), flushSubtree(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary);
        if (boundary.byteSize > request.progressiveChunkSize)
          return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
            destination,
            request.renderState,
            boundary.rootSegmentID
          ), flushSubtree(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary);
        hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));
        request.renderState.generateStaticMarkup || destination.push(startCompletedSuspenseBoundary);
        segment = boundary.completedSegments;
        if (1 !== segment.length)
          throw Error(
            "A previously unvisited boundary must have exactly one root segment. This is a bug in React."
          );
        flushSegment(request, destination, segment[0], hoistableState);
        request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.contentPreamble) && writePreambleContribution(destination, request), destination = destination.push(endSuspenseBoundary));
        return destination;
      }
      __name(flushSegment, "flushSegment");
      function flushSegmentContainer(request, destination, segment, hoistableState) {
        writeStartSegment(
          destination,
          request.renderState,
          segment.parentFormatContext,
          segment.id
        );
        flushSegment(request, destination, segment, hoistableState);
        return writeEndSegment(destination, segment.parentFormatContext);
      }
      __name(flushSegmentContainer, "flushSegmentContainer");
      function flushCompletedBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++)
          flushPartiallyCompletedSegment(
            request,
            destination,
            boundary,
            completedSegments[i]
          );
        completedSegments.length = 0;
        writeHoistablesForBoundary(
          destination,
          boundary.contentState,
          request.renderState
        );
        completedSegments = request.resumableState;
        request = request.renderState;
        i = boundary.rootSegmentID;
        boundary = boundary.contentState;
        var requiresStyleInsertion = request.stylesToHoist;
        request.stylesToHoist = false;
        destination.push(request.startInlineScript);
        requiresStyleInsertion ? (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions = completedSegments.instructions | SentStyleInsertionFunction | SentCompleteBoundaryFunction, destination.push(completeBoundaryWithStylesScript1FullBoth)) : (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, destination.push(completeBoundaryWithStylesScript1FullPartial)) : destination.push(completeBoundaryWithStylesScript1Partial) : (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent ? (completedSegments.instructions |= SentCompleteBoundaryFunction, destination.push(completeBoundaryScript1Full)) : destination.push(completeBoundaryScript1Partial);
        completedSegments = i.toString(16);
        destination.push(request.boundaryPrefix);
        destination.push(completedSegments);
        destination.push(completeBoundaryScript2);
        destination.push(request.segmentPrefix);
        destination.push(completedSegments);
        requiresStyleInsertion ? (destination.push(completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : destination.push(completeBoundaryScript3b);
        boundary = destination.push(completeBoundaryScriptEnd);
        return writeBootstrap(destination, request) && boundary;
      }
      __name(flushCompletedBoundary, "flushCompletedBoundary");
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) return true;
        var hoistableState = boundary.contentState, segmentID = segment.id;
        if (-1 === segmentID) {
          if (-1 === (segment.id = boundary.rootSegmentID))
            throw Error(
              "A root segment ID must have been assigned by now. This is a bug in React."
            );
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        }
        if (segmentID === boundary.rootSegmentID)
          return flushSegmentContainer(
            request,
            destination,
            segment,
            hoistableState
          );
        flushSegmentContainer(request, destination, segment, hoistableState);
        boundary = request.resumableState;
        request = request.renderState;
        destination.push(request.startInlineScript);
        (boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, destination.push(completeSegmentScript1Full)) : destination.push(completeSegmentScript1Partial);
        destination.push(request.segmentPrefix);
        segmentID = segmentID.toString(16);
        destination.push(segmentID);
        destination.push(completeSegmentScript2);
        destination.push(request.placeholderPrefix);
        destination.push(segmentID);
        destination = destination.push(completeSegmentScriptEnd);
        return destination;
      }
      __name(flushPartiallyCompletedSegment, "flushPartiallyCompletedSegment");
      function flushCompletedQueues(request, destination) {
        try {
          if (!(0 < request.pendingRootTasks)) {
            var i, completedRootSegment = request.completedRootSegment;
            if (null !== completedRootSegment) {
              if (completedRootSegment.status === POSTPONED) return;
              var completedPreambleSegments = request.completedPreambleSegments;
              if (null === completedPreambleSegments) return;
              var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
              if (htmlChunks) {
                for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                  destination.push(htmlChunks[i$jscomp$0]);
                if (headChunks)
                  for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                    destination.push(headChunks[i$jscomp$0]);
                else {
                  var chunk3 = startChunkForTag("head");
                  destination.push(chunk3);
                  destination.push(endOfStartTag);
                }
              } else if (headChunks)
                for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                  destination.push(headChunks[i$jscomp$0]);
              var charsetChunks = renderState.charsetChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
                destination.push(charsetChunks[i$jscomp$0]);
              charsetChunks.length = 0;
              renderState.preconnects.forEach(flushResource, destination);
              renderState.preconnects.clear();
              var viewportChunks = renderState.viewportChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
                destination.push(viewportChunks[i$jscomp$0]);
              viewportChunks.length = 0;
              renderState.fontPreloads.forEach(flushResource, destination);
              renderState.fontPreloads.clear();
              renderState.highImagePreloads.forEach(flushResource, destination);
              renderState.highImagePreloads.clear();
              renderState.styles.forEach(flushStylesInPreamble, destination);
              var importMapChunks = renderState.importMapChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
                destination.push(importMapChunks[i$jscomp$0]);
              importMapChunks.length = 0;
              renderState.bootstrapScripts.forEach(flushResource, destination);
              renderState.scripts.forEach(flushResource, destination);
              renderState.scripts.clear();
              renderState.bulkPreloads.forEach(flushResource, destination);
              renderState.bulkPreloads.clear();
              var hoistableChunks = renderState.hoistableChunks;
              for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
                destination.push(hoistableChunks[i$jscomp$0]);
              for (renderState = hoistableChunks.length = 0; renderState < completedPreambleSegments.length; renderState++) {
                var segments = completedPreambleSegments[renderState];
                for (preamble = 0; preamble < segments.length; preamble++)
                  flushSegment(request, destination, segments[preamble], null);
              }
              var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
              if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
                var chunk$jscomp$0 = endChunkForTag("head");
                destination.push(chunk$jscomp$0);
              }
              var bodyChunks = preamble$jscomp$0.bodyChunks;
              if (bodyChunks)
                for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                  destination.push(bodyChunks[completedPreambleSegments]);
              flushSegment(request, destination, completedRootSegment, null);
              request.completedRootSegment = null;
              writeBootstrap(destination, request.renderState);
            }
            var renderState$jscomp$0 = request.renderState;
            completedRootSegment = 0;
            var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;
            for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
              destination.push(viewportChunks$jscomp$0[completedRootSegment]);
            viewportChunks$jscomp$0.length = 0;
            renderState$jscomp$0.preconnects.forEach(flushResource, destination);
            renderState$jscomp$0.preconnects.clear();
            renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.fontPreloads.clear();
            renderState$jscomp$0.highImagePreloads.forEach(
              flushResource,
              destination
            );
            renderState$jscomp$0.highImagePreloads.clear();
            renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);
            renderState$jscomp$0.scripts.forEach(flushResource, destination);
            renderState$jscomp$0.scripts.clear();
            renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);
            renderState$jscomp$0.bulkPreloads.clear();
            var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;
            for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
              destination.push(hoistableChunks$jscomp$0[completedRootSegment]);
            hoistableChunks$jscomp$0.length = 0;
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            for (i = 0; i < clientRenderedBoundaries.length; i++) {
              var boundary = clientRenderedBoundaries[i];
              renderState$jscomp$0 = destination;
              var resumableState = request.resumableState, renderState$jscomp$1 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage2 = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
              renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);
              (resumableState.instructions & SentClientRenderFunction) === NothingSent ? (resumableState.instructions |= SentClientRenderFunction, renderState$jscomp$0.push(clientRenderScript1Full)) : renderState$jscomp$0.push(clientRenderScript1Partial);
              renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);
              var chunk$jscomp$1 = id.toString(16);
              renderState$jscomp$0.push(chunk$jscomp$1);
              renderState$jscomp$0.push(clientRenderScript1A);
              if (errorDigest || errorMessage2 || errorStack || errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(
                  errorDigest || ""
                );
                renderState$jscomp$0.push(chunk$jscomp$2);
              }
              if (errorMessage2 || errorStack || errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$3 = escapeJSStringsForInstructionScripts(
                  errorMessage2 || ""
                );
                renderState$jscomp$0.push(chunk$jscomp$3);
              }
              if (errorStack || errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$4 = escapeJSStringsForInstructionScripts(
                  errorStack || ""
                );
                renderState$jscomp$0.push(chunk$jscomp$4);
              }
              if (errorComponentStack) {
                renderState$jscomp$0.push(clientRenderErrorScriptArgInterstitial);
                var chunk$jscomp$5 = escapeJSStringsForInstructionScripts(errorComponentStack);
                renderState$jscomp$0.push(chunk$jscomp$5);
              }
              var JSCompiler_inline_result = renderState$jscomp$0.push(
                clientRenderScriptEnd
              );
              if (!JSCompiler_inline_result) {
                request.destination = null;
                i++;
                clientRenderedBoundaries.splice(0, i);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i);
            var completedBoundaries = request.completedBoundaries;
            for (i = 0; i < completedBoundaries.length; i++)
              if (!flushCompletedBoundary(
                request,
                destination,
                completedBoundaries[i]
              )) {
                request.destination = null;
                i++;
                completedBoundaries.splice(0, i);
                return;
              }
            completedBoundaries.splice(0, i);
            var partialBoundaries = request.partialBoundaries;
            for (i = 0; i < partialBoundaries.length; i++) {
              a: {
                clientRenderedBoundaries = request;
                boundary = destination;
                var boundary$jscomp$0 = partialBoundaries[i], completedSegments = boundary$jscomp$0.completedSegments;
                for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                  if (!flushPartiallyCompletedSegment(
                    clientRenderedBoundaries,
                    boundary,
                    boundary$jscomp$0,
                    completedSegments[JSCompiler_inline_result]
                  )) {
                    JSCompiler_inline_result++;
                    completedSegments.splice(0, JSCompiler_inline_result);
                    var JSCompiler_inline_result$jscomp$0 = false;
                    break a;
                  }
                completedSegments.splice(0, JSCompiler_inline_result);
                JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
                  boundary,
                  boundary$jscomp$0.contentState,
                  clientRenderedBoundaries.renderState
                );
              }
              if (!JSCompiler_inline_result$jscomp$0) {
                request.destination = null;
                i++;
                partialBoundaries.splice(0, i);
                return;
              }
            }
            partialBoundaries.splice(0, i);
            var largeBoundaries = request.completedBoundaries;
            for (i = 0; i < largeBoundaries.length; i++)
              if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {
                request.destination = null;
                i++;
                largeBoundaries.splice(0, i);
                return;
              }
            largeBoundaries.splice(0, i);
          }
        } finally {
          0 === request.allPendingTasks && 0 === request.pingedTasks.length && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length && (request.flushScheduled = false, i = request.resumableState, i.hasBody && (partialBoundaries = endChunkForTag("body"), destination.push(partialBoundaries)), i.hasHtml && (i = endChunkForTag("html"), destination.push(i)), 0 !== request.abortableTasks.size && console.error(
            "There was still abortable task at the root when we closed. This is a bug in React."
          ), request.status = CLOSED, destination.push(null), request.destination = null);
        }
      }
      __name(flushCompletedQueues, "flushCompletedQueues");
      function startWork(request) {
        request.flushScheduled = null !== request.destination;
        performWork(request);
        10 === request.status && (request.status = 11);
        null === request.trackedPostpones && safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);
      }
      __name(startWork, "startWork");
      function enqueueFlush(request) {
        if (false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination) {
          request.flushScheduled = true;
          var destination = request.destination;
          destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
        }
      }
      __name(enqueueFlush, "enqueueFlush");
      function startFlowing(request, destination) {
        if (13 === request.status)
          request.status = CLOSED, destination.destroy(request.fatalError);
        else if (request.status !== CLOSED && null === request.destination) {
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error) {
            destination = {}, logRecoverableError(request, error, destination, null), fatalError(request, error, destination, null);
          }
        }
      }
      __name(startFlowing, "startFlowing");
      function abort(request, reason) {
        if (11 === request.status || 10 === request.status) request.status = 12;
        try {
          var abortableTasks = request.abortableTasks;
          if (0 < abortableTasks.size) {
            var error = void 0 === reason ? Error("The render was aborted by the server without a reason.") : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error("The render was aborted by the server with a promise.") : reason;
            request.fatalError = error;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, error);
            });
            abortableTasks.clear();
          }
          null !== request.destination && flushCompletedQueues(request, request.destination);
        } catch (error$4) {
          reason = {}, logRecoverableError(request, error$4, reason, null), fatalError(request, error$4, reason, null);
        }
      }
      __name(abort, "abort");
      function onError() {
      }
      __name(onError, "onError");
      function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
        var didFatal = false, fatalError2 = null, result = "", readyToStream = false;
        options = createResumableState(
          options ? options.identifierPrefix : void 0
        );
        children = createRequest(
          children,
          options,
          createRenderState(options, generateStaticMarkup),
          createFormatContext(ROOT_HTML_MODE, null, 0),
          Infinity,
          onError,
          void 0,
          function() {
            readyToStream = true;
          },
          void 0,
          void 0,
          void 0
        );
        startWork(children);
        abort(children, abortReason);
        startFlowing(children, {
          push: /* @__PURE__ */ __name(function(chunk3) {
            null !== chunk3 && (result += chunk3);
            return true;
          }, "push"),
          destroy: /* @__PURE__ */ __name(function(error) {
            didFatal = true;
            fatalError2 = error;
          }, "destroy")
        });
        if (didFatal && fatalError2 !== abortReason) throw fatalError2;
        if (!readyToStream)
          throw Error(
            "A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition."
          );
        return result;
      }
      __name(renderToStringImpl, "renderToStringImpl");
      var React5 = require_react(), ReactDOM = require_react_dom(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, isArrayImpl = Array.isArray, jsxPropsParents = /* @__PURE__ */ new WeakMap(), jsxChildrenParents = /* @__PURE__ */ new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"), assign2 = Object.assign, hasOwnProperty = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      ), aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]), hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      }, ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties$1 = {}, rARIA$1 = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel$1 = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), didWarnValueNull = false, possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), rARIACamel = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ), badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, matchHtmlRegExp = /["'&<>]/, uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals = React5.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
        pending: false,
        data: null,
        method: null,
        action: null
      }), previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: previousDispatcher.f,
        r: previousDispatcher.r,
        D: /* @__PURE__ */ __name(function(href) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              if (!resumableState.dnsResources.hasOwnProperty(href)) {
                resumableState.dnsResources[href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
                  JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
                JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.D(href);
        }, "D"),
        C: /* @__PURE__ */ __name(function(href, crossOrigin) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if ("string" === typeof href && href) {
              var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
              if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
                resumableState.connectResources[bucket][href] = EXISTS;
                resumableState = renderState.headers;
                var header, JSCompiler_temp;
                if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
                  JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
                  if ("string" === typeof crossOrigin) {
                    var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(
                      crossOrigin,
                      "crossOrigin"
                    );
                    JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
                  }
                  JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
                }
                JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
                  rel: "preconnect",
                  href,
                  crossOrigin
                }), renderState.preconnects.add(bucket));
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.C(href, crossOrigin);
        }, "C"),
        L: /* @__PURE__ */ __name(function(href, as2, options) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (as2 && href) {
              switch (as2) {
                case "image":
                  if (options) {
                    var imageSrcSet = options.imageSrcSet;
                    var imageSizes = options.imageSizes;
                    var fetchPriority = options.fetchPriority;
                  }
                  var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
                  if (resumableState.imageResources.hasOwnProperty(key)) return;
                  resumableState.imageResources[key] = PRELOAD_NO_CREDS;
                  resumableState = renderState.headers;
                  var header;
                  resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as2, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
                    resumableState,
                    assign2(
                      {
                        rel: "preload",
                        href: imageSrcSet ? void 0 : href,
                        as: as2
                      },
                      options
                    )
                  ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
                  break;
                case "style":
                  if (resumableState.styleResources.hasOwnProperty(href)) return;
                  imageSrcSet = [];
                  pushLinkImpl(
                    imageSrcSet,
                    assign2({ rel: "preload", href, as: as2 }, options)
                  );
                  resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  renderState.preloads.stylesheets.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  break;
                case "script":
                  if (resumableState.scriptResources.hasOwnProperty(href)) return;
                  imageSrcSet = [];
                  renderState.preloads.scripts.set(href, imageSrcSet);
                  renderState.bulkPreloads.add(imageSrcSet);
                  pushLinkImpl(
                    imageSrcSet,
                    assign2({ rel: "preload", href, as: as2 }, options)
                  );
                  resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  break;
                default:
                  if (resumableState.unknownResources.hasOwnProperty(as2)) {
                    if (imageSrcSet = resumableState.unknownResources[as2], imageSrcSet.hasOwnProperty(href))
                      return;
                  } else
                    imageSrcSet = {}, resumableState.unknownResources[as2] = imageSrcSet;
                  imageSrcSet[href] = PRELOAD_NO_CREDS;
                  if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as2 && (key = getPreloadAsHeader(href, as2, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                    renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
                  else
                    switch (resumableState = [], href = assign2(
                      { rel: "preload", href, as: as2 },
                      options
                    ), pushLinkImpl(resumableState, href), as2) {
                      case "font":
                        renderState.fontPreloads.add(resumableState);
                        break;
                      default:
                        renderState.bulkPreloads.add(resumableState);
                    }
              }
              enqueueFlush(request);
            }
          } else previousDispatcher.L(href, as2, options);
        }, "L"),
        m: /* @__PURE__ */ __name(function(href, options) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              var as2 = options && "string" === typeof options.as ? options.as : "script";
              switch (as2) {
                case "script":
                  if (resumableState.moduleScriptResources.hasOwnProperty(href))
                    return;
                  as2 = [];
                  resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
                  renderState.preloads.moduleScripts.set(href, as2);
                  break;
                default:
                  if (resumableState.moduleUnknownResources.hasOwnProperty(as2)) {
                    var resources = resumableState.unknownResources[as2];
                    if (resources.hasOwnProperty(href)) return;
                  } else
                    resources = {}, resumableState.moduleUnknownResources[as2] = resources;
                  as2 = [];
                  resources[href] = PRELOAD_NO_CREDS;
              }
              pushLinkImpl(
                as2,
                assign2({ rel: "modulepreload", href }, options)
              );
              renderState.bulkPreloads.add(as2);
              enqueueFlush(request);
            }
          } else previousDispatcher.m(href, options);
        }, "m"),
        X: /* @__PURE__ */ __name(function(src, options) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.scriptResources.hasOwnProperty(
                src
              ) ? resumableState.scriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options = assign2({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
            }
          } else previousDispatcher.X(src, options);
        }, "X"),
        S: /* @__PURE__ */ __name(function(href, precedence, options) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (href) {
              precedence = precedence || "default";
              var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
              resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
                precedence: escapeTextForBrowser(precedence),
                rules: [],
                hrefs: [],
                sheets: /* @__PURE__ */ new Map()
              }, renderState.styles.set(precedence, styleQueue)), precedence = {
                state: PENDING$1,
                props: assign2(
                  {
                    rel: "stylesheet",
                    href,
                    "data-precedence": precedence
                  },
                  options
                )
              }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
            }
          } else previousDispatcher.S(href, precedence, options);
        }, "S"),
        M: /* @__PURE__ */ __name(function(src, options) {
          var request = currentRequest ? currentRequest : null;
          if (request) {
            var resumableState = request.resumableState, renderState = request.renderState;
            if (src) {
              var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : void 0;
              resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options = assign2(
                { src, type: "module", async: true },
                options
              ), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
            }
          } else previousDispatcher.M(src, options);
        }, "M")
      };
      var NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, EXISTS = null, PRELOAD_NO_CREDS = [];
      Object.freeze(PRELOAD_NO_CREDS);
      var scriptRegex = /(<\/|<)(s)(cript)/gi;
      var didWarnForNewBooleanPropsWithEmptyValue = {};
      var NoContribution = 0, ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, styleNameCache = /* @__PURE__ */ new Map(), styleAttributeStart = ' style="', styleAssign = ":", styleSeparator = ";", attributeSeparator = " ", attributeAssign = '="', attributeEnd = '"', attributeEmptyString = '=""', actionJavaScriptURL = escapeTextForBrowser(
        "javascript:throw new Error('React form unexpectedly submitted.')"
      ), endOfStartTag = ">", endOfStartTagSelfClosing = "/>", didWarnDefaultInputValue = false, didWarnDefaultChecked = false, didWarnDefaultSelectValue = false, didWarnDefaultTextareaValue = false, didWarnInvalidOptionChildren = false, didWarnInvalidOptionInnerHTML = false, didWarnSelectedSetOnOption = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, formReplayingRuntimeScript = `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`, styleRegex = /(<\/|<)(s)(tyle)/gi, leadingNewline = "\n", VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map(), endTagCache = /* @__PURE__ */ new Map(), placeholder1 = '<template id="', placeholder2 = '"></template>', startCompletedSuspenseBoundary = "<!--$-->", startPendingSuspenseBoundary1 = '<!--$?--><template id="', startPendingSuspenseBoundary2 = '"></template>', startClientRenderedSuspenseBoundary = "<!--$!-->", endSuspenseBoundary = "<!--/$-->", clientRenderedSuspenseBoundaryError1 = "<template", clientRenderedSuspenseBoundaryErrorAttrInterstitial = '"', clientRenderedSuspenseBoundaryError1A = ' data-dgst="', clientRenderedSuspenseBoundaryError1B = ' data-msg="', clientRenderedSuspenseBoundaryError1C = ' data-stck="', clientRenderedSuspenseBoundaryError1D = ' data-cstck="', clientRenderedSuspenseBoundaryError2 = "></template>", boundaryPreambleContributionChunkStart = "<!--", boundaryPreambleContributionChunkEnd = "-->", startSegmentHTML = '<div hidden id="', startSegmentHTML2 = '">', endSegmentHTML = "</div>", startSegmentSVG = '<svg aria-hidden="true" style="display:none" id="', startSegmentSVG2 = '">', endSegmentSVG = "</svg>", startSegmentMathML = '<math aria-hidden="true" style="display:none" id="', startSegmentMathML2 = '">', endSegmentMathML = "</math>", startSegmentTable = '<table hidden id="', startSegmentTable2 = '">', endSegmentTable = "</table>", startSegmentTableBody = '<table hidden><tbody id="', startSegmentTableBody2 = '">', endSegmentTableBody = "</tbody></table>", startSegmentTableRow = '<table hidden><tr id="', startSegmentTableRow2 = '">', endSegmentTableRow = "</tr></table>", startSegmentColGroup = '<table hidden><colgroup id="', startSegmentColGroup2 = '">', endSegmentColGroup = "</colgroup></table>", completeSegmentScript1Full = '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("', completeSegmentScript1Partial = '$RS("', completeSegmentScript2 = '","', completeSegmentScriptEnd = '")<\/script>', completeBoundaryScript1Full = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RC("', completeBoundaryScript1Partial = '$RC("', completeBoundaryWithStylesScript1FullBoth = '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data="$!",a.setAttribute("data-dgst",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if("/$"===d)if(0===f)break;else f--;else"$"!==d&&"$?"!==d&&"$!"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data="$"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("', completeBoundaryWithStylesScript1FullPartial = '$RM=new Map;\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll("link[data-precedence],style[data-precedence]"),x=[],k=0;b=h[k++];)"not all"===b.getAttribute("media")?x.push(b):("LINK"===b.tagName&&p.set(b.getAttribute("href"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement("link");a.href=\nd;a.rel="stylesheet";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute("media");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\nt,u,""),w.bind(null,t,u,"Resource failed to load"))};$RR("', completeBoundaryWithStylesScript1Partial = '$RR("', completeBoundaryScript2 = '","', completeBoundaryScript3a = '",', completeBoundaryScript3b = '"', completeBoundaryScriptEnd = ")<\/script>", clientRenderScript1Full = '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("', clientRenderScript1Partial = '$RX("', clientRenderScript1A = '"', clientRenderErrorScriptArgInterstitial = ",", clientRenderScriptEnd = ")<\/script>", regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g, regexForJSStringsInScripts = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen1 = '<style media="not all" data-precedence="', lateStyleTagResourceOpen2 = '" data-href="', lateStyleTagResourceOpen3 = '">', lateStyleTagTemplateClose = "</style>", currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true, stylesheetFlushingQueue = [], styleTagResourceOpen1 = '<style data-precedence="', styleTagResourceOpen2 = '" data-href="', spaceSeparator = " ", styleTagResourceOpen3 = '">', styleTagResourceClose = "</style>", arrayFirstOpenBracket = "[", arraySubsequentOpenBracket = ",[", arrayInterstitial = ",", arrayCloseBracket = "]", PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g, doctypeChunk = "", bind2 = Function.prototype.bind, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), emptyContextObject = {};
      Object.freeze(emptyContextObject);
      var rendererSigil = {};
      var currentActiveSnapshot = null, didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
      var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
      var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
      var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
      var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
      var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
      var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
      var classComponentUpdater = {
        enqueueSetState: /* @__PURE__ */ __name(function(inst, payload, callback) {
          var internals = inst._reactInternals;
          null === internals.queue ? warnNoop(inst, "setState") : (internals.queue.push(payload), void 0 !== callback && null !== callback && warnOnInvalidCallback(callback));
        }, "enqueueSetState"),
        enqueueReplaceState: /* @__PURE__ */ __name(function(inst, payload, callback) {
          inst = inst._reactInternals;
          inst.replace = true;
          inst.queue = [payload];
          void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        }, "enqueueReplaceState"),
        enqueueForceUpdate: /* @__PURE__ */ __name(function(inst, callback) {
          null === inst._reactInternals.queue ? warnNoop(inst, "forceUpdate") : void 0 !== callback && null !== callback && warnOnInvalidCallback(callback);
        }, "enqueueForceUpdate")
      }, emptyTreeContext = { id: 1, overflow: "" }, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, SuspenseException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
      ), suspendedThenable = null, objectIs = "function" === typeof Object.is ? Object.is : is, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0, isInHookUserCodeInDev = false, currentHookNameInDev, HooksDispatcher = {
        readContext,
        use: /* @__PURE__ */ __name(function(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then)
              return unwrapThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE)
              return readContext(usable);
          }
          throw Error(
            "An unsupported type was passed to use(): " + String(usable)
          );
        }, "use"),
        useContext: /* @__PURE__ */ __name(function(context) {
          currentHookNameInDev = "useContext";
          resolveCurrentlyRenderingComponent();
          return context._currentValue2;
        }, "useContext"),
        useMemo: useMemo2,
        useReducer,
        useRef: /* @__PURE__ */ __name(function(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          return null === previousRef ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook.memoizedState = initialValue) : previousRef;
        }, "useRef"),
        useState: /* @__PURE__ */ __name(function(initialState) {
          currentHookNameInDev = "useState";
          return useReducer(basicStateReducer, initialState);
        }, "useState"),
        useInsertionEffect: noop$1,
        useLayoutEffect: noop$1,
        useCallback: /* @__PURE__ */ __name(function(callback, deps) {
          return useMemo2(function() {
            return callback;
          }, deps);
        }, "useCallback"),
        useImperativeHandle: noop$1,
        useEffect: noop$1,
        useDebugValue: noop$1,
        useDeferredValue: /* @__PURE__ */ __name(function(value, initialValue) {
          resolveCurrentlyRenderingComponent();
          return void 0 !== initialValue ? initialValue : value;
        }, "useDeferredValue"),
        useTransition: /* @__PURE__ */ __name(function() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }, "useTransition"),
        useId: /* @__PURE__ */ __name(function() {
          var treeId = currentlyRenderingTask.treeContext;
          var overflow = treeId.overflow;
          treeId = treeId.id;
          treeId = (treeId & ~(1 << 32 - clz32(treeId) - 1)).toString(32) + overflow;
          var resumableState = currentResumableState;
          if (null === resumableState)
            throw Error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component."
            );
          overflow = localIdCounter++;
          treeId = "\xAB" + resumableState.idPrefix + "R" + treeId;
          0 < overflow && (treeId += "H" + overflow.toString(32));
          return treeId + "\xBB";
        }, "useId"),
        useSyncExternalStore: /* @__PURE__ */ __name(function(subscribe, getSnapshot, getServerSnapshot) {
          if (void 0 === getServerSnapshot)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          return getServerSnapshot();
        }, "useSyncExternalStore"),
        useOptimistic: /* @__PURE__ */ __name(function(passthrough) {
          resolveCurrentlyRenderingComponent();
          return [passthrough, unsupportedSetOptimisticState];
        }, "useOptimistic"),
        useActionState,
        useFormState: useActionState,
        useHostTransitionStatus: /* @__PURE__ */ __name(function() {
          resolveCurrentlyRenderingComponent();
          return NotPending;
        }, "useHostTransitionStatus"),
        useMemoCache: /* @__PURE__ */ __name(function(size) {
          for (var data4 = Array(size), i = 0; i < size; i++)
            data4[i] = REACT_MEMO_CACHE_SENTINEL;
          return data4;
        }, "useMemoCache"),
        useCacheRefresh: /* @__PURE__ */ __name(function() {
          return unsupportedRefresh;
        }, "useCacheRefresh")
      }, currentResumableState = null, currentTaskInDEV = null, DefaultAsyncDispatcher = {
        getCacheForType: /* @__PURE__ */ __name(function() {
          throw Error("Not implemented.");
        }, "getCacheForType"),
        getOwner: /* @__PURE__ */ __name(function() {
          return null === currentTaskInDEV ? null : currentTaskInDEV.componentStack;
        }, "getOwner")
      }, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      disabledLog.__reactDisabledLog = true;
      var prefix3, suffix, reentry = false;
      var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
      var callComponent = {
        react_stack_bottom_frame: /* @__PURE__ */ __name(function(Component, props, secondArg) {
          return Component(props, secondArg);
        }, "react_stack_bottom_frame")
      }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
        react_stack_bottom_frame: /* @__PURE__ */ __name(function(instance) {
          return instance.render();
        }, "react_stack_bottom_frame")
      }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callLazyInit = {
        react_stack_bottom_frame: /* @__PURE__ */ __name(function(lazy) {
          var init2 = lazy._init;
          return init2(lazy._payload);
        }, "react_stack_bottom_frame")
      }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), lastResetTime = 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        var getCurrentTime = /* @__PURE__ */ __name(function() {
          return localPerformance.now();
        }, "getCurrentTime");
      } else {
        var localDate = Date;
        getCurrentTime = /* @__PURE__ */ __name(function() {
          return localDate.now();
        }, "getCurrentTime");
      }
      var CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, POSTPONED = 5, CLOSED = 14, currentRequest = null, didWarnAboutBadClass = {}, didWarnAboutContextTypes = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = false, didWarnAboutGenerators = false, didWarnAboutMaps = false;
      exports.renderToStaticMarkup = function(children, options) {
        return renderToStringImpl(
          children,
          options,
          true,
          'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server'
        );
      };
      exports.renderToString = function(children, options) {
        return renderToStringImpl(
          children,
          options,
          false,
          'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server'
        );
      };
      exports.version = "19.1.1";
    })();
  }
});

// node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/server.edge.js
var require_server_edge = __commonJS({
  "node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/server.edge.js"(exports) {
    "use strict";
    var b;
    var l;
    if (false) {
      b = null;
      l = null;
    } else {
      b = require_react_dom_server_edge_development();
      l = require_react_dom_server_legacy_browser_development();
    }
    exports.version = b.version;
    exports.renderToReadableStream = b.renderToReadableStream;
    exports.renderToString = l.renderToString;
    exports.renderToStaticMarkup = l.renderToStaticMarkup;
    if (b.resume) {
      exports.resume = b.resume;
    }
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/isCallable.js
function isCallable4(thing) {
  return thing instanceof Function || typeof thing === "function";
}
var init_isCallable4 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/isCallable.js"() {
    __name(isCallable4, "isCallable");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/objectAssign.js
function objectAssign3(obj, objAddendum) {
  Object.assign(obj, objAddendum);
}
var init_objectAssign3 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/objectAssign.js"() {
    __name(objectAssign3, "objectAssign");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/debug.js
function createDebugger2(namespace2, optionsGlobal) {
  const debugWithOptions = /* @__PURE__ */ __name((options) => {
    return (msg, info) => {
      if (!isDebugEnabled(namespace2))
        return;
      if (info !== void 0) {
        msg += strInfo(info, { ...optionsGlobal, ...options });
      }
      console.log("\x1B[1m%s\x1B[0m", namespace2, msg);
    };
  }, "debugWithOptions");
  const debug7 = /* @__PURE__ */ __name((msg, info) => debugWithOptions({})(msg, info), "debug");
  objectAssign3(debug7, { options: debugWithOptions, isEnabled: isDebugEnabled(namespace2) });
  return debug7;
}
function isDebugEnabled(namespace2) {
  var _a2;
  let DEBUG3;
  try {
    DEBUG3 = process.env.DEBUG;
  } catch {
  }
  return (_a2 = DEBUG3 === null || DEBUG3 === void 0 ? void 0 : DEBUG3.includes(namespace2)) !== null && _a2 !== void 0 ? _a2 : false;
}
function strInfo(info, options) {
  var _a2, _b;
  if (info === void 0) {
    return void 0;
  }
  let str = "\n";
  if (typeof info === "string") {
    str += info;
  } else if (Array.isArray(info)) {
    if (info.length === 0) {
      str += (_b = (_a2 = options.serialization) === null || _a2 === void 0 ? void 0 : _a2.emptyArray) !== null && _b !== void 0 ? _b : "[]";
    } else {
      str += info.map(strUnknown2).join("\n");
    }
  } else {
    str += strUnknown2(info);
  }
  str = pad2(str);
  return str;
}
function pad2(str) {
  const PADDING = "     ";
  const terminalWidth = getTerminalWidth2();
  const lines = [];
  str.split("\n").forEach((line) => {
    if (!terminalWidth) {
      lines.push(line);
    } else {
      chunk2(line, terminalWidth - PADDING.length).forEach((chunk3) => {
        lines.push(chunk3);
      });
    }
  });
  return lines.join("\n" + PADDING);
}
function chunk2(str, size) {
  if (str.length <= size) {
    return [str];
  }
  const chunks = str.match(new RegExp(".{1," + size + "}", "g"));
  assert4(chunks);
  return chunks;
}
function strUnknown2(thing) {
  return typeof thing === "string" ? thing : strObj2(thing);
}
function strObj2(obj, newLines = false) {
  return JSON.stringify(obj, replaceFunctionSerializer2, newLines ? 2 : void 0);
}
function replaceFunctionSerializer2(_key, value) {
  if (isCallable4(value)) {
    return value.toString().split(/\s+/).join(" ");
  }
  return value;
}
function getTerminalWidth2() {
  return typeof process !== "undefined" && typeof process.stdout !== "undefined" && process.stdout.columns || void 0;
}
var init_debug4 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/debug.js"() {
    init_isBrowser3();
    init_isCallable4();
    init_objectAssign3();
    init_assert4();
    assert4(!isBrowser4(), "utils/debug.js loaded in browser");
    __name(createDebugger2, "createDebugger");
    __name(isDebugEnabled, "isDebugEnabled");
    __name(strInfo, "strInfo");
    __name(pad2, "pad");
    __name(chunk2, "chunk");
    __name(strUnknown2, "strUnknown");
    __name(strObj2, "strObj");
    __name(replaceFunctionSerializer2, "replaceFunctionSerializer");
    __name(getTerminalWidth2, "getTerminalWidth");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/isPromise.js
function isPromise3(val) {
  return typeof val === "object" && val !== null && "then" in val && isCallable4(val.then);
}
var init_isPromise3 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/isPromise.js"() {
    init_isCallable4();
    __name(isPromise3, "isPromise");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/isVikeReactApp.js
function isVikeReactApp2() {
  const g2 = globalThis;
  return !!g2._isVikeReactApp;
}
var init_isVikeReactApp2 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/isVikeReactApp.js"() {
    __name(isVikeReactApp2, "isVikeReactApp");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/assertVersion.js
function assertVersion2(dependencyName, versionActual, versionExpected) {
  assert4(versionActual);
  assert4(versionExpected);
  assertUsage4(isVersionOrAbove2(versionActual, versionExpected), `${dependencyName} ${versionActual} isn't supported, use ${dependencyName} >= ${versionExpected} instead.`);
}
function isVersionOrAbove2(versionActual, versionExpected) {
  const p1 = parseVersion2(versionActual);
  const p2 = parseVersion2(versionExpected);
  if (p1[0] !== p2[0])
    return p1[0] > p2[0];
  if (p1[1] !== p2[1])
    return p1[1] > p2[1];
  if (p1[2] !== p2[2])
    return p1[2] > p2[2];
  return true;
}
function parseVersion2(version2) {
  version2 = version2.split("-")[0];
  let partsStr = version2.split(".");
  partsStr = partsStr.slice(0, 3);
  assert4(partsStr.length === 3);
  assert4(partsStr.every((s) => s.length > 0));
  const parts = partsStr.map((s) => parseInt(s, 10));
  return parts;
}
var init_assertVersion2 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/utils/assertVersion.js"() {
    init_assert4();
    __name(assertVersion2, "assertVersion");
    __name(isVersionOrAbove2, "isVersionOrAbove");
    __name(parseVersion2, "parseVersion");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/utils.js
var init_utils8 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/utils.js"() {
    init_assert4();
    init_debug4();
    init_isPromise3();
    init_isBrowser3();
    init_getGlobalObject3();
    init_isVikeReactApp2();
    init_assertVersion2();
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/useAsync/useSuspenseData.js
function SuspenseData({ children }) {
  const suspenses = {};
  return import_react.default.createElement(globalObject17.ctxSuspenses.Provider, { value: suspenses }, children);
}
var import_react, globalObject17;
var init_useSuspenseData = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/useAsync/useSuspenseData.js"() {
    import_react = __toESM(require_react());
    init_utils8();
    globalObject17 = getGlobalObject3("useSuspenseData.ts", {
      ctxSuspenses: import_react.default.createContext(void 0)
    });
    __name(SuspenseData, "SuspenseData");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/useStream.js
var import_react2, globalObject18, StreamProvider;
var init_useStream = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/useStream.js"() {
    init_picocolors();
    import_react2 = __toESM(require_react());
    init_utils8();
    globalObject18 = getGlobalObject3("useStream.ts", {
      StreamContext: import_react2.default.createContext(null)
    });
    StreamProvider = globalObject18.StreamContext.Provider;
  }
});

// node_modules/.pnpm/isbot-fast@1.2.0/node_modules/isbot-fast/index.js
var require_isbot_fast = __commonJS({
  "node_modules/.pnpm/isbot-fast@1.2.0/node_modules/isbot-fast/index.js"(exports, module2) {
    var bots = [
      // generic
      "bot",
      // googlebot, bingbot, telegrambot, twitterbot, yandexbot, etc.
      "check",
      "cloud",
      // cloudflare, cloudinary, etc.
      "crawler",
      "download",
      "monitor",
      // monitor & monitoring
      "preview",
      // skypeuripreview, bingpreview, yahoo link preview, etc.
      "scan",
      "spider",
      // baiduspider, 360spider, screaming frog seo spider, etc.
      // search engines
      "google",
      "qwantify",
      "yahoo",
      // aggregators, messengers and social networks
      "facebookexternalhit",
      "flipboard",
      "tumblr",
      "vkshare",
      "whatsapp",
      // downloaders
      "curl",
      "perl",
      "python",
      "wget",
      // high activity scanners
      "heritrix",
      "ia_archiver"
    ];
    var createRegex = /* @__PURE__ */ __name(() => new RegExp(`(${bots.join("|")})`, "i"), "createRegex");
    var isBotRegex = createRegex();
    module2.exports = (userAgent) => isBotRegex.test(userAgent);
    module2.exports.extend = (additionalBots) => {
      bots = [...new Set(bots.concat(additionalBots))];
      isBotRegex = createRegex();
    };
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream/resolveSeoStrategy.js
function resolveSeoStrategy(options = {}) {
  const seoStrategy = options.seoStrategy || "conservative";
  if (!options.userAgent) {
    showWarning();
    return { disableStream: true };
  }
  if (!(0, import_isbot_fast.default)(options.userAgent)) {
    return { disableStream: false };
  }
  const isGoogleBot = options.userAgent.toLowerCase().includes("googlebot");
  if (seoStrategy === "google-speed" && isGoogleBot) {
    return { disableStream: false };
  }
  return { disableStream: true };
}
function showWarning() {
  const isVikeReact = isVikeReactApp2();
  const link = isVikeReact ? "https://vike.dev/streaming" : "https://github.com/brillout/react-streaming";
  const help = isVikeReact ? `the HTTP request headers with ${picocolors_default.code("renderPage({ headersOriginal })")}` : picocolors_default.code("options.userAgent");
  const errMsg = [
    `HTML streaming (${link}) disabled because the User-Agent request header is unknown: make sure to provide`,
    `${help}.`,
    "The HTTP User-Agent request header is needed so that HTML streaming can automatically be disabled for bots and crawlers, see https://github.com/brillout/react-streaming#bots for more information."
  ];
  if (!isVikeReact) {
    errMsg.push(`Or set ${picocolors_default.code("options.disable")} to ${picocolors_default.code("true")} to suppress this warning.`);
  }
  assertWarning4(false, errMsg.join(" "), { onlyOnce: true });
}
var import_isbot_fast;
var init_resolveSeoStrategy = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream/resolveSeoStrategy.js"() {
    import_isbot_fast = __toESM(require_isbot_fast());
    init_picocolors();
    init_utils8();
    __name(resolveSeoStrategy, "resolveSeoStrategy");
    __name(showWarning, "showWarning");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream/common.js
function afterReactBugCatch(fn) {
  setTimeout(() => {
    fn();
  }, 0);
}
function assertReactImport(fn, fnName) {
  assert4(typeof fn === "function");
  assertUsage4(fn, `Couldn't import ${fnName}() from 'react-dom'`);
}
function wrapStreamEnd(streamEnd, didError) {
  return streamEnd.then(() => new Promise((r) => setTimeout(r, 0))).then(() => !didError);
}
var debugFlow;
var init_common = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream/common.js"() {
    init_utils8();
    debugFlow = createDebugger2("react-streaming:flow");
    __name(afterReactBugCatch, "afterReactBugCatch");
    __name(assertReactImport, "assertReactImport");
    __name(wrapStreamEnd, "wrapStreamEnd");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream.js
async function renderToStream(element, options = {}) {
  var _a2, _b;
  assertUsage4(!options.renderToPipeableStream && !options.renderToReadableStream, "using deprecated options");
  element = import_react3.default.createElement(SuspenseData, null, element);
  const buffer = [];
  let injectToStream = /* @__PURE__ */ __name(async (chunk3) => {
    buffer.push(chunk3);
  }, "injectToStream");
  const doNotClosePromise = { promise: null };
  let doNotCloseTimeout = null;
  const doNotClose = /* @__PURE__ */ __name(() => {
    let resolve;
    doNotClosePromise.promise = new Promise((r) => resolve = r);
    if (doNotCloseTimeout)
      clearTimeout(doNotCloseTimeout);
    doNotCloseTimeout = setTimeout(() => {
      assertUsage4(false, "makeClosableAgain() not called after 10 seconds (`const makeClosableAgain = stream.doNotClose()`)");
    }, 10 * 1e3);
    const makeClosableAgain = /* @__PURE__ */ __name(() => {
      resolve();
      clearTimeout(doNotCloseTimeout);
    }, "makeClosableAgain");
    return makeClosableAgain;
  }, "doNotClose");
  let abortFn;
  const setAbortFn = /* @__PURE__ */ __name((fn) => abortFn = fn, "setAbortFn");
  const streamTimeout = (() => {
    var _a3;
    if (options.timeout === null)
      return null;
    return setTimeout(() => {
      var _a4;
      assert4(abortFn);
      abortFn();
      (_a4 = options.onTimeout) === null || _a4 === void 0 ? void 0 : _a4.call(options);
    }, ((_a3 = options.timeout) !== null && _a3 !== void 0 ? _a3 : 20) * 1e3);
  })();
  const clearTimeouts = /* @__PURE__ */ __name(() => {
    if (streamTimeout !== null)
      clearTimeout(streamTimeout);
    if (doNotCloseTimeout !== null)
      clearTimeout(doNotCloseTimeout);
  }, "clearTimeouts");
  let hasStreamEnded = /* @__PURE__ */ __name(() => false, "hasStreamEnded");
  element = import_react3.default.createElement(StreamProvider, {
    value: {
      injectToStream: /* @__PURE__ */ __name((chunk3, options2) => injectToStream(chunk3, options2), "injectToStream"),
      hasStreamEnded: /* @__PURE__ */ __name(() => hasStreamEnded(), "hasStreamEnded"),
      doNotClose
    }
  }, element);
  const disable2 = globalConfig.disable || ((_a2 = options.disable) !== null && _a2 !== void 0 ? _a2 : resolveSeoStrategy(options).disableStream);
  const webStream = (_b = options.webStream) !== null && _b !== void 0 ? _b : !globalObject19.renderToNodeStream;
  debugFlow(`disable === ${disable2} && webStream === ${webStream}`);
  let ret;
  const retCommon = { disabled: disable2, doNotClose };
  if (!webStream) {
    ret = {
      ...retCommon,
      ...await globalObject19.renderToNodeStream(element, disable2, options, doNotClosePromise, setAbortFn, clearTimeouts)
    };
  } else {
    assert4(globalObject19.renderToWebStream);
    ret = {
      ...retCommon,
      ...await globalObject19.renderToWebStream(element, disable2, options, doNotClosePromise, setAbortFn, clearTimeouts)
    };
  }
  injectToStream = ret.injectToStream;
  buffer.forEach((chunk3) => injectToStream(chunk3));
  buffer.length = 0;
  hasStreamEnded = ret.hasStreamEnded;
  debugFlow("promise `await renderToStream()` resolved");
  return ret;
}
function renderToWebStream_set(renderToWebStream2) {
  globalObject19.renderToWebStream = renderToWebStream2;
}
function assertReact() {
  const versionMajor = parseInt(import_server.version.split(".")[0], 10);
  assertUsage4(versionMajor >= 18, `\`react-dom@${import_server.version}\` was loaded, but react-streaming only works with React version 18 or greater.`);
  assert4(typeof import_server.default.renderToPipeableStream === "function" || typeof import_server.default.renderToReadableStream === "function");
}
var import_react3, import_server, globalObject19, globalConfig;
var init_renderToStream = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream.js"() {
    import_react3 = __toESM(require_react());
    import_server = __toESM(require_server_edge());
    init_useSuspenseData();
    init_useStream();
    init_resolveSeoStrategy();
    init_utils8();
    init_common();
    globalObject19 = getGlobalObject3("renderToStream.ts", {
      renderToNodeStream: null,
      renderToWebStream: null
    });
    assertReact();
    globalConfig = globalThis.__react_streaming = globalThis.__react_streaming || {
      disable: false
    };
    __name(renderToStream, "renderToStream");
    __name(renderToWebStream_set, "renderToWebStream_set");
    __name(assertReact, "assertReact");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/index.js
var init_server2 = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/index.js"() {
    init_assert4();
    init_isBrowser3();
    init_renderToStream();
    assertUsage4(!isBrowser4(), "The file node_modules/react-streaming/dist/{esm,cjs}/server/index.js is loaded in the browser but it shouldn't. Make sure to never `import { something } from 'react-streaming/server'` in code that runs on the client-side. Also make sure your bundler picks the right node_modules/react-streaming/package.json#exports entries.");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream/orchestrateChunks.js
function orchestrateChunks(streamOperations, doNotClosePromise) {
  let hasEnded = false;
  let lastWritePromise = null;
  let firstReactWritePromise_resolve;
  let firstReactWritePromise = new Promise((resolve) => {
    firstReactWritePromise_resolve = /* @__PURE__ */ __name(() => {
      if (firstReactWritePromise === null)
        return;
      firstReactWritePromise = null;
      resolve();
    }, "firstReactWritePromise_resolve");
  });
  let isFirstReactWrite = true;
  return { injectToStream, onReactWrite, onBeforeEnd, hasStreamEnded: /* @__PURE__ */ __name(() => hasEnded, "hasStreamEnded") };
  function injectToStream(chunk3, options) {
    if (debug5.isEnabled)
      debug5("injectToStream()", getChunkAsString(chunk3));
    if (hasEnded) {
      assertUsage4(false, `Cannot inject the following chunk because the stream has already ended. Consider using the doNotClose() and hasStreamEnded() utilities. The chunk:
${getChunkAsString(chunk3)}`);
    }
    writeChunkInSequence(chunk3, options === null || options === void 0 ? void 0 : options.flush);
  }
  __name(injectToStream, "injectToStream");
  function writeChunkInSequence(chunk3, flush) {
    const lastWritePromisePrevious = lastWritePromise;
    lastWritePromise = (async () => {
      if (firstReactWritePromise)
        await firstReactWritePromise;
      if (lastWritePromisePrevious)
        await lastWritePromisePrevious;
      if (isPromise3(chunk3))
        chunk3 = await chunk3;
      writeChunkNow(chunk3, flush);
    })();
  }
  __name(writeChunkInSequence, "writeChunkInSequence");
  function writeChunkNow(chunk3, flush) {
    assert4(!hasEnded);
    assert4(streamOperations.operations);
    streamOperations.operations.writeChunk(chunk3);
    if (debug5.isEnabled)
      debug5(">>> WRITE", getChunkAsString(chunk3));
    if (flush && streamOperations.operations.flush !== null) {
      streamOperations.operations.flush();
      debug5(">>> FLUSH");
    }
  }
  __name(writeChunkNow, "writeChunkNow");
  function onReactWrite(chunk3) {
    if (debug5.isEnabled)
      debug5("onReactWrite()", getChunkAsString(chunk3));
    assert4(!hasEnded);
    const flush = true;
    if (isFirstReactWrite) {
      debug5(">>> START");
      writeChunkNow(chunk3, flush);
      setTimeout(() => {
        isFirstReactWrite = false;
        firstReactWritePromise_resolve();
      }, 0);
    } else {
      writeChunkInSequence(chunk3, flush);
    }
  }
  __name(onReactWrite, "onReactWrite");
  async function onBeforeEnd() {
    firstReactWritePromise_resolve();
    await new Promise((r) => setTimeout(r, 0));
    await doNotClosePromise.promise;
    await lastWritePromise;
    hasEnded = true;
    debug5(">>> END");
  }
  __name(onBeforeEnd, "onBeforeEnd");
}
function getChunkAsString(chunk3) {
  try {
    return new TextDecoder().decode(chunk3);
  } catch (err) {
    return String(chunk3);
  }
}
var debug5;
var init_orchestrateChunks = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream/orchestrateChunks.js"() {
    init_utils8();
    debug5 = createDebugger2("react-streaming:chunks");
    __name(orchestrateChunks, "orchestrateChunks");
    __name(getChunkAsString, "getChunkAsString");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream/createReadableWrapper.js
function createReadableWrapper(readableFromReact, clearTimeouts, doNotClosePromise) {
  const streamOperations = {
    operations: null
  };
  let controllerOfUserStream;
  let onEnded;
  const streamEnd = new Promise((r) => {
    onEnded = /* @__PURE__ */ __name(() => r(), "onEnded");
  });
  const readableForUser = new ReadableStream({
    start(controller) {
      controllerOfUserStream = controller;
      onReady(onEnded);
    }
  });
  const { injectToStream, onReactWrite, onBeforeEnd, hasStreamEnded } = orchestrateChunks(streamOperations, doNotClosePromise);
  return { readableForUser, streamEnd, injectToStream, hasStreamEnded };
  async function onReady(onEnded2) {
    streamOperations.operations = {
      writeChunk(chunk3) {
        controllerOfUserStream.enqueue(encodeForWebStream2(chunk3));
      },
      flush: null
    };
    const reader = readableFromReact.getReader();
    while (true) {
      let result;
      try {
        result = await reader.read();
      } catch (err) {
        controllerOfUserStream.close();
        throw err;
      }
      const { value, done } = result;
      if (done) {
        break;
      }
      onReactWrite(value);
    }
    clearTimeouts();
    await onBeforeEnd();
    controllerOfUserStream.close();
    onEnded2();
  }
  __name(onReady, "onReady");
}
function encodeForWebStream2(thing) {
  if (!encoder2) {
    encoder2 = new TextEncoder();
  }
  if (typeof thing === "string") {
    return encoder2.encode(thing);
  }
  return thing;
}
var encoder2;
var init_createReadableWrapper = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream/createReadableWrapper.js"() {
    init_orchestrateChunks();
    __name(createReadableWrapper, "createReadableWrapper");
    __name(encodeForWebStream2, "encodeForWebStream");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream/renderToWebStream.js
async function renderToWebStream(element, disable2, options, doNotClosePromise, setAbortFn, clearTimeouts) {
  var _a2;
  debugFlow("creating Web Stream Pipe");
  assertVersion2("React", import_server2.version, "19.0.0");
  const { renderToReadableStream: renderToReadableStream_ } = await Promise.resolve().then(() => __toESM(require_server_edge()));
  const controller = new AbortController();
  setAbortFn(() => {
    controller.abort();
  });
  let didError = false;
  let firstErr = null;
  let reactBug = null;
  const onError = /* @__PURE__ */ __name((err) => {
    didError = true;
    firstErr = firstErr || err;
    afterReactBugCatch(() => {
      var _a3;
      if (err !== reactBug) {
        (_a3 = options.onBoundaryError) === null || _a3 === void 0 ? void 0 : _a3.call(options, err);
      }
    });
  }, "onError");
  const renderToReadableStream = (_a2 = options.renderToReadableStream) !== null && _a2 !== void 0 ? _a2 : renderToReadableStream_;
  if (!options.renderToReadableStream) {
    assertReactImport(renderToReadableStream, "renderToReadableStream");
  }
  const readableOriginal = await renderToReadableStream(element, {
    onError,
    signal: controller.signal,
    ...options.streamOptions
  });
  const { allReady } = readableOriginal;
  let promiseResolved = false;
  allReady.catch((err) => {
    debugFlow("react bug");
    didError = true;
    firstErr = firstErr || err;
    reactBug = err;
    if (reactBug !== firstErr || promiseResolved) {
      console.error(reactBug);
    }
  });
  if (didError)
    throw firstErr;
  if (disable2)
    await allReady;
  if (didError)
    throw firstErr;
  const { readableForUser, streamEnd, injectToStream, hasStreamEnded } = createReadableWrapper(readableOriginal, clearTimeouts, doNotClosePromise);
  promiseResolved = true;
  return {
    readable: readableForUser,
    pipe: null,
    abort: controller.abort,
    streamEnd: wrapStreamEnd(streamEnd, didError),
    injectToStream,
    hasStreamEnded
  };
}
var import_server2;
var init_renderToWebStream = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/renderToStream/renderToWebStream.js"() {
    init_createReadableWrapper();
    init_common();
    import_server2 = __toESM(require_server_edge());
    init_utils8();
    __name(renderToWebStream, "renderToWebStream");
  }
});

// node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/index.web-only.js
var init_index_web_only = __esm({
  "node_modules/.pnpm/react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/react-streaming/dist/esm/server/index.web-only.js"() {
    init_server2();
    init_renderToWebStream();
    init_renderToStream();
    renderToWebStream_set(renderToWebStream);
  }
});

// node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js"(exports, module2) {
    (function() {
      "use strict";
      var hasOwn2 = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      __name(classNames2, "classNames");
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn2.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      __name(parseValue, "parseValue");
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      __name(appendClass, "appendClass");
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames2.default = classNames2;
        module2.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// node_modules/.pnpm/@whatwg-node+promise-helpers@1.3.2/node_modules/@whatwg-node/promise-helpers/esm/index.js
function isPromise4(value) {
  return value?.then != null;
}
function isActualPromise(value) {
  const maybePromise = value;
  return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;
}
function handleMaybePromise(inputFactory, outputSuccessFactory, outputErrorFactory, finallyFactory) {
  let result$ = fakePromise().then(inputFactory).then(outputSuccessFactory, outputErrorFactory);
  if (finallyFactory) {
    result$ = result$.finally(finallyFactory);
  }
  return unfakePromise(result$);
}
function fakePromise(value) {
  if (value && isActualPromise(value)) {
    return value;
  }
  if (isPromise4(value)) {
    return {
      then: /* @__PURE__ */ __name((resolve, reject) => fakePromise(value.then(resolve, reject)), "then"),
      catch: /* @__PURE__ */ __name((reject) => fakePromise(value.then((res) => res, reject)), "catch"),
      finally: /* @__PURE__ */ __name((cb) => fakePromise(cb ? promiseLikeFinally(value, cb) : value), "finally"),
      [Symbol.toStringTag]: "Promise"
    };
  }
  return {
    then(resolve) {
      if (resolve) {
        try {
          return fakePromise(resolve(value));
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    catch() {
      return this;
    },
    finally(cb) {
      if (cb) {
        try {
          return fakePromise(cb()).then(() => value, () => value);
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    [Symbol.toStringTag]: "Promise",
    __fakePromiseValue: value,
    [kFakePromise]: "resolved"
  };
}
function fakeRejectPromise(error) {
  return {
    then(_resolve, reject) {
      if (reject) {
        try {
          return fakePromise(reject(error));
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    catch(reject) {
      if (reject) {
        try {
          return fakePromise(reject(error));
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    finally(cb) {
      if (cb) {
        try {
          cb();
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    __fakeRejectError: error,
    [Symbol.toStringTag]: "Promise",
    [kFakePromise]: "rejected"
  };
}
function isFakePromise(value) {
  return value?.[kFakePromise] === "resolved";
}
function isFakeRejectPromise(value) {
  return value?.[kFakePromise] === "rejected";
}
function promiseLikeFinally(value, onFinally) {
  if ("finally" in value) {
    return value.finally(onFinally);
  }
  return value.then((res) => {
    const finallyRes = onFinally();
    return isPromise4(finallyRes) ? finallyRes.then(() => res) : res;
  }, (err) => {
    const finallyRes = onFinally();
    if (isPromise4(finallyRes)) {
      return finallyRes.then(() => {
        throw err;
      });
    } else {
      throw err;
    }
  });
}
function unfakePromise(promise) {
  if (isFakePromise(promise)) {
    return promise.__fakePromiseValue;
  }
  if (isFakeRejectPromise(promise)) {
    throw promise.__fakeRejectError;
  }
  return promise;
}
var kFakePromise;
var init_esm2 = __esm({
  "node_modules/.pnpm/@whatwg-node+promise-helpers@1.3.2/node_modules/@whatwg-node/promise-helpers/esm/index.js"() {
    kFakePromise = Symbol.for("@whatwg-node/promise-helpers/FakePromise");
    __name(isPromise4, "isPromise");
    __name(isActualPromise, "isActualPromise");
    __name(handleMaybePromise, "handleMaybePromise");
    __name(fakePromise, "fakePromise");
    __name(fakeRejectPromise, "fakeRejectPromise");
    __name(isFakePromise, "isFakePromise");
    __name(isFakeRejectPromise, "isFakeRejectPromise");
    __name(promiseLikeFinally, "promiseLikeFinally");
    __name(unfakePromise, "unfakePromise");
  }
});

// node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/SupressedError.js
var PonyfillSuppressedError;
var init_SupressedError = __esm({
  "node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/SupressedError.js"() {
    PonyfillSuppressedError = class extends Error {
      static {
        __name(this, "PonyfillSuppressedError");
      }
      error;
      suppressed;
      // eslint-disable-next-line n/handle-callback-err
      constructor(error, suppressed, message) {
        super(message);
        this.error = error;
        this.suppressed = suppressed;
        this.name = "SuppressedError";
        Error.captureStackTrace(this, this.constructor);
      }
    };
  }
});

// node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/symbols.js
function patchSymbols() {
  Symbol.dispose ||= Symbol.for("dispose");
  Symbol.asyncDispose ||= Symbol.for("asyncDispose");
}
var DisposableSymbols;
var init_symbols = __esm({
  "node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/symbols.js"() {
    DisposableSymbols = {
      get dispose() {
        return Symbol.dispose || Symbol.for("dispose");
      },
      get asyncDispose() {
        return Symbol.asyncDispose || Symbol.for("asyncDispose");
      }
    };
    __name(patchSymbols, "patchSymbols");
  }
});

// node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/utils.js
function isSyncDisposable(obj) {
  return obj?.[DisposableSymbols.dispose] != null;
}
function isAsyncDisposable(obj) {
  return obj?.[DisposableSymbols.asyncDispose] != null;
}
var init_utils9 = __esm({
  "node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/utils.js"() {
    init_symbols();
    __name(isSyncDisposable, "isSyncDisposable");
    __name(isAsyncDisposable, "isAsyncDisposable");
  }
});

// node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/AsyncDisposableStack.js
var SuppressedError2, PonyfillAsyncDisposableStack;
var init_AsyncDisposableStack = __esm({
  "node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/AsyncDisposableStack.js"() {
    init_esm2();
    init_SupressedError();
    init_symbols();
    init_utils9();
    SuppressedError2 = globalThis.SuppressedError || PonyfillSuppressedError;
    PonyfillAsyncDisposableStack = class _PonyfillAsyncDisposableStack {
      static {
        __name(this, "PonyfillAsyncDisposableStack");
      }
      callbacks = [];
      get disposed() {
        return this.callbacks.length === 0;
      }
      use(value) {
        if (isAsyncDisposable(value)) {
          this.callbacks.push(() => value[DisposableSymbols.asyncDispose]());
        } else if (isSyncDisposable(value)) {
          this.callbacks.push(() => value[DisposableSymbols.dispose]());
        }
        return value;
      }
      adopt(value, onDisposeAsync) {
        if (onDisposeAsync) {
          this.callbacks.push(() => onDisposeAsync(value));
        }
        return value;
      }
      defer(onDisposeAsync) {
        if (onDisposeAsync) {
          this.callbacks.push(onDisposeAsync);
        }
      }
      move() {
        const stack = new _PonyfillAsyncDisposableStack();
        stack.callbacks = this.callbacks;
        this.callbacks = [];
        return stack;
      }
      disposeAsync() {
        return this[DisposableSymbols.asyncDispose]();
      }
      _error;
      _iterateCallbacks() {
        const cb = this.callbacks.pop();
        if (cb) {
          return handleMaybePromise(cb, () => this._iterateCallbacks(), (error) => {
            this._error = this._error ? new SuppressedError2(error, this._error) : error;
            return this._iterateCallbacks();
          });
        }
      }
      [DisposableSymbols.asyncDispose]() {
        const res$ = this._iterateCallbacks();
        if (res$?.then) {
          return res$.then(() => {
            if (this._error) {
              const error = this._error;
              this._error = void 0;
              throw error;
            }
          });
        }
        if (this._error) {
          const error = this._error;
          this._error = void 0;
          throw error;
        }
        return void 0;
      }
      [Symbol.toStringTag] = "AsyncDisposableStack";
    };
  }
});

// node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/DisposableStack.js
var SuppressedError3, PonyfillDisposableStack;
var init_DisposableStack = __esm({
  "node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/DisposableStack.js"() {
    init_SupressedError();
    init_symbols();
    init_utils9();
    SuppressedError3 = globalThis.SuppressedError || PonyfillSuppressedError;
    PonyfillDisposableStack = class _PonyfillDisposableStack {
      static {
        __name(this, "PonyfillDisposableStack");
      }
      callbacks = [];
      get disposed() {
        return this.callbacks.length === 0;
      }
      use(value) {
        if (isSyncDisposable(value)) {
          this.callbacks.push(() => value[DisposableSymbols.dispose]());
        }
        return value;
      }
      adopt(value, onDispose) {
        if (onDispose) {
          this.callbacks.push(() => onDispose(value));
        }
        return value;
      }
      defer(onDispose) {
        if (onDispose) {
          this.callbacks.push(onDispose);
        }
      }
      move() {
        const stack = new _PonyfillDisposableStack();
        stack.callbacks = this.callbacks;
        this.callbacks = [];
        return stack;
      }
      dispose() {
        return this[DisposableSymbols.dispose]();
      }
      _error;
      _iterateCallbacks() {
        const cb = this.callbacks.pop();
        if (cb) {
          try {
            cb();
          } catch (error) {
            this._error = this._error ? new SuppressedError3(error, this._error) : error;
          }
          return this._iterateCallbacks();
        }
      }
      [DisposableSymbols.dispose]() {
        this._iterateCallbacks();
        if (this._error) {
          const error = this._error;
          this._error = void 0;
          throw error;
        }
      }
      [Symbol.toStringTag] = "DisposableStack";
    };
  }
});

// node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AsyncDisposableStack: () => AsyncDisposableStack2,
  DisposableStack: () => DisposableStack2,
  DisposableSymbols: () => DisposableSymbols,
  SuppressedError: () => SuppressedError4,
  patchSymbols: () => patchSymbols
});
var DisposableStack2, AsyncDisposableStack2, SuppressedError4;
var init_esm3 = __esm({
  "node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/index.js"() {
    init_AsyncDisposableStack();
    init_DisposableStack();
    init_SupressedError();
    init_symbols();
    DisposableStack2 = globalThis.DisposableStack || PonyfillDisposableStack;
    AsyncDisposableStack2 = globalThis.AsyncDisposableStack || PonyfillAsyncDisposableStack;
    SuppressedError4 = globalThis.SuppressedError || PonyfillSuppressedError;
  }
});

// .dev/build/sky.examples.platform.web/web/server/chunks/chunk-D8IZrfLU.js
async function onRenderHtml(pageContext, html) {
  const stream = await renderToStream(
    /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("html", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("head", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("meta", { charSet: "UTF-8" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("meta", { name: "viewport", content: "width=device-width, initial-scale=1.0" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("link", { rel: "icon", href: faviconSvg }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("title", { children: "EmptySet" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("body", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { id: "root", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(pageContext.Page, {}) }) })
    ] }),
    {
      userAgent: pageContext.headers?.["user-agent"] ?? "unknown"
    }
  );
  const documentHtml = escapeInject`<!DOCTYPE html>${stream}`;
  return {
    documentHtml,
    pageContext: {
      // We can add custom pageContext properties here, see https://vike.dev/pageContext#custom
    }
  };
}
function initPlatform() {
  if (runsOnSide === "client") {
    window.global = window;
  }
}
function init() {
  if (local$7.isHot) {
    return;
  }
  Object.defineProperty(global, "isRuntime", {
    get() {
      return false;
    },
    set() {
      Object.defineProperty(global, "isRuntime", {
        configurable: false,
        enumerable: true,
        get() {
          return true;
        },
        set() {
        }
      });
      local$7.resolveRuntime();
    },
    configurable: true,
    enumerable: true
  });
}
function array(array2) {
  Object.setPrototypeOf(array2, arrayPrototype);
  return array2;
}
function makePlain(schema) {
  const propertiesMap = local$5.reactivePropertyDescriptors(schema);
  function Object2(object) {
    assign(this, object);
    return this;
  }
  __name(Object2, "Object2");
  Object2.schema = schema;
  Object2.prototype = defineProperties({ constructor: Object2 }, propertiesMap);
  return Object2;
}
function observe(target, schema, callbacks) {
  as(target);
  if (target[local$5.idSymbol] == null) {
    target[local$5.idSymbol] = ++local$5.uniqueId;
  }
  const map = target[local$5.listenersOfShared] ??= /* @__PURE__ */ new Map();
  for (let i = 0; i < callbacks.length; ++i) {
    const callback = callbacks[i];
    if (map.has(callback)) {
      map.set(callback, map.get(callback) + 1);
    } else {
      map.set(callback, 1);
    }
  }
  if (Array.isArray(target)) {
    target.forEach((value) => {
      if (typeof value === "object") {
        observe(value, value.constructor.schema, callbacks);
      }
    });
  } else {
    Object.keys(schema).forEach((k) => {
      const property2 = schema[k];
      if (typeof property2 === "object") {
        observe(target[k], property2, callbacks);
      }
    });
  }
}
function unobserve(target, schema, callbacks) {
  as(target);
  const map = target[local$5.listenersOfShared];
  for (let i = 0; i < callbacks.length; ++i) {
    const callback = callbacks[i];
    const counter = map.get(callback);
    if (counter == null) {
      throw NullError;
    }
    if (counter > 1) {
      map.set(callback, counter - 1);
    } else {
      map.delete(callback);
    }
  }
  if (Array.isArray(target)) {
    target.forEach((value) => {
      if (typeof value === "object") {
        unobserve(value, value.constructor.schema, callbacks);
      }
    });
  } else {
    Object.keys(schema).forEach((k) => {
      const property2 = schema[k];
      if (typeof property2 === "object") {
        unobserve(target[k], property2, callbacks);
      }
    });
  }
}
function toPrimitive(value) {
  if (typeof value === "object" || typeof value === "function") {
    as(value);
    if (value[local$5.idSymbol] == null) {
      throw typeof value === "object" ? Error("unknown object") : Error("unknown function");
    }
    return value[local$5.idSymbol];
  }
  return value;
}
function commit(callback) {
  const plainUpdates = [];
  const plainCreateUpdates = [UpdateOfShared.Type.CREATE, []];
  plainUpdates[0] = plainCreateUpdates;
  const plainDestroyUpdates = [UpdateOfShared.Type.DESTROY, []];
  plainUpdates[1] = plainDestroyUpdates;
  const plainSetUpdates = [UpdateOfShared.Type.SET, []];
  plainUpdates[2] = plainSetUpdates;
  const prettyUpdates = {
    create: [],
    destroy: [],
    set: []
  };
  callback.set.forEach((set, object) => {
    const prettySet = {};
    const keys = Object.keys(object.constructor.schema);
    set.forEach((value, i) => {
      const key = keys[i];
      prettySet[key] = value;
    });
    plainSetUpdates[1].push([
      object[local$5.idSymbol],
      set.reduce(
        (array2, value, i) => {
          return array2.concat([i, toPrimitive(value)]);
        },
        []
      )
    ]);
    prettyUpdates.set.push([
      object.constructor[local$5.uidSymbol],
      object[local$5.idSymbol],
      prettySet
    ]);
  });
  callback(plainUpdates, prettyUpdates);
}
function queueCommit(callback) {
  callback.isWaitingCommit = true;
  async(async () => {
    await switch_thread();
    commit(callback);
  });
}
function reactivePropertyDescriptors(schema) {
  const propertiesMap = {};
  const schemaKeys = Object.keys(schema);
  schemaKeys.map((k, i) => {
    const property2 = schema[k];
    const valueSymbol = `${k}_`;
    if (typeof property2 === "object") {
      property2[local$5.constructorSymbol] ??= local$5.makePlain(property2);
    }
    function get_primitive() {
      return this[valueSymbol];
    }
    __name(get_primitive, "get_primitive");
    function set_primitive(value) {
      if (this[local$5.listenersOfShared] != null) {
        const map = this[local$5.listenersOfShared];
        map.forEach((k2, callback) => {
          as(callback);
          callback.set ??= /* @__PURE__ */ new Map();
          if (callback.set.has(this)) {
            const set = callback.set.get(this);
            set[i] = value;
          } else {
            const set = [];
            callback.set.set(this, set);
            set[i] = value;
          }
          if (!callback.isWaitingCommit) {
            queueCommit(callback);
          }
        });
      }
      this[valueSymbol] = value;
    }
    __name(set_primitive, "set_primitive");
    function set_array_or_object(object) {
      if (!Array.isArray(object) && object.constructor.schema == null) {
        object = new property2[local$5.constructorSymbol](object);
      }
      const previousObject = this[valueSymbol];
      if (this[local$5.listenersOfShared] != null) {
        if (previousObject != null) {
          if (previousObject.constructor == null) {
            throw NullError;
          }
          local$5.unobserve(previousObject, previousObject.constructor.schema, [
            ...this[local$5.listenersOfShared].keys()
          ]);
        }
        if (object != null) {
          local$5.observe(object, object.constructor.schema, [
            ...this[local$5.listenersOfShared].keys()
          ]);
        }
      }
      set_primitive.call(this, object);
    }
    __name(set_array_or_object, "set_array_or_object");
    if (property2 == null) ;
    else if (Array.isArray(property2)) {
      propertiesMap[k] = {
        get: get_primitive,
        set: set_array_or_object,
        enumerable: true,
        configurable: true
      };
    } else if (typeof property2 === "object" || typeof property2 === "function") {
      propertiesMap[k] = {
        get: get_primitive,
        set: set_array_or_object,
        enumerable: true,
        configurable: true
      };
    } else {
      propertiesMap[k] = {
        get: get_primitive,
        set: set_primitive,
        enumerable: true,
        configurable: true
      };
    }
  });
  return propertiesMap;
}
function globalify(module2) {
  mergeNamespaces(global, module2);
}
function captureUI(effect) {
  const root = effect instanceof Effect ? effect.root : effect;
  return {
    onTouchStart() {
      root.isUICaptured = true;
    },
    onTouchMove() {
      root.isUICaptured = true;
    },
    onTouchEnd() {
      root.isUICaptured = true;
    },
    onMouseDown() {
      root.isUICaptured = true;
    },
    onMouseMove() {
      root.isUICaptured = true;
    },
    onMouseUp() {
      root.isUICaptured = true;
    },
    onClick() {
      root.isUICaptured = true;
    }
  };
}
function bind(target, propertyKey, descriptor) {
  const key = Symbol();
  return {
    configurable: true,
    set(value_) {
      this[key] = value_.bind(this);
    },
    get() {
      if (this[key] == null) {
        if (!descriptor) {
          return void 0;
        }
        this[key] = descriptor.value.bind(this);
      }
      return this[key];
    }
  };
}
function __fetchArgs(url, requestInit = {}) {
  const resultRequestInit = { ...requestInit };
  delete resultRequestInit.params;
  let resultUrl = url.toString();
  const { headers, params, credentials } = requestInit;
  if (params) {
    if (!requestInit.method || requestInit.method === "GET") {
      const searchParams = new URLSearchParams();
      let size = 0;
      Object.keys(params).forEach((k) => {
        if (params[k] != null) {
          searchParams.set(k, params[k].toString());
          ++size;
        }
      });
      if (size > 0) {
        resultUrl += "?" + searchParams.toString();
      }
    } else {
      resultRequestInit.body = JSON.stringify(requestInit.params);
    }
  }
  if (headers) {
    resultRequestInit.headers = headers;
  }
  if (credentials) {
    resultRequestInit.credentials = credentials;
  }
  return [resultUrl, resultRequestInit];
}
async function idle$1(timeout) {
  return await new Promise((resolve) => setTimeout(resolve, timeout.valueOf() * 1e3));
}
async function justTry(fn) {
  try {
    return await fn();
  } catch (err) {
  }
}
function hook$1(prototype, k, descriptor) {
  as(prototype);
  if (Object.getOwnPropertyDescriptor(prototype, "__hooks")?.value !== prototype.__hooks) {
    const parentHooks = prototype.__hooks;
    prototype.__hooks = {};
    Object.setPrototypeOf(prototype.__hooks, parentHooks);
  }
  prototype.__hooks ??= {};
  if (Object.getOwnPropertyDescriptor(prototype, "__bakedHooks")?.value !== prototype.__bakedHooks) {
    prototype.__bakedHooks = {};
  }
  prototype.__bakedHooks ??= {};
  if (prototype.__hooks[k]) {
    let hook2 = prototype.__hooks[k];
    while (hook2.next) {
      hook2 = hook2.next;
    }
    hook2.next = descriptor.value;
  } else {
    prototype.__hooks[k] = descriptor.value;
  }
}
function emitWithHooks$1(eventName, hooksOwner, recipient, emitEvent, ...args) {
  as(hooksOwner);
  if (hooksOwner.__hooks) {
    if (hooksOwner.__bakedHooks[eventName] == null) {
      let hook2 = hooksOwner.__hooks[eventName];
      let onAny = hooksOwner.__hooks.onAny;
      let current = emitEvent;
      while (hook2 != null) {
        let next2 = /* @__PURE__ */ __name(function(...args2) {
          original.call(this, eventName, ...args2);
        }, "next2");
        const original = current;
        const hook_ = hook2;
        current = /* @__PURE__ */ __name(function(eventName2, ...args2) {
          hook_.call(this, next2, ...args2);
        }, "current");
        hook2 = hook2.next;
      }
      while (onAny != null) {
        let next2 = /* @__PURE__ */ __name(function(...args2) {
          original.call(this, eventName, ...args2);
        }, "next2");
        const original = current;
        const onAny_ = onAny;
        current = /* @__PURE__ */ __name(function(eventName2, ...args2) {
          onAny_.call(this, next2, eventName2, ...args2);
        }, "current");
        onAny = onAny.next;
      }
      hooksOwner.__bakedHooks[eventName] = current;
    }
    hooksOwner.__bakedHooks[eventName].call(recipient, eventName, ...args);
  } else {
    emitEvent.call(recipient, eventName, ...args);
  }
}
function initServices() {
  async(async () => {
    await runtime;
    for (const singleton of local.singletons) {
      const [promise, resolve] = Promise.new();
      as(promise);
      promise[local.promiseResolveSymbol] = resolve;
      promise[local.promiseSingletonSymbol] = singleton;
      singleton[local.singletonCreatePromiseSymbol] = promise;
      singleton[Symbol.asyncCreate] = promise;
    }
    for (const singleton of local.singletons) {
      if (singleton[local.singletonSymbol] === true) {
        throw new CircularSingletonDependencyError(singleton);
      } else if (singleton[local.singletonSymbol] != null) {
        continue;
      }
      await local.createSingleton(singleton);
    }
    for (const singleton of local.singletons) {
      delete singleton[local.singletonOnErrorSymbol];
    }
  });
}
function isUndefined(value) {
  return value === void 0;
}
function asUndefined(value) {
  if (!isUndefined(value)) {
    throw Error("not an undefined");
  }
}
function isNull(value) {
  return value === null;
}
function asNull(value) {
  if (!isNull(value)) {
    throw Error("not a null");
  }
}
function isNullish2(value) {
  return value == null;
}
function asNullish(value) {
  if (!isNullish2(value)) {
    throw Error("not a nullish");
  }
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function asBoolean(value) {
  if (!isBoolean(value)) {
    throw Error("not a boolean");
  }
}
function isNumber(value) {
  return typeof value === "number";
}
function asNumber(value) {
  if (!isNumber(value)) {
    throw Error("not a number");
  }
}
function isBigInt(value) {
  return typeof value === "bigint";
}
function asBigInt(value) {
  if (!isBigInt(value)) {
    throw Error("not a bigint");
  }
}
function isSymbol(value) {
  return typeof value === "symbol";
}
function asSymbol(value) {
  if (!isSymbol(value)) {
    throw Error("not a symbol");
  }
}
function isString(value) {
  return typeof value === "string";
}
function asString(value) {
  if (!isString(value)) {
    throw Error("not a string");
  }
}
function isTemplateStringsArray$1(value) {
  return Array.isArray(value) && Array.isArray(value.raw);
}
function asTemplateStringsArray(value) {
  if (!isTemplateStringsArray$1(value)) {
    throw Error("not a template string array");
  }
}
function isArray2(value) {
  return Array.isArray(value);
}
function asArray(value) {
  if (!isArray2(value)) {
    throw Error("not an array");
  }
}
function isObject4(value) {
  return !isArray2(value) && value !== null && typeof value === "object";
}
function asObject(value) {
  if (!isObject4(value)) {
    throw Error("not an object");
  }
}
function isFunction(value) {
  return typeof value === "function";
}
function asFunction(value) {
  if (!isFunction(value)) {
    throw Error("not a function");
  }
}
function cn2(styles4) {
  return (...args) => {
    let className = "";
    if (isTemplateStringsArray(args[0])) {
      className = String.raw(
        args[0],
        args.slice(1).map((value) => (0, import_classnames.default)(value))
      );
    } else {
      className = args.map((value) => (0, import_classnames.default)(value)).join(" ");
    }
    className = className.replaceAll(/[ \t\n\r]+/g, " ").trim().split(" ").map((className2) => getClassName(className2, styles4)).join(" ");
    return className;
  };
}
function getClassName(className, styles4) {
  if (className.startsWith("@")) {
    className = className.slice(1);
    if (styles4 == null || styles4[className] == null) {
      throw Error(`missing style for .${className}`);
    }
    return styles4[className];
  }
  return className;
}
function __signalOnDestroy(effect) {
  effect["__stateOfDestroy"] = "destroying";
  if (effect["__children"]) {
    effect["__children"].forEach(__signalOnDestroy);
  }
  if (effect["__effects"]) {
    effect["__effects"].forEach(__signalOnDestroy);
  }
}
async function destroy() {
  __signalOnDestroy(this);
  return await this["__destroy"]();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function default__getEffect(main) {
  return main.effect;
}
async function property(main, target, key, deps, parameters) {
  const getEffect = parameters?.getEffect ?? default__getEffect;
  if (target[key]) {
    const effect = getEffect(target[key]);
    if (effect && !effect.isDestroyed) {
      await effect.destroy();
    }
  }
  return new Effect(() => {
    target[key] = main;
    return async () => {
      const effect = getEffect(target[key]);
      if (!effect.isDestroyed) {
        await effect.destroy();
      }
      delete target[key];
    };
  }, deps);
}
function inArray(source, target, deps) {
  return new Effect(() => {
    target.push(source);
    return () => {
      target.remove(source);
    };
  }, deps);
}
var import_jsx_runtime, import_react4, import_classnames, faviconSvg, import1, runsOnSide, runsOnServerSide2, lib$u, lib$t, local$7, lib$s, lib$r, local$6, lib$q, arrayPrototype, assign, defineProperties, local$4, local$5, lib$p, lib$o, lib$n, lib$m, lib$l, UpdateOfSharedLib, lib$k, lib$j, lib$i, global$2, lib$h, local$3, Console$1, Console$2, EventEmitter, local$2, lib$g, lib$f, lib$e, lib$d, originalDisposableUse, originalAsyncDisposableUse, SkyModule, local$1, lib$c, lib$b, __getOwnPropDesc2, __decorateClass, lib$a, lib$9, local, lib$8, lib$7, lib$6, TransformLib, lib$5, global$1, lib$4, timers, BaseOfTimer, Timer$1, TimeoutTimer, IntervalTimer, WaitTimer$1, lib$3, secondMs, minuteMs, hourMs, dayMs, weekMs, lib$2, cx2, __uniqueId, __BaseOfEffect, lib$1, Vector2, lib, Timeout, Interval, AnimationFrame, AnimationFrames$1, WindowEventListener$1, DocumentEventListener, PointerLock, Fullscreen, Loop$1;
var init_chunk_D8IZrfLU = __esm({
  async ".dev/build/sky.examples.platform.web/web/server/chunks/chunk-D8IZrfLU.js"() {
    "use strict";
    import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
    init_index_web_only();
    init_runtime2();
    import_react4 = __toESM(require_react(), 1);
    import_classnames = __toESM(require_classnames(), 1);
    faviconSvg = "/favicon.svg";
    __name(onRenderHtml, "onRenderHtml");
    import1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: onRenderHtml
    }, Symbol.toStringTag, { value: "Module" }));
    runsOnSide = typeof window === "undefined" ? "server" : "client";
    runsOnServerSide2 = runsOnSide === "server";
    ((lib22) => {
      lib22.ARCH = "unknown";
      lib22.PLATFORM = "unknown";
      lib22.OS = "unknown";
      lib22.APP_PLATFORM_TARGET = "unknown";
    })(lib$u || (lib$u = {}));
    initPlatform();
    __name(initPlatform, "initPlatform");
    Object.assign(global, lib$u);
    ((lib22) => {
      lib22.ARCH = "unknown";
      lib22.PLATFORM = runsOnServerSide2 ? "node" : "web";
      lib22.OS = "unknown";
      lib22.APP_PLATFORM_TARGET = "web";
    })(lib$t || (lib$t = {}));
    if (typeof ARCH !== "undefined") {
      Object.assign(global, { APP_PLATFORM_TARGET: lib$t.APP_PLATFORM_TARGET });
    } else {
      Object.assign(global, lib$t);
    }
    Promise.new = /* @__PURE__ */ __name(function newPromise() {
      let resolve;
      const promise = new Promise(
        (resolve_) => resolve = /* @__PURE__ */ __name((result) => {
          resolve_(result);
          return result;
        }, "resolve")
      );
      return [promise, resolve];
    }, "newPromise");
    ((local2) => {
      [local2.runtime, local2.resolveRuntime] = Promise.new();
      local2.isHot = typeof isRuntime === "boolean";
    })(local$7 || (local$7 = {}));
    ((lib22) => {
      lib22.runtime = local$7.runtime;
      init();
    })(lib$s || (lib$s = {}));
    __name(init, "init");
    Object.assign(global, lib$s);
    ((lib22) => {
      function as2(value) {
      }
      __name(as2, "as");
      lib22.as = as2;
    })(lib$r || (lib$r = {}));
    Object.assign(global, lib$r);
    ((local2) => {
      local2.moduleLoadings = {};
    })(local$6 || (local$6 = {}));
    ((lib22) => {
      function iAm2(moduleID, moduleLoading, dependencies) {
        dependencies && dependencies.needs.forEach((dependency) => {
          if (local$6.moduleLoadings[dependency] == null) {
            throw Error(
              `\xAB${moduleID}\xBB need \xAB${dependency}\xBB, but \xAB${dependency}\xBB not imported`
            );
          }
        });
        as(local$6.moduleLoadings);
        local$6.moduleLoadings[moduleID] = moduleLoading;
      }
      __name(iAm2, "iAm2");
      lib22.iAm = iAm2;
      async function getModule2(moduleID) {
        if (local$6.moduleLoadings[moduleID] == null) {
          throw Error(`unexpected module dependency: ${moduleID}`);
        }
        as(local$6.moduleLoadings);
        return local$6.moduleLoadings[moduleID];
      }
      __name(getModule2, "getModule2");
      lib22.getModule = getModule2;
      async function allowModule(moduleID, moduleLoading) {
        as(local$6.moduleLoadings);
        local$6.moduleLoadings[moduleID] = moduleLoading;
      }
      __name(allowModule, "allowModule");
      lib22.allowModule = allowModule;
    })(lib$q || (lib$q = {}));
    lib$q.getModule;
    lib$q.iAm;
    Object.assign(global, lib$q);
    arrayPrototype = Object.defineProperties(
      {},
      Object.getOwnPropertyDescriptors(Array.prototype)
    );
    arrayPrototype.copyWithin = function(target, start, end) {
      Array.prototype.copyWithin.call(this, target, start, end);
      return this;
    };
    arrayPrototype.fill = function(value, start, end) {
      Array.prototype.fill.call(this, value, start, end);
      return this;
    };
    __name(array, "array");
    assign = Object.assign;
    defineProperties = Object.defineProperties;
    __name(makePlain, "makePlain");
    __name(observe, "observe");
    __name(unobserve, "unobserve");
    __name(toPrimitive, "toPrimitive");
    __name(commit, "commit");
    __name(queueCommit, "queueCommit");
    __name(reactivePropertyDescriptors, "reactivePropertyDescriptors");
    ((local2) => {
      local2.array = array;
      local2.makePlain = makePlain;
      local2.observe = observe;
      local2.unobserve = unobserve;
      local2.reactivePropertyDescriptors = reactivePropertyDescriptors;
      local2.constructorSymbol = Symbol("constructor");
      local2.idSymbol = Symbol("id");
      local2.typeSymbol = Symbol("type");
      local2.nameSymbol = Symbol("name");
      local2.uidSymbol = Symbol("uid");
      local2.listenersOfReactivitySymbol = Symbol("listenersOfReactivity");
      local2.listenersOfShared = Symbol("listenersOfShared");
      local2.uniqueId = 2;
      local2.loadedDefines = {};
      local2.defines = {};
      local2.schemas = {};
      local2.reactions = [];
      local2.currentDefinesSymbol = Symbol("sky.standard.define.#currentDefines");
      local2.isHot = isRuntime && Object.keys(local2.defines).length === 0;
    })(local$4 || (local$4 = {}));
    local$5 = local$4;
    ((lib22) => {
      define2("sky.standard.define", define2);
      function define2(name, value) {
        if (local$5.defines[name] != null && (!isRuntime || !isHot())) {
          throw Error(`duplicate define ${name}`);
        }
        if (isRuntime) {
          if (!isHot()) {
            throw Error("runtime define");
          }
        }
        if (value != null) {
          const define22 = {
            name
          };
          if (typeof value === "object") {
            as(value);
            define22.value = value;
            define22.value[local$5.typeSymbol] = Array.isArray(value) ? "array" : "object";
          } else if (typeof value === "function") {
            as(value);
            define22.value = value;
            define22.value[local$5.typeSymbol] = "func";
          } else {
            throw Error("unknown type");
          }
          define22.value[local$5.nameSymbol] = name.split(".").pop();
          define22.value[local$5.uidSymbol] = name;
          local$5.defines[name] = define22;
          return value;
        }
        return /* @__PURE__ */ __name(function define22(Target) {
          if (isRuntime) {
            if (!isHot()) {
              throw Error("runtime define");
            }
          }
          as(Target);
          Target.prototype.schema ??= {};
          Target[local$5.typeSymbol] = "class";
          Target[local$5.nameSymbol] = Target.name;
          Target[local$5.uidSymbol] = name;
          local$5.defines[name] = {
            name,
            value: Target
          };
          const propertiesMap = local$5.reactivePropertyDescriptors(Target.prototype.schema);
          Object.defineProperties(Target.prototype, propertiesMap);
        }, "define2");
      }
      __name(define2, "define");
      lib22.define = define2;
      function type2(name, schema) {
        as(schema);
        if (Array.isArray(schema) || typeof schema !== "object") {
          throw Error("schema can be only object");
        }
        const constructor = local$5.makePlain(schema);
        schema[local$5.constructorSymbol] = constructor;
        const define22 = {
          name,
          value: constructor,
          [local$5.typeSymbol]: "schema"
        };
        define22.value[local$5.nameSymbol] = name.split(".").pop();
        define22.value[local$5.uidSymbol] = name;
        local$5.defines[name] = define22;
        return schema;
      }
      __name(type2, "type");
      lib22.type = type2;
    })(lib$p || (lib$p = {}));
    Object.assign(global, lib$p);
    ((lib22) => {
      define("sky.standard.loadDefines", loadDefines);
      async function loadDefines(defines) {
        Object.keys(defines).forEach((k) => {
          local$5.loadedDefines[k] = defines[k];
          local$5.uniqueId = Math.max(local$5.uniqueId, defines[k]);
          local$5.staticMaxId = local$5.uniqueId;
        });
      }
      __name(loadDefines, "loadDefines");
      lib22.loadDefines = loadDefines;
    })(lib$o || (lib$o = {}));
    Object.assign(global, lib$o);
    ((lib22) => {
      define("sky.standard.plain", plain);
      function plain(schema, object) {
        as(schema);
        if (Array.isArray(schema)) {
          return object;
        }
        const constructor = schema[local$5.constructorSymbol];
        if (constructor == null) {
          throw Error("plain from unknown schema");
        }
        return new constructor(object);
      }
      __name(plain, "plain");
      lib22.plain = plain;
    })(lib$n || (lib$n = {}));
    Object.assign(global, lib$n);
    ((lib22) => {
      function reaction(reaction2) {
        local$5.reactions.push(reaction2);
        reaction2();
        local$5.reactions.pop();
      }
      __name(reaction, "reaction");
      lib22.reaction = reaction;
    })(lib$m || (lib$m = {}));
    Object.assign(global, lib$m);
    ((lib22) => {
      define("sky.standard.save", save);
      function save(value) {
        return JSON.stringify(value);
      }
      __name(save, "save");
      lib22.save = save;
    })(lib$l || (lib$l = {}));
    Object.assign(global, lib$l);
    ((UpdateOfSharedLib2) => {
      ((Type2) => {
        Type2[Type2["CREATE"] = 1] = "CREATE";
        Type2[Type2["DESTROY"] = 2] = "DESTROY";
        Type2[Type2["SET"] = 3] = "SET";
        Type2[Type2["CALL"] = 4] = "CALL";
      })(UpdateOfSharedLib2.Type || (UpdateOfSharedLib2.Type = {}));
    })(UpdateOfSharedLib || (UpdateOfSharedLib = {}));
    Object.assign(global, { UpdateOfShared: UpdateOfSharedLib });
    ((lib22) => {
      define("sky.standard.share", share);
      function share(target, callback) {
        if (!isRuntime) {
          throw Error("sharing not in runtime");
        }
        as(target);
        if (target.constructor[local$5.idSymbol] == null) {
          throw Error("share object with unknown schema or class");
        }
        local$5.observe(target, target.constructor.schema, [callback]);
      }
      __name(share, "share");
      lib22.share = share;
      define("sky.standard.unshare", unshare);
      function unshare(target, callback) {
        as(target);
        if (target.constructor[local$5.idSymbol] == null) {
          throw Error("unshare object with unknown class");
        }
        local$5.unobserve(target, target.constructor.schema, [callback]);
      }
      __name(unshare, "unshare");
      lib22.unshare = unshare;
    })(lib$k || (lib$k = {}));
    Object.assign(global, lib$k);
    ((lib22) => {
      function read(schema) {
        return schema;
      }
      __name(read, "read");
      lib22.read = read;
      function write(schema) {
        return schema;
      }
      __name(write, "write");
      lib22.write = write;
      function secret(schema) {
        return schema;
      }
      __name(secret, "secret");
      lib22.secret = secret;
      function boolean(target, key) {
        target.schema ??= {};
        target.schema[key] = boolean;
      }
      __name(boolean, "boolean");
      lib22.boolean = boolean;
      function number(target, key) {
        target.schema ??= {};
        target.schema[key] = number;
      }
      __name(number, "number");
      lib22.number = number;
      function string(target, key) {
        target.schema ??= {};
        target.schema[key] = string;
      }
      __name(string, "string");
      lib22.string = string;
      function object(schema) {
        return (target, key) => {
          target.schema ??= {};
          target.schema[key] = schema;
        };
      }
      __name(object, "object");
      lib22.object = object;
      function array2(type2) {
        return (target, key) => {
          target.schema ??= {};
          target.schema[key] = type2;
        };
      }
      __name(array2, "array");
      lib22.array = array2;
      function func(target, key) {
        target.schema ??= {};
        target.schema[key] = func;
      }
      __name(func, "func");
      lib22.func = func;
      optional.boolean = optional(boolean);
      optional.number = optional(number);
      optional.string = optional(string);
      optional.func = optional(func);
      function optional(schema) {
        return schema;
      }
      __name(optional, "optional");
      lib22.optional = optional;
      nullable.boolean = nullable(boolean);
      nullable.number = nullable(number);
      nullable.string = nullable(string);
      nullable.func = nullable(func);
      function nullable(schema) {
        return schema;
      }
      __name(nullable, "nullable");
      lib22.nullable = nullable;
      nullish.boolean = nullish(boolean);
      nullish.number = nullish(number);
      nullish.string = nullish(string);
      nullish.func = nullish(func);
      function nullish(schema) {
        return schema;
      }
      __name(nullish, "nullish");
      lib22.nullish = nullish;
    })(lib$j || (lib$j = {}));
    Object.assign(global, lib$j);
    ((lib22) => {
      define("sky.standard.async", async2);
      async function async2(...args) {
        let object;
        let callback;
        let args_;
        if (typeof args[0] !== "function") {
          object = args[0];
          callback = args[1];
          args_ = args.slice(2);
        } else {
          callback = args[0];
          args_ = args.slice(1);
        }
        try {
          if (object != null) {
            return await callback.call(object, ...args_);
          } else {
            return await callback(...args_);
          }
        } catch (error) {
          const maybePromise = onAsyncError(error);
          if (maybePromise != null) {
            await maybePromise;
          }
        }
      }
      __name(async2, "async");
      lib22.async = async2;
      async function run_async_slot2(...args) {
        let object;
        let callback;
        let args_;
        if (typeof args[0] !== "function") {
          object = args[0];
          callback = args[1];
          args_ = args.slice(2);
        } else {
          callback = args[0];
          args_ = args.slice(1);
        }
        if (object != null) {
          return async2(object, callback, ...args_);
        } else {
          return async2(callback, ...args_);
        }
      }
      __name(run_async_slot2, "run_async_slot");
      lib22.run_async_slot = run_async_slot2;
      function default_onAsyncError(error) {
        throw error;
      }
      __name(default_onAsyncError, "default_onAsyncError");
      lib22.default_onAsyncError = default_onAsyncError;
    })(lib$i || (lib$i = {}));
    Object.assign(global, lib$i);
    Object.assign(global, { onAsyncError: lib$i.default_onAsyncError });
    iAm("sky.standard.define", Promise.resolve().then(() => global$2));
    async(async () => {
      await runtime;
      const errors = [];
      Object.keys(local$5.loadedDefines).forEach((k) => {
        const define2 = local$5.defines[k];
        if (define2 == null) {
          errors.push(`define ${k} is defined, but not imported`);
          return;
        }
        const id = local$5.loadedDefines[k];
        define2.value[local$5.idSymbol] = id;
      });
      Object.keys(local$5.defines).forEach((k) => {
        const define2 = local$5.loadedDefines[k];
        if (define2 == null) {
          errors.push(`define ${k} is imported, but not defined`);
          return;
        }
        const value = local$5.defines[k];
        if (typeof value === "object" || typeof value === "function") {
          Object.freezeDeep(value);
        }
      });
      if (errors.length > 0) {
        throw Error(`
    > ${errors.join("\n    > ")}`);
      }
    });
    global$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null
    }, Symbol.toStringTag, { value: "Module" }));
    global.loadDefines({
      "sky.examples.platform.web.App": 5
    });
    ((lib22) => {
      function mergeNamespaces2(targetNamespace, namespace2) {
        Object.keys(namespace2).forEach((k) => {
          if (targetNamespace[k] != null && typeof targetNamespace[k] === "function" && typeof namespace2[k] === "object" && !Array.isArray(module)) {
            Object.assign(targetNamespace[k], namespace2[k]);
          } else if (targetNamespace[k] != null && typeof targetNamespace[k] === "object" && typeof namespace2[k] === "function" && !Array.isArray(targetNamespace[k])) {
            Object.assign(namespace2[k], targetNamespace[k]);
            targetNamespace[k] = namespace2[k];
          } else {
            targetNamespace[k] = namespace2[k];
          }
        });
      }
      __name(mergeNamespaces2, "mergeNamespaces");
      lib22.mergeNamespaces = mergeNamespaces2;
    })(lib$h || (lib$h = {}));
    Object.assign(global, lib$h);
    define("sky.standard.globalify", globalify);
    __name(globalify, "globalify");
    define(
      "sky.standard.globalify.namespace",
      globalify.namespace = /* @__PURE__ */ __name(function namespace(namespace, module2) {
        const namespacesArray = namespace.split(".");
        let scope = global;
        for (const [i, namespace2] of namespacesArray.entries()) {
          scope[namespace2] ??= {};
          scope = scope[namespace2];
          if (i === namespacesArray.length - 1) {
            mergeNamespaces(scope, module2);
          }
        }
      }, "namespace")
    );
    __name(captureUI, "captureUI");
    globalify({
      React: import_react4.default,
      act: import_react4.default.act,
      cloneElement: import_react4.default.cloneElement,
      createContext: import_react4.default.createContext,
      createElement: import_react4.default.createElement,
      createRef: import_react4.default.createRef,
      forwardRef: import_react4.default.forwardRef,
      isValidElement: import_react4.default.isValidElement,
      lazy: import_react4.default.lazy,
      memo: import_react4.default.memo,
      startTransition: import_react4.default.startTransition,
      use: import_react4.default.use,
      useActionState: import_react4.default.useActionState,
      useCallback: import_react4.default.useCallback,
      useContext: import_react4.default.useContext,
      useDebugValue: import_react4.default.useDebugValue,
      useDeferredValue: import_react4.default.useDeferredValue,
      useEffect: import_react4.default.useEffect,
      useId: import_react4.default.useId,
      useImperativeHandle: import_react4.default.useImperativeHandle,
      useInsertionEffect: import_react4.default.useInsertionEffect,
      useLayoutEffect: import_react4.default.useLayoutEffect,
      useMemo: import_react4.default.useMemo,
      useReducer: import_react4.default.useReducer,
      useRef: import_react4.default.useRef,
      useSyncExternalStore: import_react4.default.useSyncExternalStore,
      useState: import_react4.default.useState,
      useTransition: import_react4.default.useTransition,
      useOptimistic: import_react4.default.useOptimistic,
      captureUI
    });
    global.loadDefines({
      "sky.standard.Console": 8,
      "sky.standard.async": 9,
      "sky.standard.define": 10,
      "sky.standard.loadDefines": 11,
      "sky.standard.plain": 12,
      "sky.standard.save": 13,
      "sky.standard.share": 14,
      "sky.standard.unshare": 15,
      "sky.standard.globalify": 16,
      "sky.standard.globalify.namespace": 17,
      "sky.standard.UndefinedError": 18,
      "sky.standard.notUndefined": 19,
      "sky.standard.NullError": 20,
      "sky.standard.notNull": 21,
      "sky.standard.NullishError": 22,
      "sky.standard.notNullish": 23,
      "sky.standard.switch_thread": 24
    });
    Array.prototype.last = /* @__PURE__ */ __name(function last() {
      return this[this.length - 1];
    }, "last");
    Object.defineProperty(Array.prototype, "last", {
      enumerable: false
    });
    Array.prototype.remove = /* @__PURE__ */ __name(function remove(element) {
      const elementIndex = this.indexOf(element);
      if (elementIndex === -1) {
        return false;
      }
      this.splice(elementIndex, 1);
      return true;
    }, "remove");
    Object.defineProperty(Array.prototype, "remove", {
      enumerable: false
    });
    Array.prototype.shuffle = /* @__PURE__ */ __name(function shuffle() {
      for (let i = this.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [this[i], this[j]] = [this[j], this[i]];
      }
      return this;
    }, "shuffle");
    Object.defineProperty(Array.prototype, "shuffle", {
      enumerable: false
    });
    Array.prototype.toShuffled = /* @__PURE__ */ __name(function toShuffled() {
      return this.slice().shuffle();
    }, "toShuffled");
    Object.defineProperty(Array.prototype, "toShuffled", {
      enumerable: false
    });
    __name(bind, "bind");
    globalify({ bind });
    iAm("sky.standard.Console", Promise.resolve().then(() => Console$2));
    ((local2) => {
      local2.reset = "\x1B[0m";
      local2.black = "\x1B[90m";
      local2.red = "\x1B[91m";
      local2.green = "\x1B[92m";
      local2.yellow = "\x1B[93m";
      local2.magenta = "\x1B[38;05;127;05;232m";
      local2.consoleCopy = { ...console };
    })(local$3 || (local$3 = {}));
    Console$1 = define(
      "sky.standard.Console",
      runsOnServerSide2 ? {
        ...local$3.consoleCopy,
        log: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.log(`\u2139\uFE0F `, ...args), "log"),
        info: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.log(
          `${local$3.magenta}INFO \u2139\uFE0F :${local$3.reset}`,
          ...args.map(
            (value) => typeof value === "string" ? `${local$3.magenta}${value}${local$3.reset}` : value
          )
        ), "info"),
        success: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.log(
          `${local$3.green}SUCCESS \u2705:${local$3.reset}`,
          ...args.map(
            (value) => typeof value === "string" ? `${local$3.green}${value}${local$3.reset}` : value
          )
        ), "success"),
        debug: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.log(
          `${local$3.black}DEBUG \u{1F308}:${local$3.reset}`,
          ...args.map(
            (value) => typeof value === "string" ? `${local$3.black}${value}${local$3.reset}` : value
          )
        ), "debug"),
        warn: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.log(
          `${local$3.yellow}WARN \u26A0\uFE0F :`,
          ...args.map(
            (value) => typeof value === "string" ? `${local$3.yellow}${value}${local$3.reset}` : value
          )
        ), "warn"),
        error: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.log(
          `${local$3.red}ERROR \u274C:`,
          ...args.map(
            (value) => typeof value === "string" ? `${local$3.red}${value}${local$3.reset}` : value
          )
        ), "error")
      } : {
        ...local$3.consoleCopy,
        log: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.log(
          `%c%s ${args.map((value) => typeof value === "string" ? "%s" : "%o").join(" ")}`,
          "color: #121212;",
          `\u2139\uFE0F`,
          ...args
        ), "log"),
        info: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.info(
          `%c%s ${args.map((value) => typeof value === "string" ? "%s" : "%o").join(" ")}`,
          "color: #cc00aa;",
          `INFO \u2139\uFE0F:`,
          ...args
        ), "info"),
        success: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.log(
          `%c%s ${args.map((value) => typeof value === "string" ? "%s" : "%o").join(" ")}`,
          "color: #55cc55;",
          `SUCCESS \u2705:`,
          ...args
        ), "success"),
        debug: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.debug(
          `%c%s ${args.map((value) => typeof value === "string" ? "%s" : "%o").join(" ")}`,
          "color: #aaaaaa;",
          `DEBUG \u{1F308}:`,
          ...args
        ), "debug"),
        warn: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.warn(
          `%c%s ${args.map((value) => typeof value === "string" ? "%s" : "%o").join(" ")}`,
          "color: #f59e0b;",
          `WARN \u26A0\uFE0F:`,
          ...args
        ), "warn"),
        error: /* @__PURE__ */ __name((...args) => local$3.consoleCopy.error(
          `%c%s ${args.map((value) => typeof value === "string" ? "%s" : "%o").join(" ")}`,
          "color: #ef4444;",
          `ERROR \u274C:`,
          ...args
        ), "error")
      }
    );
    Console$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: Console$1
    }, Symbol.toStringTag, { value: "Module" }));
    Object.assign(console, Console$1);
    globalify({ Console: console });
    EventEmitter = class {
      static {
        __name(this, "EventEmitter");
      }
      constructor() {
        this.__listeners = {};
      }
      static super(self) {
        self["__listeners"] = {};
      }
      on(ev, callback) {
        return null;
      }
      onAny(callback) {
        return null;
      }
      off(ev, callback) {
        return null;
      }
      offAll() {
        return null;
      }
      emit(ev, ...args) {
        return null;
      }
    };
    EventEmitter.extend = /* @__PURE__ */ __name(function extend(fn) {
      as(fn);
      const prototype = Object.create(Object.getPrototypeOf(fn));
      Object.assign(prototype, {
        on: EventEmitter.prototype.on,
        off: EventEmitter.prototype.on,
        emit: EventEmitter.prototype.emit
      });
      Object.setPrototypeOf(fn, prototype);
      fn["__events"] = {};
      return fn;
    }, "extend");
    EventEmitter.prototype.emit = /* @__PURE__ */ __name(function emit(ev, ...args) {
      const eventsList = this["__events"][ev];
      eventsList && eventsList.forEach((cb) => cb(...args));
      return this;
    }, "emit");
    EventEmitter.prototype.off = /* @__PURE__ */ __name(function off(ev, callback) {
      const eventsList = this["__events"][ev];
      eventsList && eventsList.remove(callback);
      return this;
    }, "off");
    EventEmitter.prototype.on = /* @__PURE__ */ __name(function on(ev, callback) {
      this["__events"] ??= {};
      const eventsList = this["__events"][ev] ??= [];
      eventsList.push(callback);
      return this;
    }, "on");
    globalify({ EventEmitter });
    ((local2) => {
      local2.x = 42;
    })(local$2 || (local$2 = {}));
    __name(__fetchArgs, "__fetchArgs");
    Object.assign(fetch, {
      async call(url, init2) {
        return await fetch(...__fetchArgs(url, init2));
      }
    });
    Object.assign(fetch, {
      json(url, init2) {
        return fetch(...__fetchArgs(url, init2)).then((result) => result.json());
      }
    });
    Object.assign(fetch, {
      text(url, init2) {
        return fetch(...__fetchArgs(url, init2)).then((response) => response.text());
      }
    });
    globalify({ globalify });
    __name(idle$1, "idle$1");
    globalify({ idle: idle$1 });
    __name(justTry, "justTry");
    globalify({
      justTry
    });
    Math.minmax = /* @__PURE__ */ __name(function minmax(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }, "minmax");
    Math.randomBetween = /* @__PURE__ */ __name(function randomBetween(from2 = 0, to2 = 1) {
      return Math.random() * (to2 - from2) + from2;
    }, "randomBetween");
    Math.roundedRandomBetween = /* @__PURE__ */ __name(function roundedRandomBetween(from2 = 0, to2 = 0) {
      return Math.floor(Math.random() * (to2 - from2 + 1) + from2);
    }, "roundedRandomBetween");
    ((lib22) => {
      function defineMeasures2(name, measures) {
        const defaultMeasure = measures.find((measure) => measure[1] === 1);
        if (defaultMeasure == null) {
          throw Error(`${name}: default measure (1) not defined`);
        }
        const defaultMeasureName = defaultMeasure[0].toLowerCase();
        const properties = {};
        measures.forEach((measure) => {
          properties["as" + measure[0]] = {
            get() {
              if (this.measure != null && this.measure != defaultMeasureName) {
                throw Error(`measures mismatch: ${this.measure}, ${name}`);
              }
              const newNumber = new Number(this * measure[1]);
              newNumber.measure = defaultMeasureName;
              return newNumber;
            }
          };
          properties["in" + measure[0]] = {
            get() {
              if (this.measure != null && this.measure != defaultMeasureName) {
                throw Error(`measures mismatch: ${this.measure}, ${name}`);
              }
              const newNumber = new Number(this / measure[1]);
              newNumber.measure = defaultMeasureName;
              return newNumber;
            }
          };
        });
        Object.defineProperties(Number.prototype, properties);
      }
      __name(defineMeasures2, "defineMeasures");
      lib22.defineMeasures = defineMeasures2;
    })(lib$g || (lib$g = {}));
    globalify(lib$g);
    defineMeasures("KilometersPerHour", [["KilometersPerHour", 1]]);
    defineMeasures("Length", [
      ["Nanometers", 1e-9],
      ["Millimeters", 1e-3],
      ["Decimeters", 0.1],
      ["Meters", 1],
      ["Kilometers", 1e3]
    ]);
    defineMeasures("MetersPerSecond", [["MetersPerSecond", 1]]);
    defineMeasures("Percents", [["Percents", 1]]);
    defineMeasures("PercentsPerMillisecond", [["PercentsPerMillisecond", 1]]);
    defineMeasures("PercentsPerSecond", [["PercentsPerSecond", 1]]);
    defineMeasures("Time", [
      ["Nanoseconds", 1e-9],
      ["Milliseconds", 1e-3],
      ["Deciseconds", 0.1],
      ["Seconds", 1],
      ["Minutes", 60],
      ["Hours", 60 * 60],
      ["Days", 24 * 60 * 60],
      ["Weeks", 7 * 24 * 60 * 60]
    ]);
    defineMeasures("Weight", [
      ["Nanograms", 1e-9],
      ["Milligrams", 1e-3],
      ["Decigrams", 0.1],
      ["Grams", 1],
      ["Kilograms", 1e3],
      ["Tons", 1e6]
    ]);
    Symbol.deeplyFrozen = Symbol("deeplyFrozen");
    Object.freezeDeep = /* @__PURE__ */ __name(function freezeDeep(object) {
      Array.isArray(object) ? object.forEach((value) => Object.isFreezable(value) && Object.freezeDeep(value)) : Object.values(object).forEach(
        (value) => Object.isFreezable(value) && Object.freezeDeep(value)
      );
      Object.defineProperty(object, Symbol.deeplyFrozen, {
        value: true
      });
      return Object.freeze(object);
    }, "freezeDeep");
    Object.isFreezable = /* @__PURE__ */ __name(function isFreezable(value) {
      return value == null ? false : typeof value === "object" || typeof value === "function";
    }, "isFreezable");
    Object.isDeeplyFrozen = /* @__PURE__ */ __name(function isDeeplyFrozen(object) {
      return !!object[Symbol.deeplyFrozen];
    }, "isDeeplyFrozen");
    ((lib22) => {
      class AssertionError extends Error {
        static {
          __name(this, "AssertionError");
        }
        constructor(message) {
          super(`assertion failed: ${message}`);
        }
      }
      lib22.AssertionError = AssertionError;
      function assert5(expression, message) {
        if (!expression) {
          throw new AssertionError(message);
        }
      }
      __name(assert5, "assert");
      lib22.assert = assert5;
    })(lib$f || (lib$f = {}));
    globalify(lib$f);
    ((lib22) => {
      Object.defineProperty(Symbol, "asyncCreate", {
        value: Symbol("asyncCreate")
      });
      function when(object, callback, ...args) {
        return async(async () => {
          if (Array.isArray(object)) {
            const result2 = await Promise.all(
              object.map(
                (value) => run_async_slot(async () => {
                  let result3;
                  if (value[Symbol.asyncCreate] != null) {
                    result3 = await value[Symbol.asyncCreate];
                  } else {
                    const promise = value;
                    result3 = await promise;
                  }
                  return result3;
                })
              )
            );
            callback && await callback(result2, ...args);
            return result2;
          }
          as(
            object
          );
          let result;
          if (object[Symbol.asyncCreate] != null) {
            result = await object[Symbol.asyncCreate];
          } else {
            const promise = object;
            result = await promise;
          }
          callback && await callback(result, ...args);
          return result;
        });
      }
      __name(when, "when");
      lib22.when = when;
    })(lib$e || (lib$e = {}));
    globalify(lib$e);
    ((lib22) => {
      function canClone(object) {
        try {
          structuredClone(object);
          return true;
        } catch (error) {
          return false;
        }
      }
      __name(canClone, "canClone");
      lib22.canClone = canClone;
    })(lib$d || (lib$d = {}));
    globalify(lib$d);
    if (typeof window === "undefined") {
      const { AsyncDisposableStack: AsyncDisposableStack22, DisposableStack: DisposableStack22, SuppressedError: SuppressedError5, patchSymbols: patchSymbols2 } = await Promise.resolve().then(() => (init_esm3(), esm_exports));
      globalify({
        AsyncDisposableStack: AsyncDisposableStack22,
        DisposableStack: DisposableStack22,
        SuppressedError: SuppressedError5
      });
      patchSymbols2();
    }
    originalDisposableUse = DisposableStack.prototype.use;
    DisposableStack.prototype.use = /* @__PURE__ */ __name(function use(funcReturnsDisposable, ...args) {
      return {
        disposable: originalDisposableUse.call(
          this,
          funcReturnsDisposable(...args)
        )
      };
    }, "use");
    originalAsyncDisposableUse = AsyncDisposableStack.prototype.use;
    AsyncDisposableStack.prototype.use = /* @__PURE__ */ __name(function use2(funcReturnsAsyncDisposable, ...args) {
      return {
        disposable: originalAsyncDisposableUse.call(
          this,
          funcReturnsAsyncDisposable(...args)
        )
      };
    }, "use2");
    ((SkyModule2) => {
      ((MouseButton2) => {
        MouseButton2[MouseButton2["LEFT"] = 0] = "LEFT";
        MouseButton2[MouseButton2["MIDDLE"] = 1] = "MIDDLE";
        MouseButton2[MouseButton2["RIGHT"] = 2] = "RIGHT";
      })(SkyModule2.MouseButton || (SkyModule2.MouseButton = {}));
    })(SkyModule || (SkyModule = {}));
    globalify.namespace("Sky", SkyModule);
    ((local2) => {
      local2.isHot = false;
    })(local$1 || (local$1 = {}));
    ((lib22) => {
      function isHot2() {
        return local$1.isHot;
      }
      __name(isHot2, "isHot");
      lib22.isHot = isHot2;
      function Hmr(hot) {
        if (hot == null) {
          throw Error("hot isn't supported");
        }
        local$1.isHot = true;
        hot.dispose(() => {
          local$1.isHot = true;
        });
      }
      __name(Hmr, "Hmr");
      lib22.Hmr = Hmr;
    })(lib$c || (lib$c = {}));
    globalify(lib$c);
    __name(hook$1, "hook$1");
    __name(emitWithHooks$1, "emitWithHooks$1");
    globalify({
      hook: hook$1,
      emitWithHooks: emitWithHooks$1
    });
    ((lib22) => {
      function mixin(mixinConstructor) {
        return /* @__PURE__ */ __name(function decorator(constructor) {
          mixinConstructor.prototype.__hooks && Object.keys(mixinConstructor.prototype.__hooks).forEach((k) => {
            hook(constructor.prototype, k, {
              value: mixinConstructor.prototype.__hooks[k]
            });
          });
          copyPrototype(mixinConstructor.prototype, constructor.prototype);
        }, "decorator");
      }
      __name(mixin, "mixin");
      lib22.mixin = mixin;
      function copyPrototype(source, target) {
        const nextPrototype = Object.getPrototypeOf(source);
        if (nextPrototype != null) {
          copyPrototype(nextPrototype, target);
        }
        const propertyDescriptors = Object.getOwnPropertyDescriptors(source);
        Object.keys(propertyDescriptors).forEach((k) => {
          if (k === "__hooks") {
            return;
          }
          if (propertyDescriptors[k].value == null) {
            return;
          }
          Object.defineProperty(target, k, propertyDescriptors[k]);
        });
      }
      __name(copyPrototype, "copyPrototype");
    })(lib$b || (lib$b = {}));
    globalify(lib$b);
    __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    __decorateClass = /* @__PURE__ */ __name((decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = decorator(result) || result;
      return result;
    }, "__decorateClass");
    ((lib22) => {
      let UndefinedError = class extends Error {
        static {
          __name(this, "UndefinedError");
        }
        constructor(message) {
          super(`unexpected undefined: ${message}`);
        }
      };
      UndefinedError = __decorateClass([
        define("sky.standard.UndefinedError")
      ], UndefinedError);
      lib22.UndefinedError = UndefinedError;
      define("sky.standard.notUndefined", notUndefined);
      function notUndefined(value, message) {
        if (value === void 0) {
          throw new UndefinedError(message);
        }
        return value;
      }
      __name(notUndefined, "notUndefined");
      lib22.notUndefined = notUndefined;
      let NullError2 = class extends Error {
        static {
          __name(this, "NullError");
        }
        constructor(message) {
          super(`unexpected null: ${message}`);
        }
      };
      NullError2 = __decorateClass([
        define("sky.standard.NullError")
      ], NullError2);
      lib22.NullError = NullError2;
      define("sky.standard.notNull", notNull2);
      function notNull2(value, message) {
        if (value === null) {
          throw new NullError2(message);
        }
        return value;
      }
      __name(notNull2, "notNull");
      lib22.notNull = notNull2;
      let NullishError = class extends Error {
        static {
          __name(this, "NullishError");
        }
        constructor(message) {
          super(`unexpected nullish: ${message}`);
        }
      };
      NullishError = __decorateClass([
        define("sky.standard.NullishError")
      ], NullishError);
      lib22.NullishError = NullishError;
      define("sky.standard.notNullish", notNullish);
      function notNullish(value, message) {
        if (value == null) {
          throw new NullishError(message);
        }
        return value;
      }
      __name(notNullish, "notNullish");
      lib22.notNullish = notNullish;
    })(lib$a || (lib$a = {}));
    globalify(lib$a);
    ((lib22) => {
      async function repeat(count, callback, ...args) {
        for (let i = 0; i < count; ++i) {
          const result = callback(i, ...args);
          if (result instanceof Promise) {
            await result;
          }
        }
      }
      __name(repeat, "repeat");
      lib22.repeat = repeat;
    })(lib$9 || (lib$9 = {}));
    globalify(lib$9);
    ((local2) => {
      local2.singletonSymbol = Symbol("singleton");
      local2.singletonOnErrorSymbol = Symbol("singletonOnError");
      local2.singletonCreatePromiseSymbol = Symbol("singletonCreatePromise");
      local2.promiseResolveSymbol = Symbol("promiseResolve");
      local2.promiseSingletonSymbol = Symbol("promiseSingleton");
      local2.injectsSymbol = Symbol("injects");
      function isSingleton(singleton) {
        as(singleton);
        return singleton[local2.singletonSymbol] != null || singleton[local2.singletonCreatePromiseSymbol] != null;
      }
      __name(isSingleton, "isSingleton");
      local2.isSingleton = isSingleton;
      local2.singletons = [];
      async function createSingleton(singleton) {
        if (singleton[local2.singletonSymbol] === true) {
          throw new CircularSingletonDependencyError(singleton);
        }
        singleton[local2.singletonSymbol] = true;
        const singletonInstance = new singleton();
        if (singleton[local2.injectsSymbol] != null) {
          for (const inject of singleton[local2.injectsSymbol]) {
            const injectedSingleton = inject[local2.promiseSingletonSymbol];
            if (injectedSingleton[local2.singletonSymbol] === true) {
              throw new CircularSingletonDependencyError(singleton);
            } else if (injectedSingleton[local2.singletonSymbol] != null) {
              continue;
            }
            await createSingleton(injectedSingleton);
          }
        }
        if (singletonInstance.create != null) {
          await singletonInstance.create();
        }
        singleton[local2.singletonSymbol] = singletonInstance;
        singleton[local2.singletonCreatePromiseSymbol][local2.promiseResolveSymbol](singletonInstance);
      }
      __name(createSingleton, "createSingleton");
      local2.createSingleton = createSingleton;
    })(local || (local = {}));
    ((lib22) => {
      class CircularSingletonDependencyError2 extends Error {
        static {
          __name(this, "CircularSingletonDependencyError2");
        }
        constructor(singleton) {
          super(`circular singleton dependency error in ${singleton.name}`);
          if (singleton[local.singletonOnErrorSymbol] != null) {
            this.message += `
Caused by: ${singleton[local.singletonOnErrorSymbol]?.stack}`;
          }
        }
      }
      lib22.CircularSingletonDependencyError = CircularSingletonDependencyError2;
      function Singleton(target) {
        as(target);
        target[local.singletonOnErrorSymbol] = Error("singleton");
        local.singletons.push(target);
        Object.setPrototypeOf(singleton, target);
        function singleton() {
          throw Error("duplicated singleton");
        }
        __name(singleton, "singleton");
        return singleton;
      }
      __name(Singleton, "Singleton");
      lib22.Singleton = Singleton;
      function dependsOn(prototype, key) {
        as(prototype);
        let injectValue;
        let promise = null;
        Object.defineProperty(prototype, key, {
          get() {
            if (promise != null) {
              throw new CircularSingletonDependencyError2(
                promise[local.promiseSingletonSymbol]
              );
            }
            if (injectValue == null) {
              throw Error(`dependsOn: service not injected yet`);
            }
            return injectValue;
          },
          set(value) {
            if (value[local.promiseResolveSymbol] != null) {
              promise = value;
              if (local.isSingleton(prototype.constructor)) {
                prototype.constructor[local.injectsSymbol] ??= [];
                prototype.constructor[local.injectsSymbol].push(promise);
              }
              async(async () => {
                this[key] = await notNull(promise, "promise");
                promise = null;
              });
            }
            injectValue = value;
          }
        });
      }
      __name(dependsOn, "dependsOn");
      lib22.dependsOn = dependsOn;
      function inject(target, key) {
        as(target);
        let injectValue;
        let promise = null;
        Object.defineProperty(target, key, {
          get() {
            if (promise != null) {
              throw Error(`inject: can't get service on create`);
            }
            return injectValue;
          },
          set(value) {
            if (value[local.promiseResolveSymbol] != null) {
              promise = value;
              async(async () => {
                target[key] = await notNull(promise, "promise");
                promise = null;
              });
            }
            injectValue = value;
          }
        });
      }
      __name(inject, "inject");
      lib22.inject = inject;
      function getService(singleton) {
        if (!isRuntime) {
          throw Error(`can't get singleton before runtime`);
        }
        if (!local.isSingleton(singleton)) {
          throw Error("not a singleton");
        }
        if (singleton[local.singletonSymbol] != null && singleton[local.singletonSymbol] !== true) {
          return notNull(singleton[local.singletonSymbol], "singleton");
        }
        if (singleton[local.singletonCreatePromiseSymbol] != null) {
          return singleton[local.singletonCreatePromiseSymbol];
        }
        if (singleton[local.singletonSymbol] !== true) {
          return notNull(singleton[local.singletonSymbol], "singleton");
        }
        throw Error(`can't get singleton in index`);
      }
      __name(getService, "getService");
      lib22.getService = getService;
    })(lib$8 || (lib$8 = {}));
    initServices();
    __name(initServices, "initServices");
    globalify(lib$8);
    global.loadDefines({
      "sky.standard.switch_thread": 24
    });
    ((lib22) => {
      define("sky.standard.switch_thread", switch_thread2);
      async function switch_thread2() {
        return await new Promise((resolve) => resolve()).then(() => {
        });
      }
      __name(switch_thread2, "switch_thread");
      lib22.switch_thread = switch_thread2;
    })(lib$7 || (lib$7 = {}));
    globalify(lib$7);
    ((lib22) => {
      lib22.to = {};
      lib22.from = {};
      function defineTransform2(type2, to3, from3) {
        as(lib22.to);
        as(lib22.from);
        lib22.to[type2] = to3;
        lib22.from[type2] = from3;
        Object.defineProperty(transform, type2, {
          get() {
            let self = this;
            if (self === transform) {
              self = Object.create(transform);
            }
            self.transformers ??= [];
            self.transformers.push(type2);
            return self;
          },
          set(value) {
            this[type2] = value;
          }
        });
      }
      __name(defineTransform2, "defineTransform2");
      lib22.defineTransform = defineTransform2;
    })(lib$6 || (lib$6 = {}));
    globalify(lib$6);
    ((TransformLib2) => {
      TransformLib2.transform = {
        transform(value) {
          for (let i = 0; i < this.transformers.length; ++i) {
            value = to[this.transformers[i]](value);
          }
          return value;
        },
        untransform(value) {
          for (let i = this.transformers.length - 1; i >= 0; --i) {
            value = from[this.transformers[i]](value);
          }
          return value;
        }
      };
    })(TransformLib || (TransformLib = {}));
    globalify(TransformLib);
    defineTransform(
      "json",
      (value, replacer, space) => JSON.stringify(value, replacer, space),
      (json) => JSON.parse(json)
    );
    defineTransform(
      "base64",
      (string) => btoa(string),
      (base64) => atob(base64)
    );
    iAm("type-guards", Promise.resolve().then(() => lib$5));
    __name(isUndefined, "isUndefined");
    __name(asUndefined, "asUndefined");
    __name(isNull, "isNull");
    __name(asNull, "asNull");
    __name(isNullish2, "isNullish");
    __name(asNullish, "asNullish");
    __name(isBoolean, "isBoolean");
    __name(asBoolean, "asBoolean");
    __name(isNumber, "isNumber");
    __name(asNumber, "asNumber");
    __name(isBigInt, "isBigInt");
    __name(asBigInt, "asBigInt");
    __name(isSymbol, "isSymbol");
    __name(asSymbol, "asSymbol");
    __name(isString, "isString");
    __name(asString, "asString");
    __name(isTemplateStringsArray$1, "isTemplateStringsArray$1");
    __name(asTemplateStringsArray, "asTemplateStringsArray");
    __name(isArray2, "isArray");
    __name(asArray, "asArray");
    __name(isObject4, "isObject");
    __name(asObject, "asObject");
    __name(isFunction, "isFunction");
    __name(asFunction, "asFunction");
    lib$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      asArray,
      asBigInt,
      asBoolean,
      asFunction,
      asNull,
      asNullish,
      asNumber,
      asObject,
      asString,
      asSymbol,
      asTemplateStringsArray,
      asUndefined,
      isArray: isArray2,
      isBigInt,
      isBoolean,
      isFunction,
      isNull,
      isNullish: isNullish2,
      isNumber,
      isObject: isObject4,
      isString,
      isSymbol,
      isTemplateStringsArray: isTemplateStringsArray$1,
      isUndefined
    }, Symbol.toStringTag, { value: "Module" }));
    globalify({ ...lib$5 });
    iAm("sky.standard", Promise.resolve().then(() => global$1));
    global$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null
    }, Symbol.toStringTag, { value: "Module" }));
    ((lib22) => {
      function shade(color, percent) {
        let R = parseInt(color.substring(1, 3), 16);
        let G = parseInt(color.substring(3, 5), 16);
        let B = parseInt(color.substring(5, 7), 16);
        R *= (100 + percent) / 100;
        G *= (100 + percent) / 100;
        B *= (100 + percent) / 100;
        R = R < 255 ? R : 255;
        G = G < 255 ? G : 255;
        B = B < 255 ? B : 255;
        R = Math.round(R);
        G = Math.round(G);
        B = Math.round(B);
        const RR = R.toString(16).length == 1 ? "0" + R.toString(16) : R.toString(16);
        const GG = G.toString(16).length == 1 ? "0" + G.toString(16) : G.toString(16);
        const BB = B.toString(16).length == 1 ? "0" + B.toString(16) : B.toString(16);
        return "#" + RR + GG + BB;
      }
      __name(shade, "shade");
      lib22.shade = shade;
      function rgb2hsl(r, g2, b) {
        r /= 255;
        g2 /= 255;
        b /= 255;
        const cmin = Math.min(r, g2, b), cmax = Math.max(r, g2, b), delta = cmax - cmin;
        let h = 0, s = 0, l = 0;
        if (delta == 0) {
          h = 0;
        } else if (cmax == r) {
          h = (g2 - b) / delta % 6;
        } else if (cmax == g2) {
          h = (b - r) / delta + 2;
        } else {
          h = (r - g2) / delta + 4;
        }
        h = Math.round(h * 60);
        if (h < 0) {
          h += 360;
        }
        l = (cmax + cmin) / 2;
        s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
        s = +(s * 100).toFixed(1);
        l = +(l * 100).toFixed(1);
        return [h, s, l];
      }
      __name(rgb2hsl, "rgb2hsl");
      lib22.rgb2hsl = rgb2hsl;
      function hsl2hex(h, s, l) {
        l /= 100;
        const a = s * Math.min(l, 1 - l) / 100;
        const f = /* @__PURE__ */ __name((n) => {
          const k = (n + h / 30) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color).toString(16).padStart(2, "0");
        }, "f");
        return `#${f(0)}${f(8)}${f(4)}`;
      }
      __name(hsl2hex, "hsl2hex");
      lib22.hsl2hex = hsl2hex;
      function hex2hsl(color) {
        return rgb2hsl(...hex2rgb(color));
      }
      __name(hex2hsl, "hex2hsl");
      lib22.hex2hsl = hex2hsl;
      function lighten(color, percent) {
        const hsl = hex2hsl(color);
        const [h, s] = hsl;
        let [, , l] = hsl;
        l = Math.minmax(0, 100, l + percent);
        return hsl2hex(h, s, l);
      }
      __name(lighten, "lighten");
      lib22.lighten = lighten;
      function darken(color, percent) {
        return lighten(color, -percent);
      }
      __name(darken, "darken");
      lib22.darken = darken;
      function component2hex(c) {
        const hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
      }
      __name(component2hex, "component2hex");
      lib22.component2hex = component2hex;
      function rgb2hex(r, g2, b) {
        return "#" + component2hex(r) + component2hex(g2) + component2hex(b);
      }
      __name(rgb2hex, "rgb2hex");
      lib22.rgb2hex = rgb2hex;
      function hex2rgb(color) {
        const r = parseInt(color.slice(1, 3), 16);
        const g2 = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        return [r, g2, b];
      }
      __name(hex2rgb, "hex2rgb");
      lib22.hex2rgb = hex2rgb;
    })(lib$4 || (lib$4 = {}));
    globalify({ colors: lib$4 });
    timers = {};
    BaseOfTimer = class {
      static {
        __name(this, "BaseOfTimer");
      }
      constructor(label) {
        this._time = Date.now();
        this._label = label ?? "";
      }
      static on(label) {
        delete timers[label];
      }
      static off(label) {
        timers[label] = false;
      }
      get label() {
        return this._label ?? "";
      }
      reset() {
        this._time = Date.now();
        return this;
      }
      isOn(label) {
        if (!label) {
          return timers[this.label] !== false;
        }
        const parts = label.split(":");
        let partLabel = this.label;
        for (let i = 0; i < parts.length; i++) {
          const part = parts[i];
          partLabel += `: ${part}`;
          if (timers[partLabel] === false) {
            return false;
          }
        }
        return true;
      }
    };
    Timer$1 = class Timer2 extends BaseOfTimer {
      static {
        __name(this, "Timer");
      }
      deltaTime() {
        const dt = Date.now() - this._time;
        this._time += dt;
        return dt.asMilliseconds;
      }
      log(label) {
        if (!this.isOn(label)) {
          return;
        }
        Console$1.log(
          `${this.label}${label ? `: ${label}` : ""}: ${this.deltaTime().inSeconds + "s"}`
        );
      }
      trace(label) {
        if (!this.isOn(label)) {
          return;
        }
        Console$1.trace(this.label + label, this.deltaTime().inSeconds + "s");
      }
    };
    TimeoutTimer = class extends Timer$1 {
      static {
        __name(this, "TimeoutTimer");
      }
      timeout(timeout) {
        const milliseconds = timeout.inMilliseconds;
        if (Date.now() - this._time > milliseconds) {
          this._time += milliseconds;
          return true;
        }
        return false;
      }
    };
    IntervalTimer = class extends Timer$1 {
      static {
        __name(this, "IntervalTimer");
      }
      constructor() {
        super(...arguments);
        this.__isIntervalStarted = false;
      }
      interval(interval, parameters) {
        if (!this.__isIntervalStarted) {
          this.__isIntervalStarted = true;
          if (parameters && parameters.skipFirstTime) {
            return false;
          }
          return true;
        }
        const milliseconds = interval.inMilliseconds;
        if (Date.now() - this._time > milliseconds) {
          this._time += milliseconds;
          return true;
        }
        return false;
      }
      reset() {
        super.reset();
        this.__isIntervalStarted = false;
        return this;
      }
    };
    WaitTimer$1 = class WaitTimer2 extends Timer$1 {
      static {
        __name(this, "WaitTimer");
      }
      constructor(label, timer) {
        super(label);
        this.__extra = 0;
        if (timer != null) {
          this.__extra = timer.__extra;
        }
      }
      async wait(time) {
        this.__updateExtra();
        this.__extra = Math.min(this.__extra, time.inMilliseconds);
        await idle((time.inMilliseconds - this.__extra).asMilliseconds);
        this.__extra -= time.inMilliseconds;
      }
      __updateExtra() {
        const newTime = Date.now();
        this.__extra += newTime - this._time;
        this._time = newTime;
      }
    };
    lib$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      BaseOfTimer,
      IntervalTimer,
      TimeoutTimer,
      WaitTimer: WaitTimer$1,
      default: Timer$1
    }, Symbol.toStringTag, { value: "Module" }));
    globalify({ Timer: Timer$1, ...lib$3 });
    secondMs = 1e3;
    minuteMs = secondMs * 60;
    hourMs = minuteMs * 60;
    dayMs = hourMs * 24;
    weekMs = dayMs * 7;
    lib$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      dayMs,
      hourMs,
      minuteMs,
      secondMs,
      weekMs
    }, Symbol.toStringTag, { value: "Module" }));
    globalify(lib$2);
    cx2 = cn2();
    __name(cn2, "cn");
    __name(getClassName, "getClassName");
    globalify({ cx: cx2, cn: cn2 });
    __name(__signalOnDestroy, "__signalOnDestroy");
    __uniqueId = 1;
    __name(destroy, "destroy");
    __BaseOfEffect = class {
      static {
        __name(this, "__BaseOfEffect");
      }
      constructor(main) {
        this.id = __uniqueId++;
        if (main != null) {
          this.main = main;
        }
        const Context3 = main?.constructor;
        if (Context3 && Context3.context) {
          if (Context3.__name == null) {
            if (Context3.name.startsWith("__")) {
              Context3.__name = Context3.name.slice(2);
            } else if (Context3.name.startsWith("_")) {
              Context3.__name = Context3.name.slice(1);
            } else {
              Context3.__name = Context3.name;
            }
          }
          this.__contexts = {
            [Context3.__name]: main
          };
        }
      }
      get isDestroyed() {
        return this.__stateOfDestroy != null;
      }
      get destroy() {
        return destroy;
      }
      set destroy(destroy2) {
        const originalDestroy = this.__destroy;
        this.__destroy = async () => {
          if (this.__stateOfDestroy === "destroyed") {
            return;
          }
          await destroy2.call(this);
          await originalDestroy.call(this);
        };
      }
      get updating() {
        {
          return null;
        }
      }
      addContext(ContextConstructor, context) {
        const Context3 = context.constructor;
        if (Context3.context == null) {
          throw Error("class missing context property");
        }
        this.__contexts ??= {};
        this.__contexts[Context3.__name] = context;
        this.__children && this.__children.forEach((child) => {
          child["__addContexts"]({
            [Context3.__name]: context
          });
        });
        return this;
      }
      removeContext(context) {
        const Context3 = context.constructor;
        if (Context3.context == null) {
          throw Error("class missing context property");
        }
        this.__contexts ??= {};
        delete this.__contexts[Context3.__name];
        this.__children && this.__children.forEach((child) => {
          child["__removeContexts"]({ [Context3.__name]: context });
        });
        return this;
      }
      hasContext(Context3) {
        as(Context3);
        if (this.__contexts == null || this.__contexts[Context3.__name] == null) {
          return false;
        }
        return true;
      }
      context(Context3) {
        as(Context3);
        if (this.__contexts == null || this.__contexts[Context3.__name] == null) {
          throw new Error("context missing");
        }
        return this.__contexts[Context3.__name];
      }
      emit(eventName, event, globalFields) {
        as(event);
        const localEvent = Object.assign({}, event);
        if (this.main != null) {
          emitWithHooks(eventName, this.main, this, this.__emit, event, localEvent, globalFields);
        } else {
          this.__emit(eventName, event, localEvent, globalFields);
        }
        return this;
      }
      emitReversed(eventName, event, globalFields) {
        as(event);
        const localEvent = Object.assign({}, event);
        if (this.main != null) {
          emitWithHooks(
            eventName,
            this.main,
            this,
            this.__emitReversed,
            event,
            localEvent,
            globalFields
          );
        } else {
          this.__emitReversed(eventName, event, localEvent, globalFields);
        }
        return this;
      }
      async __destroy() {
        this.__children && await Promise.all(
          this.__children.map(
            (child) => (async () => {
              child["__parents"].remove(this);
              if (child["__parents"].length > 0) {
                if (this.__contexts) {
                  child["__removeContexts"](this.__contexts);
                }
              } else {
                await child.destroy();
              }
            })()
          )
        );
        this.__effects && await Promise.all(
          this.__effects.map(async (effect) => {
            if (effect["__stateOfDestroy"] !== void 0) {
              return;
            }
            await effect.destroy();
          })
        );
        this.__stateOfDestroy = "destroyed";
      }
      __emit(eventName, event, localEvent, globalFields) {
        as(event);
        as(localEvent);
        const eventEmitter = this.main;
        if (eventEmitter && eventEmitter[eventName]) {
          eventEmitter[eventName](event);
        }
        if (localEvent.isCaptured) {
          event.isCaptured = true;
        }
        globalFields?.forEach((globalField) => {
          event[globalField] = localEvent[globalField];
        });
        if (this.__children == null) {
          return;
        }
        this.__children.forEach((child) => child.emit(eventName, localEvent, globalFields));
        if (localEvent.isCaptured) {
          event.isCaptured = true;
        }
        globalFields?.forEach((globalField) => {
          event[globalField] = localEvent[globalField];
        });
      }
      __emitReversed(eventName, event, localEvent, globalFields) {
        as(event);
        as(localEvent);
        const eventEmitter = this.main;
        if (eventEmitter && eventEmitter[eventName]) {
          eventEmitter[eventName](event);
        }
        if (localEvent.isCaptured) {
          event.isCaptured = true;
        }
        globalFields?.forEach((globalField) => {
          event[globalField] = localEvent[globalField];
        });
        if (this.__children == null) {
          return;
        }
        for (let i = this.__children.length - 1; i >= 0; --i) {
          this.__children[i].emitReversed(eventName, localEvent, globalFields);
        }
        if (localEvent.isCaptured) {
          event.isCaptured = true;
        }
        globalFields?.forEach((globalField) => {
          event[globalField] = localEvent[globalField];
        });
      }
    };
    ((lib22) => {
      class Effect2 extends __BaseOfEffect {
        static {
          __name(this, "Effect");
        }
        constructor(arg1, arg2, arg3) {
          let callback;
          let deps;
          let main;
          if (typeof arg1 === "function") {
            callback = arg1;
            deps = arg2;
            main = arg3;
          } else {
            deps = arg1;
            main = arg2;
          }
          if (!deps) {
            throw new Error("Effect: missing depends");
          }
          super(main);
          this.__isGotParentContexts = false;
          let parent;
          if (Array.isArray(deps)) {
            parent = deps[0];
          } else {
            parent = deps;
          }
          if (!parent) {
            throw new Error("Effect: missing parent");
          }
          this.__parents = [];
          this.addParent(parent);
          this.root = parent.root ?? parent;
          if (Array.isArray(deps) && deps.length > 1) {
            this.addDeps(...deps.slice(1));
          }
          if (callback) {
            const destroy2 = callback.call(this);
            if (destroy2) {
              this.destroy = destroy2;
            }
          }
        }
        static get updating() {
          return switch_thread();
        }
        addParent(parent) {
          parent["__children"] ??= [];
          parent["__children"].push(this);
          if (parent["__contexts"]) {
            async(async () => {
              await switch_thread();
              if (this.isDestroyed) {
                return;
              }
              this.__initContexts();
            });
          }
          this.__parents.push(parent);
          return this;
        }
        removeParents(...parents) {
          parents.forEach((parent) => {
            parent["__children"].remove(this);
            if (parent["__contexts"]) {
              this["__removeContexts"](parent["__contexts"]);
            }
            this.__parents.remove(parent);
          });
          if (this.__parents.length === 0) {
            this.destroy();
          }
          return this;
        }
        isParent(parent) {
          return !!parent["__children"]?.find((child) => child === this);
        }
        addDeps(...deps) {
          this.__dependencies ??= [];
          this.__dependencies.push(
            ...deps.filter((dep) => dep.context !== true)
          );
          deps.forEach((dep) => {
            if (dep.context !== true) {
              dep = dep;
              dep["__effects"] ??= [];
              dep["__effects"].push(this);
            } else {
              const Context3 = dep;
              const contextOwner = this.__parents[0];
              const context = contextOwner.context(Context3);
              if (!context) {
                throw new Error("context missing");
              }
              contextOwner["__contextEffects"] ??= {};
              contextOwner["__contextEffects"][Context3.__name] ??= [];
              contextOwner["__contextEffects"][Context3.__name].push(this);
            }
          });
          return this;
        }
        hasContext(Context3) {
          this.__initContexts();
          return super.hasContext(Context3);
        }
        context(Context3) {
          this.__initContexts();
          return super.context(Context3);
        }
        __initContexts() {
          if (this.__isGotParentContexts === false) {
            delete this.__isGotParentContexts;
            this.__parents.forEach((parent) => {
              if (parent instanceof Effect2) {
                parent.__initContexts();
              }
              this.__addContexts({
                ...parent["__contexts"]
              });
            });
          }
        }
        __addContexts(contexts) {
          this["__contexts"] ??= {};
          Object.keys(contexts).forEach((k) => {
            const context = contexts[k];
            this["__contexts"][k] = context;
            const contextTarget = this.main ?? this;
            if (contextTarget[`on${k}Context`]) {
              const destroy2 = contextTarget[`on${k}Context`](context);
              if (destroy2) {
                const Context3 = context.constructor;
                new Effect2(() => destroy2, [this, Context3]);
              }
            }
          });
          this["__children"]?.forEach((child) => child["__addContexts"](contexts));
        }
        async __removeContexts(contexts) {
          Object.keys(contexts).forEach((k) => {
            if (!this["__contexts"] || !this["__contexts"][k]) {
              return;
            }
            delete this["__contexts"][k];
          });
          await Promise.all(
            Object.keys(contexts).map(async (k) => {
              if (this["__contextEffects"] == null || this["__contextEffects"][k] == null) {
                return;
              }
              const contextEffects = this.__contextEffects[k];
              await Promise.all(contextEffects.map((contextEffect) => contextEffect.destroy()));
            })
          );
          if (this["__children"] != null) {
            await Promise.all(
              this["__children"].map((child) => child["__removeContexts"](contexts))
            );
          }
        }
      }
      lib22.Effect = Effect2;
      Effect2.prototype["__destroy"] = async function() {
        if (this["__parents"]) {
          this["__parents"].forEach((parent) => {
            if (parent["__stateOfDestroy"] === void 0) {
              parent["__children"].remove(this);
            }
          });
        }
        if (this["__dependencies"]) {
          this["__dependencies"].forEach((dep) => {
            if (dep["__stateOfDestroy"] === void 0) {
              dep["__effects"].remove(this);
            }
          });
        }
        await __BaseOfEffect.prototype["__destroy"].call(this);
      };
    })(lib$1 || (lib$1 = {}));
    globalify(lib$1);
    __name(clamp, "clamp");
    Vector2 = class _Vector2 {
      static {
        __name(this, "Vector2");
      }
      /**
       * Constructs a new 2D vector.
       *
       * @param {number} [x=0] - The x value of this vector.
       * @param {number} [y=0] - The y value of this vector.
       */
      constructor(x = 0, y = 0) {
        _Vector2.prototype.isVector2 = true;
        this.x = x;
        this.y = y;
      }
      /**
       * Alias for {@link Vector2#x}.
       *
       * @type {number}
       */
      get width() {
        return this.x;
      }
      set width(value) {
        this.x = value;
      }
      /**
       * Alias for {@link Vector2#y}.
       *
       * @type {number}
       */
      get height() {
        return this.y;
      }
      set height(value) {
        this.y = value;
      }
      /**
       * Sets the vector components.
       *
       * @param {number} x - The value of the x component.
       * @param {number} y - The value of the y component.
       * @return {Vector2} A reference to this vector.
       */
      set(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
      /**
       * Sets the vector components to the same value.
       *
       * @param {number} scalar - The value to set for all vector components.
       * @return {Vector2} A reference to this vector.
       */
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
      }
      /**
       * Sets the vector's x component to the given value
       *
       * @param {number} x - The value to set.
       * @return {Vector2} A reference to this vector.
       */
      setX(x) {
        this.x = x;
        return this;
      }
      /**
       * Sets the vector's y component to the given value
       *
       * @param {number} y - The value to set.
       * @return {Vector2} A reference to this vector.
       */
      setY(y) {
        this.y = y;
        return this;
      }
      /**
       * Allows to set a vector component with an index.
       *
       * @param {number} index - The component index. `0` equals to x, `1` equals to y.
       * @param {number} value - The value to set.
       * @return {Vector2} A reference to this vector.
       */
      setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      }
      /**
       * Returns the value of the vector component which matches the given index.
       *
       * @param {number} index - The component index. `0` equals to x, `1` equals to y.
       * @return {number} A vector component value.
       */
      getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + index);
        }
      }
      /**
       * Returns a new vector with copied values from this instance.
       *
       * @return {Vector2} A clone of this instance.
       */
      clone() {
        return new this.constructor(this.x, this.y);
      }
      /**
       * Copies the values of the given vector to this instance.
       *
       * @param {Vector2} v - The vector to copy.
       * @return {Vector2} A reference to this vector.
       */
      copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      }
      /**
       * Adds the given vector to this instance.
       *
       * @param {Vector2} v - The vector to add.
       * @return {Vector2} A reference to this vector.
       */
      add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
      }
      /**
       * Adds the given scalar value to all components of this instance.
       *
       * @param {number} s - The scalar to add.
       * @return {Vector2} A reference to this vector.
       */
      addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
      }
      /**
       * Adds the given vectors and stores the result in this instance.
       *
       * @param {Vector2} a - The first vector.
       * @param {Vector2} b - The second vector.
       * @return {Vector2} A reference to this vector.
       */
      addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      }
      /**
       * Adds the given vector scaled by the given factor to this instance.
       *
       * @param {Vector2} v - The vector.
       * @param {number} s - The factor that scales `v`.
       * @return {Vector2} A reference to this vector.
       */
      addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
      }
      /**
       * Subtracts the given vector from this instance.
       *
       * @param {Vector2} v - The vector to subtract.
       * @return {Vector2} A reference to this vector.
       */
      sub(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
      }
      /**
       * Subtracts the given scalar value from all components of this instance.
       *
       * @param {number} s - The scalar to subtract.
       * @return {Vector2} A reference to this vector.
       */
      subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
      }
      /**
       * Subtracts the given vectors and stores the result in this instance.
       *
       * @param {Vector2} a - The first vector.
       * @param {Vector2} b - The second vector.
       * @return {Vector2} A reference to this vector.
       */
      subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      }
      /**
       * Multiplies the given vector with this instance.
       *
       * @param {Vector2} v - The vector to multiply.
       * @return {Vector2} A reference to this vector.
       */
      multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      }
      /**
       * Multiplies the given scalar value with all components of this instance.
       *
       * @param {number} scalar - The scalar to multiply.
       * @return {Vector2} A reference to this vector.
       */
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      }
      /**
       * Divides this instance by the given vector.
       *
       * @param {Vector2} v - The vector to divide.
       * @return {Vector2} A reference to this vector.
       */
      divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      }
      /**
       * Divides this vector by the given scalar.
       *
       * @param {number} scalar - The scalar to divide.
       * @return {Vector2} A reference to this vector.
       */
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      /**
       * Multiplies this vector (with an implicit 1 as the 3rd component) by
       * the given 3x3 matrix.
       *
       * @param {Matrix3} m - The matrix to apply.
       * @return {Vector2} A reference to this vector.
       */
      applyMatrix3(m) {
        const x = this.x, y = this.y;
        const e2 = m.elements;
        this.x = e2[0] * x + e2[3] * y + e2[6];
        this.y = e2[1] * x + e2[4] * y + e2[7];
        return this;
      }
      /**
       * If this vector's x or y value is greater than the given vector's x or y
       * value, replace that value with the corresponding min value.
       *
       * @param {Vector2} v - The vector.
       * @return {Vector2} A reference to this vector.
       */
      min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
      }
      /**
       * If this vector's x or y value is less than the given vector's x or y
       * value, replace that value with the corresponding max value.
       *
       * @param {Vector2} v - The vector.
       * @return {Vector2} A reference to this vector.
       */
      max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
      }
      /**
       * If this vector's x or y value is greater than the max vector's x or y
       * value, it is replaced by the corresponding value.
       * If this vector's x or y value is less than the min vector's x or y value,
       * it is replaced by the corresponding value.
       *
       * @param {Vector2} min - The minimum x and y values.
       * @param {Vector2} max - The maximum x and y values in the desired range.
       * @return {Vector2} A reference to this vector.
       */
      clamp(min, max) {
        this.x = clamp(this.x, min.x, max.x);
        this.y = clamp(this.y, min.y, max.y);
        return this;
      }
      /**
       * If this vector's x or y values are greater than the max value, they are
       * replaced by the max value.
       * If this vector's x or y values are less than the min value, they are
       * replaced by the min value.
       *
       * @param {number} minVal - The minimum value the components will be clamped to.
       * @param {number} maxVal - The maximum value the components will be clamped to.
       * @return {Vector2} A reference to this vector.
       */
      clampScalar(minVal, maxVal) {
        this.x = clamp(this.x, minVal, maxVal);
        this.y = clamp(this.y, minVal, maxVal);
        return this;
      }
      /**
       * If this vector's length is greater than the max value, it is replaced by
       * the max value.
       * If this vector's length is less than the min value, it is replaced by the
       * min value.
       *
       * @param {number} min - The minimum value the vector length will be clamped to.
       * @param {number} max - The maximum value the vector length will be clamped to.
       * @return {Vector2} A reference to this vector.
       */
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
      }
      /**
       * The components of this vector are rounded down to the nearest integer value.
       *
       * @return {Vector2} A reference to this vector.
       */
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      }
      /**
       * The components of this vector are rounded up to the nearest integer value.
       *
       * @return {Vector2} A reference to this vector.
       */
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      }
      /**
       * The components of this vector are rounded to the nearest integer value
       *
       * @return {Vector2} A reference to this vector.
       */
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      }
      /**
       * The components of this vector are rounded towards zero (up if negative,
       * down if positive) to an integer value.
       *
       * @return {Vector2} A reference to this vector.
       */
      roundToZero() {
        this.x = Math.trunc(this.x);
        this.y = Math.trunc(this.y);
        return this;
      }
      /**
       * Inverts this vector - i.e. sets x = -x and y = -y.
       *
       * @return {Vector2} A reference to this vector.
       */
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      }
      /**
       * Calculates the dot product of the given vector with this instance.
       *
       * @param {Vector2} v - The vector to compute the dot product with.
       * @return {number} The result of the dot product.
       */
      dot(v) {
        return this.x * v.x + this.y * v.y;
      }
      /**
       * Calculates the cross product of the given vector with this instance.
       *
       * @param {Vector2} v - The vector to compute the cross product with.
       * @return {number} The result of the cross product.
       */
      cross(v) {
        return this.x * v.y - this.y * v.x;
      }
      /**
       * Computes the square of the Euclidean length (straight-line length) from
       * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
       * compare the length squared instead as it is slightly more efficient to calculate.
       *
       * @return {number} The square length of this vector.
       */
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      /**
       * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
       *
       * @return {number} The length of this vector.
       */
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      /**
       * Computes the Manhattan length of this vector.
       *
       * @return {number} The length of this vector.
       */
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      /**
       * Converts this vector to a unit vector - that is, sets it equal to a vector
       * with the same direction as this one, but with a vector length of `1`.
       *
       * @return {Vector2} A reference to this vector.
       */
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      /**
       * Computes the angle in radians of this vector with respect to the positive x-axis.
       *
       * @return {number} The angle in radians.
       */
      angle() {
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
      }
      /**
       * Returns the angle between the given vector and this instance in radians.
       *
       * @param {Vector2} v - The vector to compute the angle with.
       * @return {number} The angle in radians.
       */
      angleTo(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        const theta = this.dot(v) / denominator;
        return Math.acos(clamp(theta, -1, 1));
      }
      /**
       * Computes the distance from the given vector to this instance.
       *
       * @param {Vector2} v - The vector to compute the distance to.
       * @return {number} The distance.
       */
      distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
      /**
       * Computes the squared distance from the given vector to this instance.
       * If you are just comparing the distance with another distance, you should compare
       * the distance squared instead as it is slightly more efficient to calculate.
       *
       * @param {Vector2} v - The vector to compute the squared distance to.
       * @return {number} The squared distance.
       */
      distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
      }
      /**
       * Computes the Manhattan distance from the given vector to this instance.
       *
       * @param {Vector2} v - The vector to compute the Manhattan distance to.
       * @return {number} The Manhattan distance.
       */
      manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
      }
      /**
       * Sets this vector to a vector with the same direction as this one, but
       * with the specified length.
       *
       * @param {number} length - The new length of this vector.
       * @return {Vector2} A reference to this vector.
       */
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      /**
       * Linearly interpolates between the given vector and this instance, where
       * alpha is the percent distance along the line - alpha = 0 will be this
       * vector, and alpha = 1 will be the given one.
       *
       * @param {Vector2} v - The vector to interpolate towards.
       * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
       * @return {Vector2} A reference to this vector.
       */
      lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      }
      /**
       * Linearly interpolates between the given vectors, where alpha is the percent
       * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
       * be the second one. The result is stored in this instance.
       *
       * @param {Vector2} v1 - The first vector.
       * @param {Vector2} v2 - The second vector.
       * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
       * @return {Vector2} A reference to this vector.
       */
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
      }
      /**
       * Returns `true` if this vector is equal with the given one.
       *
       * @param {Vector2} v - The vector to test for equality.
       * @return {boolean} Whether this vector is equal with the given one.
       */
      equals(v) {
        return v.x === this.x && v.y === this.y;
      }
      /**
       * Sets this vector's x value to be `array[ offset ]` and y
       * value to be `array[ offset + 1 ]`.
       *
       * @param {Array<number>} array - An array holding the vector component values.
       * @param {number} [offset=0] - The offset into the array.
       * @return {Vector2} A reference to this vector.
       */
      fromArray(array2, offset = 0) {
        this.x = array2[offset];
        this.y = array2[offset + 1];
        return this;
      }
      /**
       * Writes the components of this vector to the given array. If no array is provided,
       * the method returns a new instance.
       *
       * @param {Array<number>} [array=[]] - The target array holding the vector components.
       * @param {number} [offset=0] - Index of the first element in the array.
       * @return {Array<number>} The vector components.
       */
      toArray(array2 = [], offset = 0) {
        array2[offset] = this.x;
        array2[offset + 1] = this.y;
        return array2;
      }
      /**
       * Sets the components of this vector from the given buffer attribute.
       *
       * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
       * @param {number} index - The index into the attribute.
       * @return {Vector2} A reference to this vector.
       */
      fromBufferAttribute(attribute, index) {
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
      }
      /**
       * Rotates this vector around the given center by the given angle.
       *
       * @param {Vector2} center - The point around which to rotate.
       * @param {number} angle - The angle to rotate, in radians.
       * @return {Vector2} A reference to this vector.
       */
      rotateAround(center, angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
      }
      /**
       * Sets each component of this vector to a pseudo-random value between `0` and
       * `1`, excluding `1`.
       *
       * @return {Vector2} A reference to this vector.
       */
      random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
      }
    };
    ((lib22) => {
      class EffectsRoot extends __BaseOfEffect {
        static {
          __name(this, "EffectsRoot");
        }
        constructor() {
          super(...arguments);
          this.isLeftMousePressed = false;
          this.isMiddleMousePressed = false;
          this.isRightMousePressed = false;
          this.isPressed = {};
          this.isUICaptured = false;
        }
        static get updating() {
          return switch_thread();
        }
        registerEmitUpdate(before, after) {
          this.__timer = new Timer();
          if (runsOnServerSide2) {
            new Loop(
              Time(1 / 50, seconds),
              () => {
                if (this.__timer == null) {
                  throw new NullError();
                }
                const dt = this.__timer.deltaTime().seconds;
                before && before();
                this.emit("beforeUpdate", { dt, isCaptured: false });
                this.emit("update", { dt, isCaptured: false });
                this.emit("afterUpdate", { dt, isCaptured: false });
                after && after();
              },
              this
            );
          } else {
            new AnimationFrames(() => {
              if (this.__timer == null) {
                throw new NullError();
              }
              const dt = this.__timer.deltaTime().seconds;
              before && before();
              this.emit("beforeUpdate", { dt, isCaptured: false });
              this.emit("update", { dt, isCaptured: false });
              this.emit("afterUpdate", { dt, isCaptured: false });
              this.emit("beforeAnimationFrame", { dt, isCaptured: false });
              this.emit("onAnimationFrame", { dt, isCaptured: false });
              this.emit("afterAnimationFrame", { dt, isCaptured: false });
              after && after();
              this.isUICaptured = false;
            }, this);
          }
          return this;
        }
        registerEmitMouseEvents(before, after) {
          new WindowEventListener(
            "mousemove",
            (ev) => {
              let mouse = new Vector2().copy(ev);
              if (before) {
                mouse = before(mouse);
              }
              this.emitReversed("onGlobalMouseMove", {
                x: mouse.x,
                y: mouse.y,
                isCaptured: this.isUICaptured
              });
              after && after(mouse);
            },
            [this]
          );
          new WindowEventListener(
            "mousedown",
            (ev) => {
              if (ev.button === 0) {
                this.isLeftMousePressed = true;
              } else if (ev.button === 1) {
                this.isMiddleMousePressed = true;
              } else if (ev.button === 2) {
                this.isRightMousePressed = true;
              }
              let mouse = new Vector2().copy(ev);
              if (before) {
                mouse = before(mouse);
              }
              this.emitReversed("onGlobalMouseDown", {
                x: mouse.x,
                y: mouse.y,
                button: ev.button,
                isCaptured: this.isUICaptured
              });
              after && after(mouse);
            },
            [this]
          );
          new WindowEventListener(
            "mouseup",
            (ev) => {
              if (ev.button === 0) {
                this.isLeftMousePressed = false;
              } else if (ev.button === 1) {
                this.isMiddleMousePressed = false;
              } else if (ev.button === 2) {
                this.isRightMousePressed = false;
              }
              let mouse = new Vector2().copy(ev);
              if (before) {
                mouse = before(mouse);
              }
              this.emitReversed("onGlobalMouseUp", {
                x: mouse.x,
                y: mouse.y,
                isCaptured: this.isUICaptured
              });
              after && after(mouse);
            },
            [this]
          );
          new WindowEventListener(
            "click",
            (ev) => {
              let mouse = new Vector2().copy(ev);
              if (before) {
                mouse = before(mouse);
              }
              this.emitReversed("globalClick", { x: mouse.x, y: mouse.y, isCaptured: false });
              after && after(mouse);
            },
            [this]
          );
          new WindowEventListener(
            "wheel",
            (ev) => {
              this.emitReversed("onGlobalScroll", {
                x: ev.deltaX,
                y: ev.deltaY,
                z: ev.deltaZ,
                isCaptured: this.isUICaptured
              });
            },
            [this]
          );
          return this;
        }
        registerEmitKeyboardEvents(before, after) {
          new WindowEventListener(
            "keydown",
            (ev) => {
              this.isPressed[ev.code] = true;
              before && before();
              this.emit("onGlobalKeyDown", { code: ev.code, isCaptured: false });
              after && after();
            },
            [this]
          );
          new WindowEventListener(
            "keyup",
            (ev) => {
              delete this.isPressed[ev.code];
              before && before();
              this.emit("onGlobalKeyUp", { code: ev.code, isCaptured: false });
              after && after();
            },
            [this]
          );
          new WindowEventListener(
            "keypress",
            (ev) => {
              before && before();
              this.emit("onGlobalKeyPress", { code: ev.code, isCaptured: false });
              after && after();
            },
            [this]
          );
          return this;
        }
        registerEmitRender(before, after) {
          new AnimationFrames(() => {
            before && before();
            this.emit("beforeRender", {
              isCaptured: false
            });
            this.emit("render", {
              isCaptured: false
            });
            this.emit("afterRender", {
              isCaptured: false
            });
            after && after();
          }, this);
          return this;
        }
        registerEmitDraw(before, after) {
          new AnimationFrames(() => {
            let position = new Vector2();
            if (before) {
              position = before(position) ?? new Vector2();
            }
            this.emit("beforeDraw", {
              x: position.x,
              y: position.y,
              opacity: 1,
              visible: true,
              isCaptured: false
            });
            this.emit("draw", {
              x: position.x,
              y: position.y,
              opacity: 1,
              visible: true,
              isCaptured: false
            });
            this.emit("afterDraw", {
              x: position.x,
              y: position.y,
              opacity: 1,
              visible: true,
              isCaptured: false
            });
            after && after(position);
          }, this);
          return this;
        }
        registerEmitWindowResize(resize) {
          resize(window.innerWidth, window.innerHeight);
          new WindowEventListener(
            "resize",
            () => {
              resize(window.innerWidth, window.innerHeight);
            },
            this
          );
          return this;
        }
      }
      lib22.EffectsRoot = EffectsRoot;
    })(lib || (lib = {}));
    globalify(lib);
    __name(default__getEffect, "default__getEffect");
    __name(property, "property");
    __name(inArray, "inArray");
    Timeout = class {
      static {
        __name(this, "Timeout");
      }
      constructor(callback, timeout, deps, ...args) {
        this.effect = new Effect(deps, this);
        const { destroy: destroy2 } = this.effect;
        const identifier = setTimeout(async () => {
          await callback(...args);
          await destroy2.call(this.effect);
        }, timeout.valueOf() * 1e3);
        this.effect.destroy = () => {
          clearTimeout(identifier);
        };
      }
    };
    Interval = class {
      static {
        __name(this, "Interval");
      }
      constructor(callback, interval, deps, ...args) {
        this.effect = new Effect(deps, this);
        const identifier = setInterval(async () => {
          await callback(...args);
        }, interval.valueOf() * 1e3);
        this.effect.destroy = () => {
          clearInterval(identifier);
        };
      }
    };
    AnimationFrame = class {
      static {
        __name(this, "AnimationFrame");
      }
      constructor(callback, deps, ...args) {
        this.effect = new Effect(deps, this);
        const identifier = requestAnimationFrame(async () => await callback(...args));
        this.effect.destroy = () => {
          cancelAnimationFrame(identifier);
        };
      }
    };
    AnimationFrames$1 = class AnimationFrames2 {
      static {
        __name(this, "AnimationFrames");
      }
      constructor(callback, deps, ...args) {
        this.effect = new Effect(deps, this);
        let identifier;
        const frame = /* @__PURE__ */ __name(async () => {
          await callback(...args);
          identifier = requestAnimationFrame(frame);
        }, "frame");
        identifier = requestAnimationFrame(frame);
        this.effect.destroy = () => {
          cancelAnimationFrame(identifier);
        };
      }
    };
    WindowEventListener$1 = class WindowEventListener2 {
      static {
        __name(this, "WindowEventListener");
      }
      constructor(type2, listener, deps, options) {
        this.effect = new Effect(deps, this);
        const handle = /* @__PURE__ */ __name((...args) => {
          listener.call(window, ...args);
        }, "handle");
        window.addEventListener(type2, handle, options);
        this.effect.destroy = () => {
          window.removeEventListener(type2, handle, options);
        };
      }
    };
    DocumentEventListener = class {
      static {
        __name(this, "DocumentEventListener");
      }
      constructor(type2, listener, deps, options) {
        this.effect = new Effect(deps, this);
        const handle = /* @__PURE__ */ __name((...args) => {
          listener.call(window, ...args);
        }, "handle");
        document.addEventListener(type2, handle, options);
        this.effect.destroy = () => {
          document.removeEventListener(type2, handle, options);
        };
      }
    };
    PointerLock = class {
      static {
        __name(this, "PointerLock");
      }
      constructor(deps) {
        this.effect = new Effect(deps, this);
        this.enabling = document.body.requestPointerLock();
        this.effect.destroy = () => {
          document.exitPointerLock();
        };
      }
    };
    Fullscreen = class {
      static {
        __name(this, "Fullscreen");
      }
      constructor(deps) {
        this.effect = new Effect(deps, this);
        this.requesting = document.body.requestFullscreen();
        this.effect.destroy = async () => {
          await document.exitFullscreen();
        };
      }
    };
    globalify({
      property,
      inArray,
      Timeout,
      Interval,
      AnimationFrame,
      AnimationFrames: AnimationFrames$1,
      WindowEventListener: WindowEventListener$1,
      DocumentEventListener,
      PointerLock,
      Fullscreen
    });
    Loop$1 = class Loop2 {
      static {
        __name(this, "Loop");
      }
      constructor(interval, callback, deps) {
        this.effect = new Effect(deps, this);
        const controller = { disposed: false };
        this.looping = this.__loop(controller, interval, callback);
        this.effect.destroy = async () => {
          controller.disposed = true;
          await this.looping;
        };
      }
      async __loop(controller, interval, callback) {
        const timer = new Timer();
        const waitTimer = new WaitTimer("loop");
        while (true) {
          if (controller.disposed) {
            return;
          }
          await callback(timer.deltaTime());
          await waitTimer.wait(interval);
        }
      }
    };
    globalify({ Loop: Loop$1 });
  }
});

// .dev/build/sky.examples.platform.web/web/server/entries/pages_index.mjs
var pages_index_exports = {};
__export(pages_index_exports, {
  configValuesSerialized: () => configValuesSerialized
});
function Box$1(props) {
  const { className, sx: sx2, as: as2, children, ...restProps } = props;
  const Tag = as2 ?? "div";
  return (
    // @ts-expect-error
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Tag, { ...restProps, className: cx2(className, sx2), children })
  );
}
function sxWith(cx22) {
  function commonSx(tag, sx3, ...args) {
    sx3 = cx22(sx3, ...args);
    return /* @__PURE__ */ __name(function Styled(props) {
      const finalSX = props.sx ? `${sx3} ${props.sx}` : sx3;
      return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Box, { as: tag, ...props, sx: finalSX });
    }, "Styled");
  }
  __name(commonSx, "commonSx");
  function createSxAs(tag) {
    return /* @__PURE__ */ __name(function sxAs(sx3, ...args) {
      return commonSx(tag, sx3, ...args);
    }, "sxAs");
  }
  __name(createSxAs, "createSxAs");
  function sx2(sx3, ...args) {
    return commonSx("div", sx3, ...args);
  }
  __name(sx2, "sx2");
  sx2.header = createSxAs("header");
  sx2.footer = createSxAs("footer");
  sx2.div = createSxAs("div");
  sx2.section = createSxAs("section");
  sx2.span = createSxAs("span");
  sx2.a = createSxAs("a");
  sx2.input = createSxAs("input");
  sx2.form = createSxAs("form");
  sx2.textarea = createSxAs("textarea");
  sx2.label = createSxAs("label");
  sx2.p = createSxAs("p");
  sx2.b = createSxAs("b");
  sx2.i = createSxAs("i");
  return sx2;
}
function HomePage() {
  const apiData = {};
  Console.log(42);
  useEffect(() => {
    async(onTest, 42);
  }, []);
  const Foo2 = sx.form`
        @Foo
        bg-pink-500
    `;
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { style: { padding: "2rem", fontFamily: "system-ui" }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h1", { children: "Vike + Hono + Cloudflare Workers" }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("p", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("strong", { children: "Message:" }),
        " ",
        apiData.message
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("p", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("strong", { children: "Location:" }),
        " ",
        apiData.location.city,
        ", ",
        apiData.location.country,
        apiData.location.colo && ` (colo: ${apiData.location.colo})`
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { children: "This page was rendered at the edge, closest to you! \u{1F30D}" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Foo2, { sx: "flex mt-3 align-center", children: "aspect 2" }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Box, { sx: "flex mt-2 align-center", children: "aspect" }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Box, { className: styles.Box2, children: "aspect" }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Box, { className: cx$1`@Box2` }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Box, { sx: cx$1`Box2`, children: "aspect" }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(Box, { className: cx$1`@Box2`, sx: "aspect-[16/9]", children: [
      "aspect",
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("br", {})
    ] })
  ] });
}
async function data(pageContext) {
  try {
    const apiUrl = new URL("/api/hello", pageContext.urlOriginal).toString();
    const response = await fetch(apiUrl);
    if (!response.ok) {
      throw new Error(`API error: ${response.status}`);
    }
    const apiData = await response.json();
    return { apiData };
  } catch (error) {
    console.error("Failed to fetch API data:", error);
    return { apiData: { message: "Failed to load data", location: {} } };
  }
}
var import_jsx_runtime2, import_react5, import_classnames2, lib2, sx$1, sx$2, container, fluid, row, col, Foo, Boo, One, Box2, Box3, title, spin, ping, pulse, bounce, styles, cx$1, sx, import2, import3, configValuesSerialized;
var init_pages_index = __esm({
  async ".dev/build/sky.examples.platform.web/web/server/entries/pages_index.mjs"() {
    "use strict";
    await init_chunk_D8IZrfLU();
    import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
    init_chunk_DtOK7jkR();
    init_index_web_only();
    init_runtime2();
    import_react5 = __toESM(require_react(), 1);
    import_classnames2 = __toESM(require_classnames(), 1);
    init_server();
    iAm("sky.react.components.layout.Box", Promise.resolve().then(() => lib2));
    __name(Box$1, "Box$1");
    lib2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: Box$1
    }, Symbol.toStringTag, { value: "Module" }));
    globalify({ Box: Box$1, ...lib2 });
    iAm("sx", Promise.resolve().then(() => sx$2));
    sx$1 = sxWith(cx);
    __name(sxWith, "sxWith");
    sx$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: sx$1,
      sxWith
    }, Symbol.toStringTag, { value: "Module" }));
    container = "HomePage-container";
    fluid = "HomePage-fluid";
    row = "HomePage-row";
    col = "HomePage-col";
    Foo = "HomePage-Foo";
    Boo = "HomePage-Boo";
    One = "HomePage-One";
    Box2 = "HomePage-Box2";
    Box3 = "HomePage-Box3";
    title = "HomePage-title";
    spin = "HomePage-spin";
    ping = "HomePage-ping";
    pulse = "HomePage-pulse";
    bounce = "HomePage-bounce";
    styles = {
      "theme-dark": "HomePage-theme-dark",
      container,
      fluid,
      row,
      col,
      Foo,
      Boo,
      One,
      "Two-A": "HomePage-Two-A",
      "Two-B": "HomePage-Two-B",
      Box2,
      Box3,
      title,
      spin,
      ping,
      pulse,
      bounce
    };
    cx$1 = cn(styles);
    sx = sxWith(cx$1);
    __name(HomePage, "HomePage");
    import2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: HomePage
    }, Symbol.toStringTag, { value: "Module" }));
    __name(data, "data");
    import3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      data
    }, Symbol.toStringTag, { value: "Module" }));
    configValuesSerialized = {
      ["isClientRuntimeLoaded"]: {
        type: "computed",
        definedAtData: null,
        valueSerialized: {
          type: "js-serialized",
          value: false
        }
      },
      ["onRenderHtml"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/renderer/+onRenderHtml.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import1
        }
      },
      ["Page"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/index/+Page.tsx", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import2
        }
      },
      ["data"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/index/+data.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import3
        }
      }
    };
  }
});

// .dev/build/sky.examples.platform.web/web/server/chunks/chunk-CQSiE3-x.js
function usePageContext() {
  return (0, import_react6.useContext)(Context2);
}
var import_react6, import_jsx_runtime3, Context2;
var init_chunk_CQSiE3_x = __esm({
  ".dev/build/sky.examples.platform.web/web/server/chunks/chunk-CQSiE3-x.js"() {
    "use strict";
    import_react6 = __toESM(require_react(), 1);
    import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
    Context2 = (0, import_react6.createContext)(void 0);
    __name(usePageContext, "usePageContext");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/subscribable.js
var Subscribable;
var init_subscribable = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/subscribable.js"() {
    Subscribable = class {
      static {
        __name(this, "Subscribable");
      }
      constructor() {
        this.listeners = /* @__PURE__ */ new Set();
        this.subscribe = this.subscribe.bind(this);
      }
      subscribe(listener) {
        this.listeners.add(listener);
        this.onSubscribe();
        return () => {
          this.listeners.delete(listener);
          this.onUnsubscribe();
        };
      }
      hasListeners() {
        return this.listeners.size > 0;
      }
      onSubscribe() {
      }
      onUnsubscribe() {
      }
    };
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/timeoutManager.js
function systemSetTimeoutZero(callback) {
  setTimeout(callback, 0);
}
var defaultTimeoutProvider, TimeoutManager, timeoutManager;
var init_timeoutManager = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/timeoutManager.js"() {
    defaultTimeoutProvider = {
      // We need the wrapper function syntax below instead of direct references to
      // global setTimeout etc.
      //
      // BAD: `setTimeout: setTimeout`
      // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
      //
      // If we use direct references here, then anything that wants to spy on or
      // replace the global setTimeout (like tests) won't work since we'll already
      // have a hard reference to the original implementation at the time when this
      // file was imported.
      setTimeout: /* @__PURE__ */ __name((callback, delay) => setTimeout(callback, delay), "setTimeout"),
      clearTimeout: /* @__PURE__ */ __name((timeoutId) => clearTimeout(timeoutId), "clearTimeout"),
      setInterval: /* @__PURE__ */ __name((callback, delay) => setInterval(callback, delay), "setInterval"),
      clearInterval: /* @__PURE__ */ __name((intervalId) => clearInterval(intervalId), "clearInterval")
    };
    TimeoutManager = class {
      static {
        __name(this, "TimeoutManager");
      }
      // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
      // type at app boot; and if we leave that type, then any new timer provider
      // would need to support ReturnType<typeof setTimeout>, which is infeasible.
      //
      // We settle for type safety for the TimeoutProvider type, and accept that
      // this class is unsafe internally to allow for extension.
      #provider = defaultTimeoutProvider;
      #providerCalled = false;
      setTimeoutProvider(provider) {
        if (true) {
          if (this.#providerCalled && provider !== this.#provider) {
            console.error(
              `[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`,
              { previous: this.#provider, provider }
            );
          }
        }
        this.#provider = provider;
        if (true) {
          this.#providerCalled = false;
        }
      }
      setTimeout(callback, delay) {
        if (true) {
          this.#providerCalled = true;
        }
        return this.#provider.setTimeout(callback, delay);
      }
      clearTimeout(timeoutId) {
        this.#provider.clearTimeout(timeoutId);
      }
      setInterval(callback, delay) {
        if (true) {
          this.#providerCalled = true;
        }
        return this.#provider.setInterval(callback, delay);
      }
      clearInterval(intervalId) {
        this.#provider.clearInterval(intervalId);
      }
    };
    timeoutManager = new TimeoutManager();
    __name(systemSetTimeoutZero, "systemSetTimeoutZero");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/utils.js
function noop() {
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query2) {
  return typeof staleTime === "function" ? staleTime(query2) : staleTime;
}
function resolveEnabled(enabled, query2) {
  return typeof enabled === "function" ? enabled(query2) : enabled;
}
function matchQuery(filters, query2) {
  const {
    type: type2 = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query2.queryHash !== hashQueryKeyByOptions(queryKey, query2.options)) {
        return false;
      }
    } else if (!partialMatchKey(query2.queryKey, queryKey)) {
      return false;
    }
  }
  if (type2 !== "all") {
    const isActive = query2.isActive();
    if (type2 === "active" && !isActive) {
      return false;
    }
    if (type2 === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query2.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query2.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query2)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status: status2, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status2 && mutation.state.status !== status2) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = options?.queryKeyHashFn || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject3(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));
  }
  return false;
}
function replaceEqualDeep(a, b) {
  if (a === b) {
    return a;
  }
  const array2 = isPlainArray(a) && isPlainArray(b);
  if (!array2 && !(isPlainObject3(a) && isPlainObject3(b))) return b;
  const aItems = array2 ? a : Object.keys(a);
  const aSize = aItems.length;
  const bItems = array2 ? b : Object.keys(b);
  const bSize = bItems.length;
  const copy2 = array2 ? new Array(bSize) : {};
  let equalItems = 0;
  for (let i = 0; i < bSize; i++) {
    const key = array2 ? i : bItems[i];
    const aItem = a[key];
    const bItem = b[key];
    if (aItem === bItem) {
      copy2[key] = aItem;
      if (array2 ? i < aSize : hasOwn.call(a, key)) equalItems++;
      continue;
    }
    if (aItem === null || bItem === null || typeof aItem !== "object" || typeof bItem !== "object") {
      copy2[key] = bItem;
      continue;
    }
    const v = replaceEqualDeep(aItem, bItem);
    copy2[key] = v;
    if (v === aItem) equalItems++;
  }
  return aSize === bSize && equalItems === aSize ? a : copy2;
}
function shallowEqualObjects(a, b) {
  if (!b || Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject3(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    timeoutManager.setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data4, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data4);
  } else if (options.structuralSharing !== false) {
    if (true) {
      try {
        return replaceEqualDeep(prevData, data4);
      } catch (error) {
        console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`
        );
        throw error;
      }
    }
    return replaceEqualDeep(prevData, data4);
  }
  return data4;
}
function addToEnd(items, item, max = 0) {
  const newItems = [...items, item];
  return max && newItems.length > max ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max = 0) {
  const newItems = [item, ...items];
  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
}
function ensureQueryFn(options, fetchOptions) {
  if (true) {
    if (options.queryFn === skipToken) {
      console.error(
        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`
      );
    }
  }
  if (!options.queryFn && fetchOptions?.initialPromise) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
function shouldThrowError(throwOnError, params) {
  if (typeof throwOnError === "function") {
    return throwOnError(...params);
  }
  return !!throwOnError;
}
var isServer, hasOwn, skipToken;
var init_utils10 = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/utils.js"() {
    init_timeoutManager();
    isServer = typeof window === "undefined" || "Deno" in globalThis;
    __name(noop, "noop");
    __name(functionalUpdate, "functionalUpdate");
    __name(isValidTimeout, "isValidTimeout");
    __name(timeUntilStale, "timeUntilStale");
    __name(resolveStaleTime, "resolveStaleTime");
    __name(resolveEnabled, "resolveEnabled");
    __name(matchQuery, "matchQuery");
    __name(matchMutation, "matchMutation");
    __name(hashQueryKeyByOptions, "hashQueryKeyByOptions");
    __name(hashKey, "hashKey");
    __name(partialMatchKey, "partialMatchKey");
    hasOwn = Object.prototype.hasOwnProperty;
    __name(replaceEqualDeep, "replaceEqualDeep");
    __name(shallowEqualObjects, "shallowEqualObjects");
    __name(isPlainArray, "isPlainArray");
    __name(isPlainObject3, "isPlainObject");
    __name(hasObjectPrototype, "hasObjectPrototype");
    __name(sleep, "sleep");
    __name(replaceData, "replaceData");
    __name(addToEnd, "addToEnd");
    __name(addToStart, "addToStart");
    skipToken = Symbol();
    __name(ensureQueryFn, "ensureQueryFn");
    __name(shouldThrowError, "shouldThrowError");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/focusManager.js
var FocusManager, focusManager;
var init_focusManager = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/focusManager.js"() {
    init_subscribable();
    init_utils10();
    FocusManager = class extends Subscribable {
      static {
        __name(this, "FocusManager");
      }
      #focused;
      #cleanup;
      #setup;
      constructor() {
        super();
        this.#setup = (onFocus) => {
          if (!isServer && window.addEventListener) {
            const listener = /* @__PURE__ */ __name(() => onFocus(), "listener");
            window.addEventListener("visibilitychange", listener, false);
            return () => {
              window.removeEventListener("visibilitychange", listener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.#cleanup) {
          this.setEventListener(this.#setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.#cleanup?.();
          this.#cleanup = void 0;
        }
      }
      setEventListener(setup2) {
        this.#setup = setup2;
        this.#cleanup?.();
        this.#cleanup = setup2((focused) => {
          if (typeof focused === "boolean") {
            this.setFocused(focused);
          } else {
            this.onFocus();
          }
        });
      }
      setFocused(focused) {
        const changed = this.#focused !== focused;
        if (changed) {
          this.#focused = focused;
          this.onFocus();
        }
      }
      onFocus() {
        const isFocused = this.isFocused();
        this.listeners.forEach((listener) => {
          listener(isFocused);
        });
      }
      isFocused() {
        if (typeof this.#focused === "boolean") {
          return this.#focused;
        }
        return globalThis.document?.visibilityState !== "hidden";
      }
    };
    focusManager = new FocusManager();
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/thenable.js
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data4) {
    Object.assign(thenable, data4);
    delete thenable.resolve;
    delete thenable.reject;
  }
  __name(finalize, "finalize");
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}
var init_thenable = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/thenable.js"() {
    __name(pendingThenable, "pendingThenable");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/hydration.js
function defaultTransformerFn(data4) {
  return data4;
}
function dehydrateMutation(mutation) {
  return {
    mutationKey: mutation.options.mutationKey,
    state: mutation.state,
    ...mutation.options.scope && { scope: mutation.options.scope },
    ...mutation.meta && { meta: mutation.meta }
  };
}
function dehydrateQuery(query2, serializeData, shouldRedactErrors) {
  return {
    dehydratedAt: Date.now(),
    state: {
      ...query2.state,
      ...query2.state.data !== void 0 && {
        data: serializeData(query2.state.data)
      }
    },
    queryKey: query2.queryKey,
    queryHash: query2.queryHash,
    ...query2.state.status === "pending" && {
      promise: query2.promise?.then(serializeData).catch((error) => {
        if (!shouldRedactErrors(error)) {
          return Promise.reject(error);
        }
        if (true) {
          console.error(
            `A query that was dehydrated as pending ended up rejecting. [${query2.queryHash}]: ${error}; The error will be redacted in production builds`
          );
        }
        return Promise.reject(new Error("redacted"));
      })
    },
    ...query2.meta && { meta: query2.meta }
  };
}
function defaultShouldDehydrateMutation(mutation) {
  return mutation.state.isPaused;
}
function defaultShouldDehydrateQuery(query2) {
  return query2.state.status === "success";
}
function defaultShouldRedactErrors(_) {
  return true;
}
function dehydrate(client, options = {}) {
  const filterMutation = options.shouldDehydrateMutation ?? client.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? defaultShouldDehydrateMutation;
  const mutations = client.getMutationCache().getAll().flatMap(
    (mutation) => filterMutation(mutation) ? [dehydrateMutation(mutation)] : []
  );
  const filterQuery = options.shouldDehydrateQuery ?? client.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? defaultShouldDehydrateQuery;
  const shouldRedactErrors = options.shouldRedactErrors ?? client.getDefaultOptions().dehydrate?.shouldRedactErrors ?? defaultShouldRedactErrors;
  const serializeData = options.serializeData ?? client.getDefaultOptions().dehydrate?.serializeData ?? defaultTransformerFn;
  const queries = client.getQueryCache().getAll().flatMap(
    (query2) => filterQuery(query2) ? [dehydrateQuery(query2, serializeData, shouldRedactErrors)] : []
  );
  return { mutations, queries };
}
var init_hydration = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/hydration.js"() {
    __name(defaultTransformerFn, "defaultTransformerFn");
    __name(dehydrateMutation, "dehydrateMutation");
    __name(dehydrateQuery, "dehydrateQuery");
    __name(defaultShouldDehydrateMutation, "defaultShouldDehydrateMutation");
    __name(defaultShouldDehydrateQuery, "defaultShouldDehydrateQuery");
    __name(defaultShouldRedactErrors, "defaultShouldRedactErrors");
    __name(dehydrate, "dehydrate");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/notifyManager.js
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = /* @__PURE__ */ __name((callback) => {
    callback();
  }, "notifyFn");
  let batchNotifyFn = /* @__PURE__ */ __name((callback) => {
    callback();
  }, "batchNotifyFn");
  let scheduleFn = defaultScheduler;
  const schedule = /* @__PURE__ */ __name((callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  }, "schedule");
  const flush = /* @__PURE__ */ __name(() => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  }, "flush");
  return {
    batch: /* @__PURE__ */ __name((callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    }, "batch"),
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: /* @__PURE__ */ __name((callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    }, "batchCalls"),
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: /* @__PURE__ */ __name((fn) => {
      notifyFn = fn;
    }, "setNotifyFunction"),
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: /* @__PURE__ */ __name((fn) => {
      batchNotifyFn = fn;
    }, "setBatchNotifyFunction"),
    setScheduler: /* @__PURE__ */ __name((fn) => {
      scheduleFn = fn;
    }, "setScheduler")
  };
}
var defaultScheduler, notifyManager;
var init_notifyManager = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/notifyManager.js"() {
    init_timeoutManager();
    defaultScheduler = systemSetTimeoutZero;
    __name(createNotifyManager, "createNotifyManager");
    notifyManager = createNotifyManager();
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/onlineManager.js
var OnlineManager, onlineManager;
var init_onlineManager = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/onlineManager.js"() {
    init_subscribable();
    init_utils10();
    OnlineManager = class extends Subscribable {
      static {
        __name(this, "OnlineManager");
      }
      #online = true;
      #cleanup;
      #setup;
      constructor() {
        super();
        this.#setup = (onOnline) => {
          if (!isServer && window.addEventListener) {
            const onlineListener = /* @__PURE__ */ __name(() => onOnline(true), "onlineListener");
            const offlineListener = /* @__PURE__ */ __name(() => onOnline(false), "offlineListener");
            window.addEventListener("online", onlineListener, false);
            window.addEventListener("offline", offlineListener, false);
            return () => {
              window.removeEventListener("online", onlineListener);
              window.removeEventListener("offline", offlineListener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.#cleanup) {
          this.setEventListener(this.#setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.#cleanup?.();
          this.#cleanup = void 0;
        }
      }
      setEventListener(setup2) {
        this.#setup = setup2;
        this.#cleanup?.();
        this.#cleanup = setup2(this.setOnline.bind(this));
      }
      setOnline(online) {
        const changed = this.#online !== online;
        if (changed) {
          this.#online = online;
          this.listeners.forEach((listener) => {
            listener(online);
          });
        }
      }
      isOnline() {
        return this.#online;
      }
    };
    onlineManager = new OnlineManager();
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/retryer.js
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let continueFn;
  const thenable = pendingThenable();
  const isResolved = /* @__PURE__ */ __name(() => thenable.status !== "pending", "isResolved");
  const cancel = /* @__PURE__ */ __name((cancelOptions) => {
    if (!isResolved()) {
      const error = new CancelledError(cancelOptions);
      reject(error);
      config.onCancel?.(error);
    }
  }, "cancel");
  const cancelRetry = /* @__PURE__ */ __name(() => {
    isRetryCancelled = true;
  }, "cancelRetry");
  const continueRetry = /* @__PURE__ */ __name(() => {
    isRetryCancelled = false;
  }, "continueRetry");
  const canContinue = /* @__PURE__ */ __name(() => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun(), "canContinue");
  const canStart = /* @__PURE__ */ __name(() => canFetch(config.networkMode) && config.canRun(), "canStart");
  const resolve = /* @__PURE__ */ __name((value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.resolve(value);
    }
  }, "resolve");
  const reject = /* @__PURE__ */ __name((value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.reject(value);
    }
  }, "reject");
  const pause = /* @__PURE__ */ __name(() => {
    return new Promise((continueResolve) => {
      continueFn = /* @__PURE__ */ __name((value) => {
        if (isResolved() || canContinue()) {
          continueResolve(value);
        }
      }, "continueFn");
      config.onPause?.();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved()) {
        config.onContinue?.();
      }
    });
  }, "pause");
  const run = /* @__PURE__ */ __name(() => {
    if (isResolved()) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      if (isResolved()) {
        return;
      }
      const retry = config.retry ?? (isServer ? 0 : 3);
      const retryDelay = config.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config.onFail?.(failureCount, error);
      sleep(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  }, "run");
  return {
    promise: thenable,
    status: /* @__PURE__ */ __name(() => thenable.status, "status"),
    cancel,
    continue: /* @__PURE__ */ __name(() => {
      continueFn?.();
      return thenable;
    }, "continue"),
    cancelRetry,
    continueRetry,
    canStart,
    start: /* @__PURE__ */ __name(() => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }, "start")
  };
}
var CancelledError;
var init_retryer = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/retryer.js"() {
    init_focusManager();
    init_onlineManager();
    init_thenable();
    init_utils10();
    __name(defaultRetryDelay, "defaultRetryDelay");
    __name(canFetch, "canFetch");
    CancelledError = class extends Error {
      static {
        __name(this, "CancelledError");
      }
      constructor(options) {
        super("CancelledError");
        this.revert = options?.revert;
        this.silent = options?.silent;
      }
    };
    __name(createRetryer, "createRetryer");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/removable.js
var Removable;
var init_removable = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/removable.js"() {
    init_timeoutManager();
    init_utils10();
    Removable = class {
      static {
        __name(this, "Removable");
      }
      #gcTimeout;
      destroy() {
        this.clearGcTimeout();
      }
      scheduleGc() {
        this.clearGcTimeout();
        if (isValidTimeout(this.gcTime)) {
          this.#gcTimeout = timeoutManager.setTimeout(() => {
            this.optionalRemove();
          }, this.gcTime);
        }
      }
      updateGcTime(newGcTime) {
        this.gcTime = Math.max(
          this.gcTime || 0,
          newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
        );
      }
      clearGcTimeout() {
        if (this.#gcTimeout) {
          timeoutManager.clearTimeout(this.#gcTimeout);
          this.#gcTimeout = void 0;
        }
      }
    };
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/query.js
function fetchState(data4, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data4 === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState(options) {
  const data4 = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data4 !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data: data4,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var Query;
var init_query = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/query.js"() {
    init_utils10();
    init_notifyManager();
    init_retryer();
    init_removable();
    Query = class extends Removable {
      static {
        __name(this, "Query");
      }
      #initialState;
      #revertState;
      #cache;
      #client;
      #retryer;
      #defaultOptions;
      #abortSignalConsumed;
      constructor(config) {
        super();
        this.#abortSignalConsumed = false;
        this.#defaultOptions = config.defaultOptions;
        this.setOptions(config.options);
        this.observers = [];
        this.#client = config.client;
        this.#cache = this.#client.getQueryCache();
        this.queryKey = config.queryKey;
        this.queryHash = config.queryHash;
        this.#initialState = getDefaultState(this.options);
        this.state = config.state ?? this.#initialState;
        this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      get promise() {
        return this.#retryer?.promise;
      }
      setOptions(options) {
        this.options = { ...this.#defaultOptions, ...options };
        this.updateGcTime(this.options.gcTime);
        if (this.state && this.state.data === void 0) {
          const defaultState = getDefaultState(this.options);
          if (defaultState.data !== void 0) {
            this.setData(defaultState.data, {
              updatedAt: defaultState.dataUpdatedAt,
              manual: true
            });
            this.#initialState = defaultState;
          }
        }
      }
      optionalRemove() {
        if (!this.observers.length && this.state.fetchStatus === "idle") {
          this.#cache.remove(this);
        }
      }
      setData(newData, options) {
        const data4 = replaceData(this.state.data, newData, this.options);
        this.#dispatch({
          data: data4,
          type: "success",
          dataUpdatedAt: options?.updatedAt,
          manual: options?.manual
        });
        return data4;
      }
      setState(state2, setStateOptions) {
        this.#dispatch({ type: "setState", state: state2, setStateOptions });
      }
      cancel(options) {
        const promise = this.#retryer?.promise;
        this.#retryer?.cancel(options);
        return promise ? promise.then(noop).catch(noop) : Promise.resolve();
      }
      destroy() {
        super.destroy();
        this.cancel({ silent: true });
      }
      reset() {
        this.destroy();
        this.setState(this.#initialState);
      }
      isActive() {
        return this.observers.some(
          (observer) => resolveEnabled(observer.options.enabled, this) !== false
        );
      }
      isDisabled() {
        if (this.getObserversCount() > 0) {
          return !this.isActive();
        }
        return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
      }
      isStatic() {
        if (this.getObserversCount() > 0) {
          return this.observers.some(
            (observer) => resolveStaleTime(observer.options.staleTime, this) === "static"
          );
        }
        return false;
      }
      isStale() {
        if (this.getObserversCount() > 0) {
          return this.observers.some(
            (observer) => observer.getCurrentResult().isStale
          );
        }
        return this.state.data === void 0 || this.state.isInvalidated;
      }
      isStaleByTime(staleTime = 0) {
        if (this.state.data === void 0) {
          return true;
        }
        if (staleTime === "static") {
          return false;
        }
        if (this.state.isInvalidated) {
          return true;
        }
        return !timeUntilStale(this.state.dataUpdatedAt, staleTime);
      }
      onFocus() {
        const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
        observer?.refetch({ cancelRefetch: false });
        this.#retryer?.continue();
      }
      onOnline() {
        const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
        observer?.refetch({ cancelRefetch: false });
        this.#retryer?.continue();
      }
      addObserver(observer) {
        if (!this.observers.includes(observer)) {
          this.observers.push(observer);
          this.clearGcTimeout();
          this.#cache.notify({ type: "observerAdded", query: this, observer });
        }
      }
      removeObserver(observer) {
        if (this.observers.includes(observer)) {
          this.observers = this.observers.filter((x) => x !== observer);
          if (!this.observers.length) {
            if (this.#retryer) {
              if (this.#abortSignalConsumed) {
                this.#retryer.cancel({ revert: true });
              } else {
                this.#retryer.cancelRetry();
              }
            }
            this.scheduleGc();
          }
          this.#cache.notify({ type: "observerRemoved", query: this, observer });
        }
      }
      getObserversCount() {
        return this.observers.length;
      }
      invalidate() {
        if (!this.state.isInvalidated) {
          this.#dispatch({ type: "invalidate" });
        }
      }
      async fetch(options, fetchOptions) {
        if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
        // re-start the fetch; there is a chance that the query is still in a
        // pending state when that happens
        this.#retryer?.status() !== "rejected") {
          if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {
            this.cancel({ silent: true });
          } else if (this.#retryer) {
            this.#retryer.continueRetry();
            return this.#retryer.promise;
          }
        }
        if (options) {
          this.setOptions(options);
        }
        if (!this.options.queryFn) {
          const observer = this.observers.find((x) => x.options.queryFn);
          if (observer) {
            this.setOptions(observer.options);
          }
        }
        if (true) {
          if (!Array.isArray(this.options.queryKey)) {
            console.error(
              `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`
            );
          }
        }
        const abortController = new AbortController();
        const addSignalProperty = /* @__PURE__ */ __name((object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: /* @__PURE__ */ __name(() => {
              this.#abortSignalConsumed = true;
              return abortController.signal;
            }, "get")
          });
        }, "addSignalProperty");
        const fetchFn = /* @__PURE__ */ __name(() => {
          const queryFn = ensureQueryFn(this.options, fetchOptions);
          const createQueryFnContext = /* @__PURE__ */ __name(() => {
            const queryFnContext2 = {
              client: this.#client,
              queryKey: this.queryKey,
              meta: this.meta
            };
            addSignalProperty(queryFnContext2);
            return queryFnContext2;
          }, "createQueryFnContext");
          const queryFnContext = createQueryFnContext();
          this.#abortSignalConsumed = false;
          if (this.options.persister) {
            return this.options.persister(
              queryFn,
              queryFnContext,
              this
            );
          }
          return queryFn(queryFnContext);
        }, "fetchFn");
        const createFetchContext = /* @__PURE__ */ __name(() => {
          const context2 = {
            fetchOptions,
            options: this.options,
            queryKey: this.queryKey,
            client: this.#client,
            state: this.state,
            fetchFn
          };
          addSignalProperty(context2);
          return context2;
        }, "createFetchContext");
        const context = createFetchContext();
        this.options.behavior?.onFetch(context, this);
        this.#revertState = this.state;
        if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== context.fetchOptions?.meta) {
          this.#dispatch({ type: "fetch", meta: context.fetchOptions?.meta });
        }
        this.#retryer = createRetryer({
          initialPromise: fetchOptions?.initialPromise,
          fn: context.fetchFn,
          onCancel: /* @__PURE__ */ __name((error) => {
            if (error instanceof CancelledError && error.revert) {
              this.setState({
                ...this.#revertState,
                fetchStatus: "idle"
              });
            }
            abortController.abort();
          }, "onCancel"),
          onFail: /* @__PURE__ */ __name((failureCount, error) => {
            this.#dispatch({ type: "failed", failureCount, error });
          }, "onFail"),
          onPause: /* @__PURE__ */ __name(() => {
            this.#dispatch({ type: "pause" });
          }, "onPause"),
          onContinue: /* @__PURE__ */ __name(() => {
            this.#dispatch({ type: "continue" });
          }, "onContinue"),
          retry: context.options.retry,
          retryDelay: context.options.retryDelay,
          networkMode: context.options.networkMode,
          canRun: /* @__PURE__ */ __name(() => true, "canRun")
        });
        try {
          const data4 = await this.#retryer.start();
          if (data4 === void 0) {
            if (true) {
              console.error(
                `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
              );
            }
            throw new Error(`${this.queryHash} data is undefined`);
          }
          this.setData(data4);
          this.#cache.config.onSuccess?.(data4, this);
          this.#cache.config.onSettled?.(
            data4,
            this.state.error,
            this
          );
          return data4;
        } catch (error) {
          if (error instanceof CancelledError) {
            if (error.silent) {
              return this.#retryer.promise;
            } else if (error.revert) {
              if (this.state.data === void 0) {
                throw error;
              }
              return this.state.data;
            }
          }
          this.#dispatch({
            type: "error",
            error
          });
          this.#cache.config.onError?.(
            error,
            this
          );
          this.#cache.config.onSettled?.(
            this.state.data,
            error,
            this
          );
          throw error;
        } finally {
          this.scheduleGc();
        }
      }
      #dispatch(action) {
        const reducer = /* @__PURE__ */ __name((state2) => {
          switch (action.type) {
            case "failed":
              return {
                ...state2,
                fetchFailureCount: action.failureCount,
                fetchFailureReason: action.error
              };
            case "pause":
              return {
                ...state2,
                fetchStatus: "paused"
              };
            case "continue":
              return {
                ...state2,
                fetchStatus: "fetching"
              };
            case "fetch":
              return {
                ...state2,
                ...fetchState(state2.data, this.options),
                fetchMeta: action.meta ?? null
              };
            case "success":
              const newState = {
                ...state2,
                data: action.data,
                dataUpdateCount: state2.dataUpdateCount + 1,
                dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: false,
                status: "success",
                ...!action.manual && {
                  fetchStatus: "idle",
                  fetchFailureCount: 0,
                  fetchFailureReason: null
                }
              };
              this.#revertState = action.manual ? newState : void 0;
              return newState;
            case "error":
              const error = action.error;
              return {
                ...state2,
                error,
                errorUpdateCount: state2.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: state2.fetchFailureCount + 1,
                fetchFailureReason: error,
                fetchStatus: "idle",
                status: "error"
              };
            case "invalidate":
              return {
                ...state2,
                isInvalidated: true
              };
            case "setState":
              return {
                ...state2,
                ...action.state
              };
          }
        }, "reducer");
        this.state = reducer(this.state);
        notifyManager.batch(() => {
          this.observers.forEach((observer) => {
            observer.onQueryUpdate();
          });
          this.#cache.notify({ query: this, type: "updated", action });
        });
      }
    };
    __name(fetchState, "fetchState");
    __name(getDefaultState, "getDefaultState");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/queryObserver.js
function shouldLoadOnMount(query2, options) {
  return resolveEnabled(options.enabled, query2) !== false && query2.state.data === void 0 && !(query2.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query2, options) {
  return shouldLoadOnMount(query2, options) || query2.state.data !== void 0 && shouldFetchOn(query2, options, options.refetchOnMount);
}
function shouldFetchOn(query2, options, field) {
  if (resolveEnabled(options.enabled, query2) !== false && resolveStaleTime(options.staleTime, query2) !== "static") {
    const value = typeof field === "function" ? field(query2) : field;
    return value === "always" || value !== false && isStale(query2, options);
  }
  return false;
}
function shouldFetchOptionally(query2, prevQuery, options, prevOptions) {
  return (query2 !== prevQuery || resolveEnabled(prevOptions.enabled, query2) === false) && (!options.suspense || query2.state.status !== "error") && isStale(query2, options);
}
function isStale(query2, options) {
  return resolveEnabled(options.enabled, query2) !== false && query2.isStaleByTime(resolveStaleTime(options.staleTime, query2));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}
var QueryObserver;
var init_queryObserver = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/queryObserver.js"() {
    init_focusManager();
    init_notifyManager();
    init_query();
    init_subscribable();
    init_thenable();
    init_utils10();
    init_timeoutManager();
    QueryObserver = class extends Subscribable {
      static {
        __name(this, "QueryObserver");
      }
      constructor(client, options) {
        super();
        this.options = options;
        this.#client = client;
        this.#selectError = null;
        this.#currentThenable = pendingThenable();
        this.bindMethods();
        this.setOptions(options);
      }
      #client;
      #currentQuery = void 0;
      #currentQueryInitialState = void 0;
      #currentResult = void 0;
      #currentResultState;
      #currentResultOptions;
      #currentThenable;
      #selectError;
      #selectFn;
      #selectResult;
      // This property keeps track of the last query with defined data.
      // It will be used to pass the previous data and query to the placeholder function between renders.
      #lastQueryWithDefinedData;
      #staleTimeoutId;
      #refetchIntervalId;
      #currentRefetchInterval;
      #trackedProps = /* @__PURE__ */ new Set();
      bindMethods() {
        this.refetch = this.refetch.bind(this);
      }
      onSubscribe() {
        if (this.listeners.size === 1) {
          this.#currentQuery.addObserver(this);
          if (shouldFetchOnMount(this.#currentQuery, this.options)) {
            this.#executeFetch();
          } else {
            this.updateResult();
          }
          this.#updateTimers();
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.destroy();
        }
      }
      shouldFetchOnReconnect() {
        return shouldFetchOn(
          this.#currentQuery,
          this.options,
          this.options.refetchOnReconnect
        );
      }
      shouldFetchOnWindowFocus() {
        return shouldFetchOn(
          this.#currentQuery,
          this.options,
          this.options.refetchOnWindowFocus
        );
      }
      destroy() {
        this.listeners = /* @__PURE__ */ new Set();
        this.#clearStaleTimeout();
        this.#clearRefetchInterval();
        this.#currentQuery.removeObserver(this);
      }
      setOptions(options) {
        const prevOptions = this.options;
        const prevQuery = this.#currentQuery;
        this.options = this.#client.defaultQueryOptions(options);
        if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== "boolean") {
          throw new Error(
            "Expected enabled to be a boolean or a callback that returns a boolean"
          );
        }
        this.#updateQuery();
        this.#currentQuery.setOptions(this.options);
        if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
          this.#client.getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: this.#currentQuery,
            observer: this
          });
        }
        const mounted = this.hasListeners();
        if (mounted && shouldFetchOptionally(
          this.#currentQuery,
          prevQuery,
          this.options,
          prevOptions
        )) {
          this.#executeFetch();
        }
        this.updateResult();
        if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {
          this.#updateStaleTimeout();
        }
        const nextRefetchInterval = this.#computeRefetchInterval();
        if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {
          this.#updateRefetchInterval(nextRefetchInterval);
        }
      }
      getOptimisticResult(options) {
        const query2 = this.#client.getQueryCache().build(this.#client, options);
        const result = this.createResult(query2, options);
        if (shouldAssignObserverCurrentProperties(this, result)) {
          this.#currentResult = result;
          this.#currentResultOptions = this.options;
          this.#currentResultState = this.#currentQuery.state;
        }
        return result;
      }
      getCurrentResult() {
        return this.#currentResult;
      }
      trackResult(result, onPropTracked) {
        return new Proxy(result, {
          get: /* @__PURE__ */ __name((target, key) => {
            this.trackProp(key);
            onPropTracked?.(key);
            if (key === "promise" && !this.options.experimental_prefetchInRender && this.#currentThenable.status === "pending") {
              this.#currentThenable.reject(
                new Error(
                  "experimental_prefetchInRender feature flag is not enabled"
                )
              );
            }
            return Reflect.get(target, key);
          }, "get")
        });
      }
      trackProp(key) {
        this.#trackedProps.add(key);
      }
      getCurrentQuery() {
        return this.#currentQuery;
      }
      refetch({ ...options } = {}) {
        return this.fetch({
          ...options
        });
      }
      fetchOptimistic(options) {
        const defaultedOptions = this.#client.defaultQueryOptions(options);
        const query2 = this.#client.getQueryCache().build(this.#client, defaultedOptions);
        return query2.fetch().then(() => this.createResult(query2, defaultedOptions));
      }
      fetch(fetchOptions) {
        return this.#executeFetch({
          ...fetchOptions,
          cancelRefetch: fetchOptions.cancelRefetch ?? true
        }).then(() => {
          this.updateResult();
          return this.#currentResult;
        });
      }
      #executeFetch(fetchOptions) {
        this.#updateQuery();
        let promise = this.#currentQuery.fetch(
          this.options,
          fetchOptions
        );
        if (!fetchOptions?.throwOnError) {
          promise = promise.catch(noop);
        }
        return promise;
      }
      #updateStaleTimeout() {
        this.#clearStaleTimeout();
        const staleTime = resolveStaleTime(
          this.options.staleTime,
          this.#currentQuery
        );
        if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {
          return;
        }
        const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);
        const timeout = time + 1;
        this.#staleTimeoutId = timeoutManager.setTimeout(() => {
          if (!this.#currentResult.isStale) {
            this.updateResult();
          }
        }, timeout);
      }
      #computeRefetchInterval() {
        return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;
      }
      #updateRefetchInterval(nextInterval) {
        this.#clearRefetchInterval();
        this.#currentRefetchInterval = nextInterval;
        if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {
          return;
        }
        this.#refetchIntervalId = timeoutManager.setInterval(() => {
          if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
            this.#executeFetch();
          }
        }, this.#currentRefetchInterval);
      }
      #updateTimers() {
        this.#updateStaleTimeout();
        this.#updateRefetchInterval(this.#computeRefetchInterval());
      }
      #clearStaleTimeout() {
        if (this.#staleTimeoutId) {
          timeoutManager.clearTimeout(this.#staleTimeoutId);
          this.#staleTimeoutId = void 0;
        }
      }
      #clearRefetchInterval() {
        if (this.#refetchIntervalId) {
          timeoutManager.clearInterval(this.#refetchIntervalId);
          this.#refetchIntervalId = void 0;
        }
      }
      createResult(query2, options) {
        const prevQuery = this.#currentQuery;
        const prevOptions = this.options;
        const prevResult = this.#currentResult;
        const prevResultState = this.#currentResultState;
        const prevResultOptions = this.#currentResultOptions;
        const queryChange = query2 !== prevQuery;
        const queryInitialState = queryChange ? query2.state : this.#currentQueryInitialState;
        const { state: state2 } = query2;
        let newState = { ...state2 };
        let isPlaceholderData = false;
        let data4;
        if (options._optimisticResults) {
          const mounted = this.hasListeners();
          const fetchOnMount = !mounted && shouldFetchOnMount(query2, options);
          const fetchOptionally = mounted && shouldFetchOptionally(query2, prevQuery, options, prevOptions);
          if (fetchOnMount || fetchOptionally) {
            newState = {
              ...newState,
              ...fetchState(state2.data, query2.options)
            };
          }
          if (options._optimisticResults === "isRestoring") {
            newState.fetchStatus = "idle";
          }
        }
        let { error, errorUpdatedAt, status: status2 } = newState;
        data4 = newState.data;
        let skipSelect = false;
        if (options.placeholderData !== void 0 && data4 === void 0 && status2 === "pending") {
          let placeholderData;
          if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {
            placeholderData = prevResult.data;
            skipSelect = true;
          } else {
            placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
              this.#lastQueryWithDefinedData?.state.data,
              this.#lastQueryWithDefinedData
            ) : options.placeholderData;
          }
          if (placeholderData !== void 0) {
            status2 = "success";
            data4 = replaceData(
              prevResult?.data,
              placeholderData,
              options
            );
            isPlaceholderData = true;
          }
        }
        if (options.select && data4 !== void 0 && !skipSelect) {
          if (prevResult && data4 === prevResultState?.data && options.select === this.#selectFn) {
            data4 = this.#selectResult;
          } else {
            try {
              this.#selectFn = options.select;
              data4 = options.select(data4);
              data4 = replaceData(prevResult?.data, data4, options);
              this.#selectResult = data4;
              this.#selectError = null;
            } catch (selectError) {
              this.#selectError = selectError;
            }
          }
        }
        if (this.#selectError) {
          error = this.#selectError;
          data4 = this.#selectResult;
          errorUpdatedAt = Date.now();
          status2 = "error";
        }
        const isFetching = newState.fetchStatus === "fetching";
        const isPending = status2 === "pending";
        const isError = status2 === "error";
        const isLoading = isPending && isFetching;
        const hasData = data4 !== void 0;
        const result = {
          status: status2,
          fetchStatus: newState.fetchStatus,
          isPending,
          isSuccess: status2 === "success",
          isError,
          isInitialLoading: isLoading,
          isLoading,
          data: data4,
          dataUpdatedAt: newState.dataUpdatedAt,
          error,
          errorUpdatedAt,
          failureCount: newState.fetchFailureCount,
          failureReason: newState.fetchFailureReason,
          errorUpdateCount: newState.errorUpdateCount,
          isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
          isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
          isFetching,
          isRefetching: isFetching && !isPending,
          isLoadingError: isError && !hasData,
          isPaused: newState.fetchStatus === "paused",
          isPlaceholderData,
          isRefetchError: isError && hasData,
          isStale: isStale(query2, options),
          refetch: this.refetch,
          promise: this.#currentThenable,
          isEnabled: resolveEnabled(options.enabled, query2) !== false
        };
        const nextResult = result;
        if (this.options.experimental_prefetchInRender) {
          const finalizeThenableIfPossible = /* @__PURE__ */ __name((thenable) => {
            if (nextResult.status === "error") {
              thenable.reject(nextResult.error);
            } else if (nextResult.data !== void 0) {
              thenable.resolve(nextResult.data);
            }
          }, "finalizeThenableIfPossible");
          const recreateThenable = /* @__PURE__ */ __name(() => {
            const pending = this.#currentThenable = nextResult.promise = pendingThenable();
            finalizeThenableIfPossible(pending);
          }, "recreateThenable");
          const prevThenable = this.#currentThenable;
          switch (prevThenable.status) {
            case "pending":
              if (query2.queryHash === prevQuery.queryHash) {
                finalizeThenableIfPossible(prevThenable);
              }
              break;
            case "fulfilled":
              if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
                recreateThenable();
              }
              break;
            case "rejected":
              if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
                recreateThenable();
              }
              break;
          }
        }
        return nextResult;
      }
      updateResult() {
        const prevResult = this.#currentResult;
        const nextResult = this.createResult(this.#currentQuery, this.options);
        this.#currentResultState = this.#currentQuery.state;
        this.#currentResultOptions = this.options;
        if (this.#currentResultState.data !== void 0) {
          this.#lastQueryWithDefinedData = this.#currentQuery;
        }
        if (shallowEqualObjects(nextResult, prevResult)) {
          return;
        }
        this.#currentResult = nextResult;
        const shouldNotifyListeners = /* @__PURE__ */ __name(() => {
          if (!prevResult) {
            return true;
          }
          const { notifyOnChangeProps } = this.options;
          const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
          if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.#trackedProps.size) {
            return true;
          }
          const includedProps = new Set(
            notifyOnChangePropsValue ?? this.#trackedProps
          );
          if (this.options.throwOnError) {
            includedProps.add("error");
          }
          return Object.keys(this.#currentResult).some((key) => {
            const typedKey = key;
            const changed = this.#currentResult[typedKey] !== prevResult[typedKey];
            return changed && includedProps.has(typedKey);
          });
        }, "shouldNotifyListeners");
        this.#notify({ listeners: shouldNotifyListeners() });
      }
      #updateQuery() {
        const query2 = this.#client.getQueryCache().build(this.#client, this.options);
        if (query2 === this.#currentQuery) {
          return;
        }
        const prevQuery = this.#currentQuery;
        this.#currentQuery = query2;
        this.#currentQueryInitialState = query2.state;
        if (this.hasListeners()) {
          prevQuery?.removeObserver(this);
          query2.addObserver(this);
        }
      }
      onQueryUpdate() {
        this.updateResult();
        if (this.hasListeners()) {
          this.#updateTimers();
        }
      }
      #notify(notifyOptions) {
        notifyManager.batch(() => {
          if (notifyOptions.listeners) {
            this.listeners.forEach((listener) => {
              listener(this.#currentResult);
            });
          }
          this.#client.getQueryCache().notify({
            query: this.#currentQuery,
            type: "observerResultsUpdated"
          });
        });
      }
    };
    __name(shouldLoadOnMount, "shouldLoadOnMount");
    __name(shouldFetchOnMount, "shouldFetchOnMount");
    __name(shouldFetchOn, "shouldFetchOn");
    __name(shouldFetchOptionally, "shouldFetchOptionally");
    __name(isStale, "isStale");
    __name(shouldAssignObserverCurrentProperties, "shouldAssignObserverCurrentProperties");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js
function infiniteQueryBehavior(pages) {
  return {
    onFetch: /* @__PURE__ */ __name((context, query2) => {
      const options = context.options;
      const direction = context.fetchOptions?.meta?.fetchMore?.direction;
      const oldPages = context.state.data?.pages || [];
      const oldPageParams = context.state.data?.pageParams || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = /* @__PURE__ */ __name(async () => {
        let cancelled = false;
        const addSignalProperty = /* @__PURE__ */ __name((object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: /* @__PURE__ */ __name(() => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }, "get")
          });
        }, "addSignalProperty");
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = /* @__PURE__ */ __name(async (data4, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data4.pages.length) {
            return Promise.resolve(data4);
          }
          const createQueryFnContext = /* @__PURE__ */ __name(() => {
            const queryFnContext2 = {
              client: context.client,
              queryKey: context.queryKey,
              pageParam: param,
              direction: previous ? "backward" : "forward",
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext2);
            return queryFnContext2;
          }, "createQueryFnContext");
          const queryFnContext = createQueryFnContext();
          const page = await queryFn(queryFnContext);
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data4.pages, page, maxPages),
            pageParams: addTo(data4.pageParams, param, maxPages)
          };
        }, "fetchPage");
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      }, "fetchFn");
      if (context.options.persister) {
        context.fetchFn = () => {
          return context.options.persister?.(
            fetchFn,
            {
              client: context.client,
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query2
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }, "onFetch")
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;
}
var init_infiniteQueryBehavior = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js"() {
    init_utils10();
    __name(infiniteQueryBehavior, "infiniteQueryBehavior");
    __name(getNextPageParam, "getNextPageParam");
    __name(getPreviousPageParam, "getPreviousPageParam");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/mutation.js
function getDefaultState2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var Mutation;
var init_mutation = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/mutation.js"() {
    init_notifyManager();
    init_removable();
    init_retryer();
    Mutation = class extends Removable {
      static {
        __name(this, "Mutation");
      }
      #observers;
      #mutationCache;
      #retryer;
      constructor(config) {
        super();
        this.mutationId = config.mutationId;
        this.#mutationCache = config.mutationCache;
        this.#observers = [];
        this.state = config.state || getDefaultState2();
        this.setOptions(config.options);
        this.scheduleGc();
      }
      setOptions(options) {
        this.options = options;
        this.updateGcTime(this.options.gcTime);
      }
      get meta() {
        return this.options.meta;
      }
      addObserver(observer) {
        if (!this.#observers.includes(observer)) {
          this.#observers.push(observer);
          this.clearGcTimeout();
          this.#mutationCache.notify({
            type: "observerAdded",
            mutation: this,
            observer
          });
        }
      }
      removeObserver(observer) {
        this.#observers = this.#observers.filter((x) => x !== observer);
        this.scheduleGc();
        this.#mutationCache.notify({
          type: "observerRemoved",
          mutation: this,
          observer
        });
      }
      optionalRemove() {
        if (!this.#observers.length) {
          if (this.state.status === "pending") {
            this.scheduleGc();
          } else {
            this.#mutationCache.remove(this);
          }
        }
      }
      continue() {
        return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
        this.execute(this.state.variables);
      }
      async execute(variables) {
        const onContinue = /* @__PURE__ */ __name(() => {
          this.#dispatch({ type: "continue" });
        }, "onContinue");
        this.#retryer = createRetryer({
          fn: /* @__PURE__ */ __name(() => {
            if (!this.options.mutationFn) {
              return Promise.reject(new Error("No mutationFn found"));
            }
            return this.options.mutationFn(variables);
          }, "fn"),
          onFail: /* @__PURE__ */ __name((failureCount, error) => {
            this.#dispatch({ type: "failed", failureCount, error });
          }, "onFail"),
          onPause: /* @__PURE__ */ __name(() => {
            this.#dispatch({ type: "pause" });
          }, "onPause"),
          onContinue,
          retry: this.options.retry ?? 0,
          retryDelay: this.options.retryDelay,
          networkMode: this.options.networkMode,
          canRun: /* @__PURE__ */ __name(() => this.#mutationCache.canRun(this), "canRun")
        });
        const restored = this.state.status === "pending";
        const isPaused = !this.#retryer.canStart();
        try {
          if (restored) {
            onContinue();
          } else {
            this.#dispatch({ type: "pending", variables, isPaused });
            await this.#mutationCache.config.onMutate?.(
              variables,
              this
            );
            const context = await this.options.onMutate?.(variables);
            if (context !== this.state.context) {
              this.#dispatch({
                type: "pending",
                context,
                variables,
                isPaused
              });
            }
          }
          const data4 = await this.#retryer.start();
          await this.#mutationCache.config.onSuccess?.(
            data4,
            variables,
            this.state.context,
            this
          );
          await this.options.onSuccess?.(data4, variables, this.state.context);
          await this.#mutationCache.config.onSettled?.(
            data4,
            null,
            this.state.variables,
            this.state.context,
            this
          );
          await this.options.onSettled?.(data4, null, variables, this.state.context);
          this.#dispatch({ type: "success", data: data4 });
          return data4;
        } catch (error) {
          try {
            await this.#mutationCache.config.onError?.(
              error,
              variables,
              this.state.context,
              this
            );
            await this.options.onError?.(
              error,
              variables,
              this.state.context
            );
            await this.#mutationCache.config.onSettled?.(
              void 0,
              error,
              this.state.variables,
              this.state.context,
              this
            );
            await this.options.onSettled?.(
              void 0,
              error,
              variables,
              this.state.context
            );
            throw error;
          } finally {
            this.#dispatch({ type: "error", error });
          }
        } finally {
          this.#mutationCache.runNext(this);
        }
      }
      #dispatch(action) {
        const reducer = /* @__PURE__ */ __name((state2) => {
          switch (action.type) {
            case "failed":
              return {
                ...state2,
                failureCount: action.failureCount,
                failureReason: action.error
              };
            case "pause":
              return {
                ...state2,
                isPaused: true
              };
            case "continue":
              return {
                ...state2,
                isPaused: false
              };
            case "pending":
              return {
                ...state2,
                context: action.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: action.isPaused,
                status: "pending",
                variables: action.variables,
                submittedAt: Date.now()
              };
            case "success":
              return {
                ...state2,
                data: action.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: false
              };
            case "error":
              return {
                ...state2,
                data: void 0,
                error: action.error,
                failureCount: state2.failureCount + 1,
                failureReason: action.error,
                isPaused: false,
                status: "error"
              };
          }
        }, "reducer");
        this.state = reducer(this.state);
        notifyManager.batch(() => {
          this.#observers.forEach((observer) => {
            observer.onMutationUpdate(action);
          });
          this.#mutationCache.notify({
            mutation: this,
            type: "updated",
            action
          });
        });
      }
    };
    __name(getDefaultState2, "getDefaultState");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/mutationCache.js
function scopeFor(mutation) {
  return mutation.options.scope?.id;
}
var MutationCache;
var init_mutationCache = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/mutationCache.js"() {
    init_notifyManager();
    init_mutation();
    init_utils10();
    init_subscribable();
    MutationCache = class extends Subscribable {
      static {
        __name(this, "MutationCache");
      }
      constructor(config = {}) {
        super();
        this.config = config;
        this.#mutations = /* @__PURE__ */ new Set();
        this.#scopes = /* @__PURE__ */ new Map();
        this.#mutationId = 0;
      }
      #mutations;
      #scopes;
      #mutationId;
      build(client, options, state2) {
        const mutation = new Mutation({
          mutationCache: this,
          mutationId: ++this.#mutationId,
          options: client.defaultMutationOptions(options),
          state: state2
        });
        this.add(mutation);
        return mutation;
      }
      add(mutation) {
        this.#mutations.add(mutation);
        const scope = scopeFor(mutation);
        if (typeof scope === "string") {
          const scopedMutations = this.#scopes.get(scope);
          if (scopedMutations) {
            scopedMutations.push(mutation);
          } else {
            this.#scopes.set(scope, [mutation]);
          }
        }
        this.notify({ type: "added", mutation });
      }
      remove(mutation) {
        if (this.#mutations.delete(mutation)) {
          const scope = scopeFor(mutation);
          if (typeof scope === "string") {
            const scopedMutations = this.#scopes.get(scope);
            if (scopedMutations) {
              if (scopedMutations.length > 1) {
                const index = scopedMutations.indexOf(mutation);
                if (index !== -1) {
                  scopedMutations.splice(index, 1);
                }
              } else if (scopedMutations[0] === mutation) {
                this.#scopes.delete(scope);
              }
            }
          }
        }
        this.notify({ type: "removed", mutation });
      }
      canRun(mutation) {
        const scope = scopeFor(mutation);
        if (typeof scope === "string") {
          const mutationsWithSameScope = this.#scopes.get(scope);
          const firstPendingMutation = mutationsWithSameScope?.find(
            (m) => m.state.status === "pending"
          );
          return !firstPendingMutation || firstPendingMutation === mutation;
        } else {
          return true;
        }
      }
      runNext(mutation) {
        const scope = scopeFor(mutation);
        if (typeof scope === "string") {
          const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);
          return foundMutation?.continue() ?? Promise.resolve();
        } else {
          return Promise.resolve();
        }
      }
      clear() {
        notifyManager.batch(() => {
          this.#mutations.forEach((mutation) => {
            this.notify({ type: "removed", mutation });
          });
          this.#mutations.clear();
          this.#scopes.clear();
        });
      }
      getAll() {
        return Array.from(this.#mutations);
      }
      find(filters) {
        const defaultedFilters = { exact: true, ...filters };
        return this.getAll().find(
          (mutation) => matchMutation(defaultedFilters, mutation)
        );
      }
      findAll(filters = {}) {
        return this.getAll().filter((mutation) => matchMutation(filters, mutation));
      }
      notify(event) {
        notifyManager.batch(() => {
          this.listeners.forEach((listener) => {
            listener(event);
          });
        });
      }
      resumePausedMutations() {
        const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
        return notifyManager.batch(
          () => Promise.all(
            pausedMutations.map((mutation) => mutation.continue().catch(noop))
          )
        );
      }
    };
    __name(scopeFor, "scopeFor");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/queryCache.js
var QueryCache;
var init_queryCache = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/queryCache.js"() {
    init_utils10();
    init_query();
    init_notifyManager();
    init_subscribable();
    QueryCache = class extends Subscribable {
      static {
        __name(this, "QueryCache");
      }
      constructor(config = {}) {
        super();
        this.config = config;
        this.#queries = /* @__PURE__ */ new Map();
      }
      #queries;
      build(client, options, state2) {
        const queryKey = options.queryKey;
        const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
        let query2 = this.get(queryHash);
        if (!query2) {
          query2 = new Query({
            client,
            queryKey,
            queryHash,
            options: client.defaultQueryOptions(options),
            state: state2,
            defaultOptions: client.getQueryDefaults(queryKey)
          });
          this.add(query2);
        }
        return query2;
      }
      add(query2) {
        if (!this.#queries.has(query2.queryHash)) {
          this.#queries.set(query2.queryHash, query2);
          this.notify({
            type: "added",
            query: query2
          });
        }
      }
      remove(query2) {
        const queryInMap = this.#queries.get(query2.queryHash);
        if (queryInMap) {
          query2.destroy();
          if (queryInMap === query2) {
            this.#queries.delete(query2.queryHash);
          }
          this.notify({ type: "removed", query: query2 });
        }
      }
      clear() {
        notifyManager.batch(() => {
          this.getAll().forEach((query2) => {
            this.remove(query2);
          });
        });
      }
      get(queryHash) {
        return this.#queries.get(queryHash);
      }
      getAll() {
        return [...this.#queries.values()];
      }
      find(filters) {
        const defaultedFilters = { exact: true, ...filters };
        return this.getAll().find(
          (query2) => matchQuery(defaultedFilters, query2)
        );
      }
      findAll(filters = {}) {
        const queries = this.getAll();
        return Object.keys(filters).length > 0 ? queries.filter((query2) => matchQuery(filters, query2)) : queries;
      }
      notify(event) {
        notifyManager.batch(() => {
          this.listeners.forEach((listener) => {
            listener(event);
          });
        });
      }
      onFocus() {
        notifyManager.batch(() => {
          this.getAll().forEach((query2) => {
            query2.onFocus();
          });
        });
      }
      onOnline() {
        notifyManager.batch(() => {
          this.getAll().forEach((query2) => {
            query2.onOnline();
          });
        });
      }
    };
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/queryClient.js
var QueryClient;
var init_queryClient = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/queryClient.js"() {
    init_utils10();
    init_queryCache();
    init_mutationCache();
    init_focusManager();
    init_onlineManager();
    init_notifyManager();
    init_infiniteQueryBehavior();
    QueryClient = class {
      static {
        __name(this, "QueryClient");
      }
      #queryCache;
      #mutationCache;
      #defaultOptions;
      #queryDefaults;
      #mutationDefaults;
      #mountCount;
      #unsubscribeFocus;
      #unsubscribeOnline;
      constructor(config = {}) {
        this.#queryCache = config.queryCache || new QueryCache();
        this.#mutationCache = config.mutationCache || new MutationCache();
        this.#defaultOptions = config.defaultOptions || {};
        this.#queryDefaults = /* @__PURE__ */ new Map();
        this.#mutationDefaults = /* @__PURE__ */ new Map();
        this.#mountCount = 0;
      }
      mount() {
        this.#mountCount++;
        if (this.#mountCount !== 1) return;
        this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {
          if (focused) {
            await this.resumePausedMutations();
            this.#queryCache.onFocus();
          }
        });
        this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {
          if (online) {
            await this.resumePausedMutations();
            this.#queryCache.onOnline();
          }
        });
      }
      unmount() {
        this.#mountCount--;
        if (this.#mountCount !== 0) return;
        this.#unsubscribeFocus?.();
        this.#unsubscribeFocus = void 0;
        this.#unsubscribeOnline?.();
        this.#unsubscribeOnline = void 0;
      }
      isFetching(filters) {
        return this.#queryCache.findAll({ ...filters, fetchStatus: "fetching" }).length;
      }
      isMutating(filters) {
        return this.#mutationCache.findAll({ ...filters, status: "pending" }).length;
      }
      /**
       * Imperative (non-reactive) way to retrieve data for a QueryKey.
       * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
       *
       * Hint: Do not use this function inside a component, because it won't receive updates.
       * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
       */
      getQueryData(queryKey) {
        const options = this.defaultQueryOptions({ queryKey });
        return this.#queryCache.get(options.queryHash)?.state.data;
      }
      ensureQueryData(options) {
        const defaultedOptions = this.defaultQueryOptions(options);
        const query2 = this.#queryCache.build(this, defaultedOptions);
        const cachedData = query2.state.data;
        if (cachedData === void 0) {
          return this.fetchQuery(options);
        }
        if (options.revalidateIfStale && query2.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query2))) {
          void this.prefetchQuery(defaultedOptions);
        }
        return Promise.resolve(cachedData);
      }
      getQueriesData(filters) {
        return this.#queryCache.findAll(filters).map(({ queryKey, state: state2 }) => {
          const data4 = state2.data;
          return [queryKey, data4];
        });
      }
      setQueryData(queryKey, updater, options) {
        const defaultedOptions = this.defaultQueryOptions({ queryKey });
        const query2 = this.#queryCache.get(
          defaultedOptions.queryHash
        );
        const prevData = query2?.state.data;
        const data4 = functionalUpdate(updater, prevData);
        if (data4 === void 0) {
          return void 0;
        }
        return this.#queryCache.build(this, defaultedOptions).setData(data4, { ...options, manual: true });
      }
      setQueriesData(filters, updater, options) {
        return notifyManager.batch(
          () => this.#queryCache.findAll(filters).map(({ queryKey }) => [
            queryKey,
            this.setQueryData(queryKey, updater, options)
          ])
        );
      }
      getQueryState(queryKey) {
        const options = this.defaultQueryOptions({ queryKey });
        return this.#queryCache.get(
          options.queryHash
        )?.state;
      }
      removeQueries(filters) {
        const queryCache = this.#queryCache;
        notifyManager.batch(() => {
          queryCache.findAll(filters).forEach((query2) => {
            queryCache.remove(query2);
          });
        });
      }
      resetQueries(filters, options) {
        const queryCache = this.#queryCache;
        return notifyManager.batch(() => {
          queryCache.findAll(filters).forEach((query2) => {
            query2.reset();
          });
          return this.refetchQueries(
            {
              type: "active",
              ...filters
            },
            options
          );
        });
      }
      cancelQueries(filters, cancelOptions = {}) {
        const defaultedCancelOptions = { revert: true, ...cancelOptions };
        const promises = notifyManager.batch(
          () => this.#queryCache.findAll(filters).map((query2) => query2.cancel(defaultedCancelOptions))
        );
        return Promise.all(promises).then(noop).catch(noop);
      }
      invalidateQueries(filters, options = {}) {
        return notifyManager.batch(() => {
          this.#queryCache.findAll(filters).forEach((query2) => {
            query2.invalidate();
          });
          if (filters?.refetchType === "none") {
            return Promise.resolve();
          }
          return this.refetchQueries(
            {
              ...filters,
              type: filters?.refetchType ?? filters?.type ?? "active"
            },
            options
          );
        });
      }
      refetchQueries(filters, options = {}) {
        const fetchOptions = {
          ...options,
          cancelRefetch: options.cancelRefetch ?? true
        };
        const promises = notifyManager.batch(
          () => this.#queryCache.findAll(filters).filter((query2) => !query2.isDisabled() && !query2.isStatic()).map((query2) => {
            let promise = query2.fetch(void 0, fetchOptions);
            if (!fetchOptions.throwOnError) {
              promise = promise.catch(noop);
            }
            return query2.state.fetchStatus === "paused" ? Promise.resolve() : promise;
          })
        );
        return Promise.all(promises).then(noop);
      }
      fetchQuery(options) {
        const defaultedOptions = this.defaultQueryOptions(options);
        if (defaultedOptions.retry === void 0) {
          defaultedOptions.retry = false;
        }
        const query2 = this.#queryCache.build(this, defaultedOptions);
        return query2.isStaleByTime(
          resolveStaleTime(defaultedOptions.staleTime, query2)
        ) ? query2.fetch(defaultedOptions) : Promise.resolve(query2.state.data);
      }
      prefetchQuery(options) {
        return this.fetchQuery(options).then(noop).catch(noop);
      }
      fetchInfiniteQuery(options) {
        options.behavior = infiniteQueryBehavior(options.pages);
        return this.fetchQuery(options);
      }
      prefetchInfiniteQuery(options) {
        return this.fetchInfiniteQuery(options).then(noop).catch(noop);
      }
      ensureInfiniteQueryData(options) {
        options.behavior = infiniteQueryBehavior(options.pages);
        return this.ensureQueryData(options);
      }
      resumePausedMutations() {
        if (onlineManager.isOnline()) {
          return this.#mutationCache.resumePausedMutations();
        }
        return Promise.resolve();
      }
      getQueryCache() {
        return this.#queryCache;
      }
      getMutationCache() {
        return this.#mutationCache;
      }
      getDefaultOptions() {
        return this.#defaultOptions;
      }
      setDefaultOptions(options) {
        this.#defaultOptions = options;
      }
      setQueryDefaults(queryKey, options) {
        this.#queryDefaults.set(hashKey(queryKey), {
          queryKey,
          defaultOptions: options
        });
      }
      getQueryDefaults(queryKey) {
        const defaults = [...this.#queryDefaults.values()];
        const result = {};
        defaults.forEach((queryDefault) => {
          if (partialMatchKey(queryKey, queryDefault.queryKey)) {
            Object.assign(result, queryDefault.defaultOptions);
          }
        });
        return result;
      }
      setMutationDefaults(mutationKey, options) {
        this.#mutationDefaults.set(hashKey(mutationKey), {
          mutationKey,
          defaultOptions: options
        });
      }
      getMutationDefaults(mutationKey) {
        const defaults = [...this.#mutationDefaults.values()];
        const result = {};
        defaults.forEach((queryDefault) => {
          if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
            Object.assign(result, queryDefault.defaultOptions);
          }
        });
        return result;
      }
      defaultQueryOptions(options) {
        if (options._defaulted) {
          return options;
        }
        const defaultedOptions = {
          ...this.#defaultOptions.queries,
          ...this.getQueryDefaults(options.queryKey),
          ...options,
          _defaulted: true
        };
        if (!defaultedOptions.queryHash) {
          defaultedOptions.queryHash = hashQueryKeyByOptions(
            defaultedOptions.queryKey,
            defaultedOptions
          );
        }
        if (defaultedOptions.refetchOnReconnect === void 0) {
          defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
        }
        if (defaultedOptions.throwOnError === void 0) {
          defaultedOptions.throwOnError = !!defaultedOptions.suspense;
        }
        if (!defaultedOptions.networkMode && defaultedOptions.persister) {
          defaultedOptions.networkMode = "offlineFirst";
        }
        if (defaultedOptions.queryFn === skipToken) {
          defaultedOptions.enabled = false;
        }
        return defaultedOptions;
      }
      defaultMutationOptions(options) {
        if (options?._defaulted) {
          return options;
        }
        return {
          ...this.#defaultOptions.mutations,
          ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),
          ...options,
          _defaulted: true
        };
      }
      clear() {
        this.#queryCache.clear();
        this.#mutationCache.clear();
      }
    };
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/types.js
var dataTagSymbol, dataTagErrorSymbol, unsetMarker;
var init_types2 = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/types.js"() {
    dataTagSymbol = Symbol("dataTagSymbol");
    dataTagErrorSymbol = Symbol("dataTagErrorSymbol");
    unsetMarker = Symbol("unsetMarker");
  }
});

// node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/index.js
var init_modern = __esm({
  "node_modules/.pnpm/@tanstack+query-core@5.87.4/node_modules/@tanstack/query-core/build/modern/index.js"() {
    init_hydration();
    init_notifyManager();
    init_queryClient();
    init_queryObserver();
    init_utils10();
    init_types2();
  }
});

// .dev/build/sky.examples.platform.web/web/server/chunks/chunk-sZbIegKP.js
async function afterInitPage() {
  this.initial.dehydratedState = dehydrate(this.queryClient);
}
async function initPage(parameters) {
  const store = {};
  const { ns, theme } = parameters;
  const forwarded = this.headers["x-forwarded-for"];
  const ip = forwarded ? forwarded.split(/, /)[0] : this.headers["x-remote-address"] ?? "127.0.0.1";
  const queryClient2 = new QueryClient();
  const lng = this.lng;
  const lngPrefix = this.lngPrefix;
  Console$1.log(`ip ${ip} -> ${this.urlOriginal}`);
  const dehydratedState = dehydrate(queryClient2);
  this.queryClient = queryClient2;
  this.initial = {
    store,
    dehydratedState,
    ip,
    ns
    // resources,
  };
  return {
    domain: this.domain,
    lng,
    lngPrefix,
    // t,
    queryClient: queryClient2,
    ip
  };
}
function data2(init2) {
  const handler = /* @__PURE__ */ __name(async (pageContext) => {
    if (pageContext.isClientSideNavigation) {
      return null;
    }
    pageContext.init = initPage;
    const result = await init2(pageContext);
    await afterInitPage.call(pageContext);
    pageContext.initial.title = result.title;
    const data22 = result.data;
    delete result.data;
    Object.assign(pageContext, result);
    return data22;
  }, "handler");
  handler.init = init2;
  return handler;
}
var init_chunk_sZbIegKP = __esm({
  async ".dev/build/sky.examples.platform.web/web/server/chunks/chunk-sZbIegKP.js"() {
    "use strict";
    init_modern();
    await init_chunk_D8IZrfLU();
    __name(afterInitPage, "afterInitPage");
    __name(initPage, "initPage");
    __name(data2, "data");
  }
});

// .dev/build/sky.examples.platform.web/web/server/entries/pages_old_error.mjs
var pages_old_error_exports = {};
__export(pages_old_error_exports, {
  configValuesSerialized: () => configValuesSerialized2
});
function Page() {
  const pageContext = usePageContext();
  let { abortReason } = pageContext;
  if (!abortReason) {
    abortReason = pageContext.is404 ? "Page not found." : "Something went wrong.";
  }
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Center, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("p", { style: { fontSize: "1.3em" }, children: abortReason }) });
}
function Center({ children }) {
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    "div",
    {
      style: {
        height: "calc(100vh - 100px)",
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      },
      children
    }
  );
}
var import_jsx_runtime4, import_react7, import_classnames3, import22, ErrorPageData, import32, configValuesSerialized2;
var init_pages_old_error = __esm({
  async ".dev/build/sky.examples.platform.web/web/server/entries/pages_old_error.mjs"() {
    "use strict";
    await init_chunk_D8IZrfLU();
    import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
    init_chunk_CQSiE3_x();
    await init_chunk_sZbIegKP();
    init_index_web_only();
    init_runtime2();
    import_react7 = __toESM(require_react(), 1);
    import_classnames3 = __toESM(require_classnames(), 1);
    __name(Page, "Page");
    __name(Center, "Center");
    import22 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      Page
    }, Symbol.toStringTag, { value: "Module" }));
    ErrorPageData = data2(async (pageContext) => {
      await pageContext.init({
        ns: []
      });
      return {
        title: pageContext.is404 ? "Not Found" : "Error",
        description: ""
      };
    });
    import32 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: ErrorPageData
    }, Symbol.toStringTag, { value: "Module" }));
    configValuesSerialized2 = {
      ["isClientRuntimeLoaded"]: {
        type: "computed",
        definedAtData: null,
        valueSerialized: {
          type: "js-serialized",
          value: true
        }
      },
      ["onRenderHtml"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/renderer/+onRenderHtml.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import1
        }
      },
      ["Page"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/_error/+Page.tsx", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import22
        }
      },
      ["passToClient"]: {
        type: "cumulative",
        definedAtData: [{ "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "passToClient"] }],
        valueSerialized: [{
          type: "js-serialized",
          value: ["errorWhileRendering", "is404", "domain", "lng", "lngPrefix", "urlLogical", "theme", "initial"]
        }]
      },
      ["data"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/_error/+data.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import32
        }
      }
    };
  }
});

// .dev/build/sky.examples.platform.web/web/server/entries/pages_old_about.mjs
var pages_old_about_exports = {};
__export(pages_old_about_exports, {
  configValuesSerialized: () => configValuesSerialized3
});
function AboutPage() {
  const b = "AboutPage";
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(PageLayout, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: cx3`AboutPage`, children: [
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("h1", { className: cx3`${b}-title`, children: "About" }),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: cx3`${b}-text`, children: "Example of using Sky." })
  ] }) });
}
function About() {
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(AboutPage, {});
}
async function data3() {
  return "About";
}
var import_jsx_runtime5, import_react8, import_classnames4, container2, fluid2, row2, col2, spin2, ping2, pulse2, bounce2, styles2, cx3, import23, import33, configValuesSerialized3;
var init_pages_old_about = __esm({
  async ".dev/build/sky.examples.platform.web/web/server/entries/pages_old_about.mjs"() {
    "use strict";
    await init_chunk_D8IZrfLU();
    import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
    init_index_web_only();
    init_runtime2();
    import_react8 = __toESM(require_react(), 1);
    import_classnames4 = __toESM(require_classnames(), 1);
    container2 = "AboutPage-container";
    fluid2 = "AboutPage-fluid";
    row2 = "AboutPage-row";
    col2 = "AboutPage-col";
    spin2 = "AboutPage-spin";
    ping2 = "AboutPage-ping";
    pulse2 = "AboutPage-pulse";
    bounce2 = "AboutPage-bounce";
    styles2 = {
      "theme-dark": "AboutPage-theme-dark",
      container: container2,
      fluid: fluid2,
      row: row2,
      col: col2,
      spin: spin2,
      ping: ping2,
      pulse: pulse2,
      bounce: bounce2
    };
    cx3 = cn(styles2);
    __name(AboutPage, "AboutPage");
    __name(About, "About");
    import23 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: About
    }, Symbol.toStringTag, { value: "Module" }));
    __name(data3, "data");
    import33 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: data3
    }, Symbol.toStringTag, { value: "Module" }));
    configValuesSerialized3 = {
      ["isClientRuntimeLoaded"]: {
        type: "computed",
        definedAtData: null,
        valueSerialized: {
          type: "js-serialized",
          value: true
        }
      },
      ["onRenderHtml"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/renderer/+onRenderHtml.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import1
        }
      },
      ["Page"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/about/+Page.tsx", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import23
        }
      },
      ["passToClient"]: {
        type: "cumulative",
        definedAtData: [{ "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "passToClient"] }],
        valueSerialized: [{
          type: "js-serialized",
          value: ["errorWhileRendering", "is404", "domain", "lng", "lngPrefix", "urlLogical", "theme", "initial"]
        }]
      },
      ["data"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/about/+data.tsx", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import33
        }
      }
    };
  }
});

// .dev/build/sky.examples.platform.web/web/server/entries/pages_old_data-fetching_-id.mjs
var pages_old_data_fetching_id_exports = {};
__export(pages_old_data_fetching_id_exports, {
  configValuesSerialized: () => configValuesSerialized4
});
function minimize(movie) {
  const { id, title: title2, release_date, director, producer } = movie;
  movie = { id, title: title2, release_date, director, producer };
  return movie;
}
var import_jsx_runtime6, import_react9, import_classnames5, import24, StarWarsMovieData, import34, configValuesSerialized4;
var init_pages_old_data_fetching_id = __esm({
  async ".dev/build/sky.examples.platform.web/web/server/entries/pages_old_data-fetching_-id.mjs"() {
    "use strict";
    await init_chunk_D8IZrfLU();
    await init_chunk_sZbIegKP();
    init_chunk_BLGzEfE8();
    import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
    init_index_web_only();
    init_runtime2();
    import_react9 = __toESM(require_react(), 1);
    import_classnames5 = __toESM(require_classnames(), 1);
    init_server();
    import24 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null
    }, Symbol.toStringTag, { value: "Module" }));
    StarWarsMovieData = data2(async (pageContext) => {
      await pageContext.init({
        ns: []
      });
      const movieData = await onFetchStarWarsMovie(pageContext.routeParams.id);
      const movie = minimize(movieData);
      return {
        title: movie.title,
        description: "",
        data: {
          movie
        }
      };
    });
    __name(minimize, "minimize");
    import34 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: StarWarsMovieData
    }, Symbol.toStringTag, { value: "Module" }));
    configValuesSerialized4 = {
      ["isClientRuntimeLoaded"]: {
        type: "computed",
        definedAtData: null,
        valueSerialized: {
          type: "js-serialized",
          value: true
        }
      },
      ["onRenderHtml"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/renderer/+onRenderHtml.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import1
        }
      },
      ["Page"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/data-fetching/@id/+Page.tsx", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import24
        }
      },
      ["passToClient"]: {
        type: "cumulative",
        definedAtData: [{ "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "passToClient"] }],
        valueSerialized: [{
          type: "js-serialized",
          value: ["errorWhileRendering", "is404", "domain", "lng", "lngPrefix", "urlLogical", "theme", "initial"]
        }]
      },
      ["data"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/data-fetching/@id/+data.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import34
        }
      }
    };
  }
});

// .dev/build/sky.examples.platform.web/web/server/entries/pages_old_data-fetching_index.mjs
var pages_old_data_fetching_index_exports = {};
__export(pages_old_data_fetching_index_exports, {
  configValuesSerialized: () => configValuesSerialized5
});
function minimize2(movies) {
  return movies.map((movie) => {
    const { title: title2, release_date, id } = movie;
    return { title: title2, release_date, id };
  });
}
var import_jsx_runtime7, import_react10, import_classnames6, import25, _data, import35, configValuesSerialized5;
var init_pages_old_data_fetching_index = __esm({
  async ".dev/build/sky.examples.platform.web/web/server/entries/pages_old_data-fetching_index.mjs"() {
    "use strict";
    await init_chunk_D8IZrfLU();
    await init_chunk_sZbIegKP();
    init_chunk_VZQ4tFqC();
    import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
    init_index_web_only();
    init_runtime2();
    import_react10 = __toESM(require_react(), 1);
    import_classnames6 = __toESM(require_classnames(), 1);
    init_server();
    import25 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null
    }, Symbol.toStringTag, { value: "Module" }));
    _data = data2(async (pageContext) => {
      await pageContext.init({
        ns: []
      });
      await idle(700 .asMilliseconds);
      const moviesData = await onInitStarWars();
      const movies = minimize2(moviesData);
      return {
        title: `${movies.length} Star Wars Movies`,
        description: "",
        data: {
          movies
        }
      };
    });
    __name(minimize2, "minimize");
    import35 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: _data
    }, Symbol.toStringTag, { value: "Module" }));
    configValuesSerialized5 = {
      ["isClientRuntimeLoaded"]: {
        type: "computed",
        definedAtData: null,
        valueSerialized: {
          type: "js-serialized",
          value: true
        }
      },
      ["onRenderHtml"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/renderer/+onRenderHtml.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import1
        }
      },
      ["Page"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/data-fetching/index/+Page.tsx", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import25
        }
      },
      ["passToClient"]: {
        type: "cumulative",
        definedAtData: [{ "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "passToClient"] }],
        valueSerialized: [{
          type: "js-serialized",
          value: ["errorWhileRendering", "is404", "domain", "lng", "lngPrefix", "urlLogical", "theme", "initial"]
        }]
      },
      ["data"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/data-fetching/index/+data.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import35
        }
      }
    };
  }
});

// node_modules/.pnpm/void-elements@3.1.0/node_modules/void-elements/index.js
var require_void_elements = __commonJS({
  "node_modules/.pnpm/void-elements@3.1.0/node_modules/void-elements/index.js"(exports, module2) {
    module2.exports = {
      "area": true,
      "base": true,
      "br": true,
      "col": true,
      "embed": true,
      "hr": true,
      "img": true,
      "input": true,
      "link": true,
      "meta": true,
      "param": true,
      "source": true,
      "track": true,
      "wbr": true
    };
  }
});

// node_modules/.pnpm/html-parse-stringify@3.0.1/node_modules/html-parse-stringify/dist/html-parse-stringify.module.js
var import_void_elements;
var init_html_parse_stringify_module = __esm({
  "node_modules/.pnpm/html-parse-stringify@3.0.1/node_modules/html-parse-stringify/dist/html-parse-stringify.module.js"() {
    import_void_elements = __toESM(require_void_elements());
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/utils.js
var warn, alreadyWarned, warnOnce, loadedClb, loadNamespaces, loadLanguages, hasLoadedNamespace, isString2, isObject5;
var init_utils11 = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/utils.js"() {
    warn = /* @__PURE__ */ __name((i18n, code, msg, rest) => {
      const args = [msg, {
        code,
        ...rest || {}
      }];
      if (i18n?.services?.logger?.forward) {
        return i18n.services.logger.forward(args, "warn", "react-i18next::", true);
      }
      if (isString2(args[0])) args[0] = `react-i18next:: ${args[0]}`;
      if (i18n?.services?.logger?.warn) {
        i18n.services.logger.warn(...args);
      } else if (console?.warn) {
        console.warn(...args);
      }
    }, "warn");
    alreadyWarned = {};
    warnOnce = /* @__PURE__ */ __name((i18n, code, msg, rest) => {
      if (isString2(msg) && alreadyWarned[msg]) return;
      if (isString2(msg)) alreadyWarned[msg] = /* @__PURE__ */ new Date();
      warn(i18n, code, msg, rest);
    }, "warnOnce");
    loadedClb = /* @__PURE__ */ __name((i18n, cb) => () => {
      if (i18n.isInitialized) {
        cb();
      } else {
        const initialized = /* @__PURE__ */ __name(() => {
          setTimeout(() => {
            i18n.off("initialized", initialized);
          }, 0);
          cb();
        }, "initialized");
        i18n.on("initialized", initialized);
      }
    }, "loadedClb");
    loadNamespaces = /* @__PURE__ */ __name((i18n, ns, cb) => {
      i18n.loadNamespaces(ns, loadedClb(i18n, cb));
    }, "loadNamespaces");
    loadLanguages = /* @__PURE__ */ __name((i18n, lng, ns, cb) => {
      if (isString2(ns)) ns = [ns];
      if (i18n.options.preload && i18n.options.preload.indexOf(lng) > -1) return loadNamespaces(i18n, ns, cb);
      ns.forEach((n) => {
        if (i18n.options.ns.indexOf(n) < 0) i18n.options.ns.push(n);
      });
      i18n.loadLanguages(lng, loadedClb(i18n, cb));
    }, "loadLanguages");
    hasLoadedNamespace = /* @__PURE__ */ __name((ns, i18n, options = {}) => {
      if (!i18n.languages || !i18n.languages.length) {
        warnOnce(i18n, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
          languages: i18n.languages
        });
        return true;
      }
      return i18n.hasLoadedNamespace(ns, {
        lng: options.lng,
        precheck: /* @__PURE__ */ __name((i18nInstance2, loadNotPending) => {
          if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns)) return false;
        }, "precheck")
      });
    }, "hasLoadedNamespace");
    isString2 = /* @__PURE__ */ __name((obj) => typeof obj === "string", "isString");
    isObject5 = /* @__PURE__ */ __name((obj) => typeof obj === "object" && obj !== null, "isObject");
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/unescape.js
var matchHtmlEntity, htmlEntities, unescapeHtmlEntity, unescape;
var init_unescape = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/unescape.js"() {
    matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
    htmlEntities = {
      "&amp;": "&",
      "&#38;": "&",
      "&lt;": "<",
      "&#60;": "<",
      "&gt;": ">",
      "&#62;": ">",
      "&apos;": "'",
      "&#39;": "'",
      "&quot;": '"',
      "&#34;": '"',
      "&nbsp;": " ",
      "&#160;": " ",
      "&copy;": "\xA9",
      "&#169;": "\xA9",
      "&reg;": "\xAE",
      "&#174;": "\xAE",
      "&hellip;": "\u2026",
      "&#8230;": "\u2026",
      "&#x2F;": "/",
      "&#47;": "/"
    };
    unescapeHtmlEntity = /* @__PURE__ */ __name((m) => htmlEntities[m], "unescapeHtmlEntity");
    unescape = /* @__PURE__ */ __name((text) => text.replace(matchHtmlEntity, unescapeHtmlEntity), "unescape");
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/defaults.js
var defaultOptions, getDefaults;
var init_defaults = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/defaults.js"() {
    init_unescape();
    defaultOptions = {
      bindI18n: "languageChanged",
      bindI18nStore: "",
      transEmptyNodeValue: "",
      transSupportBasicHtmlNodes: true,
      transWrapTextNodes: "",
      transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
      useSuspense: true,
      unescape
    };
    getDefaults = /* @__PURE__ */ __name(() => defaultOptions, "getDefaults");
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/i18nInstance.js
var i18nInstance, getI18n;
var init_i18nInstance = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/i18nInstance.js"() {
    getI18n = /* @__PURE__ */ __name(() => i18nInstance, "getI18n");
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/TransWithoutContext.js
var import_react11;
var init_TransWithoutContext = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/TransWithoutContext.js"() {
    import_react11 = __toESM(require_react(), 1);
    init_html_parse_stringify_module();
    init_utils11();
    init_defaults();
    init_i18nInstance();
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/initReactI18next.js
var init_initReactI18next = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/initReactI18next.js"() {
    init_defaults();
    init_i18nInstance();
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/context.js
var import_react12, I18nContext, ReportNamespaces;
var init_context = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/context.js"() {
    import_react12 = __toESM(require_react(), 1);
    init_defaults();
    init_i18nInstance();
    init_initReactI18next();
    I18nContext = (0, import_react12.createContext)();
    ReportNamespaces = class {
      static {
        __name(this, "ReportNamespaces");
      }
      constructor() {
        this.usedNamespaces = {};
      }
      addUsedNamespaces(namespaces) {
        namespaces.forEach((ns) => {
          if (!this.usedNamespaces[ns]) this.usedNamespaces[ns] = true;
        });
      }
      getUsedNamespaces() {
        return Object.keys(this.usedNamespaces);
      }
    };
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/Trans.js
var import_react13;
var init_Trans = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/Trans.js"() {
    import_react13 = __toESM(require_react(), 1);
    init_TransWithoutContext();
    init_context();
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/useTranslation.js
var import_react14, usePrevious, alwaysNewT, useMemoizedT, useTranslation;
var init_useTranslation = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/useTranslation.js"() {
    import_react14 = __toESM(require_react(), 1);
    init_context();
    init_utils11();
    usePrevious = /* @__PURE__ */ __name((value, ignore) => {
      const ref = (0, import_react14.useRef)();
      (0, import_react14.useEffect)(() => {
        ref.current = ignore ? ref.current : value;
      }, [value, ignore]);
      return ref.current;
    }, "usePrevious");
    alwaysNewT = /* @__PURE__ */ __name((i18n, language, namespace2, keyPrefix) => i18n.getFixedT(language, namespace2, keyPrefix), "alwaysNewT");
    useMemoizedT = /* @__PURE__ */ __name((i18n, language, namespace2, keyPrefix) => (0, import_react14.useCallback)(alwaysNewT(i18n, language, namespace2, keyPrefix), [i18n, language, namespace2, keyPrefix]), "useMemoizedT");
    useTranslation = /* @__PURE__ */ __name((ns, props = {}) => {
      const {
        i18n: i18nFromProps
      } = props;
      const {
        i18n: i18nFromContext,
        defaultNS: defaultNSFromContext
      } = (0, import_react14.useContext)(I18nContext) || {};
      const i18n = i18nFromProps || i18nFromContext || getI18n();
      if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
      if (!i18n) {
        warnOnce(i18n, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
        const notReadyT = /* @__PURE__ */ __name((k, optsOrDefaultValue) => {
          if (isString2(optsOrDefaultValue)) return optsOrDefaultValue;
          if (isObject5(optsOrDefaultValue) && isString2(optsOrDefaultValue.defaultValue)) return optsOrDefaultValue.defaultValue;
          return Array.isArray(k) ? k[k.length - 1] : k;
        }, "notReadyT");
        const retNotReady = [notReadyT, {}, false];
        retNotReady.t = notReadyT;
        retNotReady.i18n = {};
        retNotReady.ready = false;
        return retNotReady;
      }
      if (i18n.options.react?.wait) warnOnce(i18n, "DEPRECATED_OPTION", "useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
      const i18nOptions = {
        ...getDefaults(),
        ...i18n.options.react,
        ...props
      };
      const {
        useSuspense,
        keyPrefix
      } = i18nOptions;
      let namespaces = ns || defaultNSFromContext || i18n.options?.defaultNS;
      namespaces = isString2(namespaces) ? [namespaces] : namespaces || ["translation"];
      i18n.reportNamespaces.addUsedNamespaces?.(namespaces);
      const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n) => hasLoadedNamespace(n, i18n, i18nOptions));
      const memoGetT = useMemoizedT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
      const getT = /* @__PURE__ */ __name(() => memoGetT, "getT");
      const getNewT = /* @__PURE__ */ __name(() => alwaysNewT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix), "getNewT");
      const [t, setT] = (0, import_react14.useState)(getT);
      let joinedNS = namespaces.join();
      if (props.lng) joinedNS = `${props.lng}${joinedNS}`;
      const previousJoinedNS = usePrevious(joinedNS);
      const isMounted = (0, import_react14.useRef)(true);
      (0, import_react14.useEffect)(() => {
        const {
          bindI18n,
          bindI18nStore
        } = i18nOptions;
        isMounted.current = true;
        if (!ready && !useSuspense) {
          if (props.lng) {
            loadLanguages(i18n, props.lng, namespaces, () => {
              if (isMounted.current) setT(getNewT);
            });
          } else {
            loadNamespaces(i18n, namespaces, () => {
              if (isMounted.current) setT(getNewT);
            });
          }
        }
        if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
          setT(getNewT);
        }
        const boundReset = /* @__PURE__ */ __name(() => {
          if (isMounted.current) setT(getNewT);
        }, "boundReset");
        if (bindI18n) i18n?.on(bindI18n, boundReset);
        if (bindI18nStore) i18n?.store.on(bindI18nStore, boundReset);
        return () => {
          isMounted.current = false;
          if (i18n && bindI18n) bindI18n?.split(" ").forEach((e2) => i18n.off(e2, boundReset));
          if (bindI18nStore && i18n) bindI18nStore.split(" ").forEach((e2) => i18n.store.off(e2, boundReset));
        };
      }, [i18n, joinedNS]);
      (0, import_react14.useEffect)(() => {
        if (isMounted.current && ready) {
          setT(getT);
        }
      }, [i18n, keyPrefix, ready]);
      const ret = [t, i18n, ready];
      ret.t = t;
      ret.i18n = i18n;
      ret.ready = ready;
      if (ready) return ret;
      if (!ready && !useSuspense) return ret;
      throw new Promise((resolve) => {
        if (props.lng) {
          loadLanguages(i18n, props.lng, namespaces, () => resolve());
        } else {
          loadNamespaces(i18n, namespaces, () => resolve());
        }
      });
    }, "useTranslation");
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/withTranslation.js
var import_react15;
var init_withTranslation = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/withTranslation.js"() {
    import_react15 = __toESM(require_react(), 1);
    init_useTranslation();
    init_utils11();
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/Translation.js
var init_Translation = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/Translation.js"() {
    init_useTranslation();
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/I18nextProvider.js
var import_react16;
var init_I18nextProvider = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/I18nextProvider.js"() {
    import_react16 = __toESM(require_react(), 1);
    init_context();
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/useSSR.js
var import_react17;
var init_useSSR = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/useSSR.js"() {
    import_react17 = __toESM(require_react(), 1);
    init_context();
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/withSSR.js
var import_react18;
var init_withSSR = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/withSSR.js"() {
    import_react18 = __toESM(require_react(), 1);
    init_useSSR();
    init_context();
    init_utils11();
  }
});

// node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/index.js
var init_es = __esm({
  "node_modules/.pnpm/react-i18next@15.7.3_i18next@25.5.2_typescript@5.9.2__react-dom@19.1.1_react@19.1.1__re_aa16d168a1ff094344323ce4e36f57a8/node_modules/react-i18next/dist/es/index.js"() {
    init_Trans();
    init_TransWithoutContext();
    init_useTranslation();
    init_withTranslation();
    init_Translation();
    init_I18nextProvider();
    init_withSSR();
    init_useSSR();
    init_initReactI18next();
    init_defaults();
    init_i18nInstance();
    init_context();
  }
});

// .dev/build/sky.examples.platform.web/web/server/chunks/chunk-D4DmFcHJ.js
var chunk_D4DmFcHJ_exports = {};
__export(chunk_D4DmFcHJ_exports, {
  default: () => queryClient
});
var queryClient;
var init_chunk_D4DmFcHJ = __esm({
  ".dev/build/sky.examples.platform.web/web/server/chunks/chunk-D4DmFcHJ.js"() {
    "use strict";
    init_modern();
    queryClient = new QueryClient();
  }
});

// .dev/build/sky.examples.platform.web/web/server/chunks/chunk-BmABpVUj.js
function useData(handler, deps) {
  const pageContext = usePageContext();
  const [isLoading, setLoading] = (0, import_react19.useState)(!afterHydration);
  const [data4, setData] = (0, import_react19.useState)(
    afterHydration ? pageContext.data : void 0
  );
  const { t } = useTranslation();
  (0, import_react19.useEffect)(() => {
    if (afterHydration) {
      return;
    }
    async(load);
    async function load() {
      pageContext.init = async () => ({
        domain: pageContext.domain,
        lng: pageContext.lng,
        lngPrefix: pageContext.lngPrefix,
        t,
        queryClient: (await Promise.resolve().then(() => (init_chunk_D4DmFcHJ(), chunk_D4DmFcHJ_exports))).default,
        ip: pageContext.initial.ip
      });
      as(handler);
      const result = await handler.init(pageContext);
      if (result.data) {
        setData(result.data);
      }
      document.title = result.title;
      setLoading(false);
    }
    __name(load, "load");
  }, []);
  return {
    isLoading,
    ...data4
  };
}
var import_react19;
var init_chunk_BmABpVUj = __esm({
  ".dev/build/sky.examples.platform.web/web/server/chunks/chunk-BmABpVUj.js"() {
    "use strict";
    import_react19 = __toESM(require_react(), 1);
    init_es();
    init_chunk_CQSiE3_x();
    __name(useData, "useData");
  }
});

// .dev/build/sky.examples.platform.web/web/server/entries/pages_old_index.mjs
var pages_old_index_exports = {};
__export(pages_old_index_exports, {
  configValuesSerialized: () => configValuesSerialized6
});
function Container() {
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: cx4`container`, children: "container" });
}
function useStore(Store) {
  const store = useContext(StoreContext);
  if (!store[Store.name]) {
    store[Store.name] = new Store();
  } else if (!(store[Store.name] instanceof Store)) {
    const newStore = new Store();
    Object.assign(newStore, store[Store.name]);
    store[Store.name] = newStore;
  }
  return store[Store.name];
}
function Counter() {
  const counter = useStore(CounterStore);
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
    "button",
    {
      type: "button",
      onClick: /* @__PURE__ */ __name(() => {
        counter.setCount(counter.count + 1);
      }, "onClick"),
      children: [
        "Counter: ",
        counter.count
      ]
    }
  );
}
function HomePage2() {
  Console.log(42);
  useData(HomePageData);
  useEffect(() => {
    async(onTest2, 42);
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(PageLayout, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Container, {}),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "md:mt-2", children: "1234" }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("br", {}),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Counter, {})
  ] });
}
var import_jsx_runtime8, import_react20, import_classnames7, styles3, cx4, HomePageData, import36, StoreContext, CounterStore, import26, configValuesSerialized6;
var init_pages_old_index = __esm({
  async ".dev/build/sky.examples.platform.web/web/server/entries/pages_old_index.mjs"() {
    "use strict";
    await init_chunk_D8IZrfLU();
    import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
    init_chunk_BmABpVUj();
    await init_chunk_sZbIegKP();
    import_react20 = __toESM(require_react(), 1);
    init_chunk_DCFQADSa();
    init_index_web_only();
    init_runtime2();
    import_classnames7 = __toESM(require_classnames(), 1);
    init_es();
    init_chunk_CQSiE3_x();
    init_server();
    styles3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null
    }, Symbol.toStringTag, { value: "Module" }));
    cx4 = cn2(styles3);
    __name(Container, "Container");
    HomePageData = data2(async (pageContext) => {
      const { t } = await pageContext.init({
        ns: []
      });
      return {
        // title: t`title`,
        description: ""
      };
    });
    import36 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: HomePageData
    }, Symbol.toStringTag, { value: "Module" }));
    StoreContext = (0, import_react20.createContext)({});
    __name(useStore, "useStore");
    CounterStore = class {
      static {
        __name(this, "CounterStore");
      }
      constructor() {
        this.count = 0;
        this.count = 10;
      }
      setCount(count) {
        this.count = count;
      }
    };
    __name(Counter, "Counter");
    __name(HomePage2, "HomePage");
    import26 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: HomePage2
    }, Symbol.toStringTag, { value: "Module" }));
    configValuesSerialized6 = {
      ["isClientRuntimeLoaded"]: {
        type: "computed",
        definedAtData: null,
        valueSerialized: {
          type: "js-serialized",
          value: true
        }
      },
      ["onRenderHtml"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/renderer/+onRenderHtml.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import1
        }
      },
      ["Page"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/index/+Page.tsx", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import26
        }
      },
      ["passToClient"]: {
        type: "cumulative",
        definedAtData: [{ "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "passToClient"] }],
        valueSerialized: [{
          type: "js-serialized",
          value: ["errorWhileRendering", "is404", "domain", "lng", "lngPrefix", "urlLogical", "theme", "initial"]
        }]
      },
      ["data"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/index/+data.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import36
        }
      }
    };
  }
});

// .dev/build/sky.examples.platform.web/web/server/entries/pages_old_react-query.mjs
var pages_old_react_query_exports = {};
__export(pages_old_react_query_exports, {
  configValuesSerialized: () => configValuesSerialized7
});
function createValue() {
  let isReset = false;
  return {
    clearReset: /* @__PURE__ */ __name(() => {
      isReset = false;
    }, "clearReset"),
    reset: /* @__PURE__ */ __name(() => {
      isReset = true;
    }, "reset"),
    isReset: /* @__PURE__ */ __name(() => {
      return isReset;
    }, "isReset")
  };
}
function useBaseQuery(options, Observer, queryClient2) {
  if (true) {
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new Error(
        'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
      );
    }
  }
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const client = useQueryClient();
  const defaultedOptions = client.defaultQueryOptions(options);
  client.getDefaultOptions().queries?._experimental_beforeQuery?.(
    defaultedOptions
  );
  if (true) {
    if (!defaultedOptions.queryFn) {
      console.error(
        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
      );
    }
  }
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);
  const [observer] = React4.useState(
    () => new Observer(
      client,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options.subscribed !== false;
  React4.useSyncExternalStore(
    React4.useCallback(
      (onStoreChange) => {
        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;
        observer.updateResult();
        return unsubscribe;
      },
      [observer, shouldSubscribe]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  React4.useEffect(() => {
    observer.setOptions(defaultedOptions);
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client.getQueryCache().get(defaultedOptions.queryHash),
    suspense: defaultedOptions.suspense
  })) {
    throw result.error;
  }
  client.getDefaultOptions().queries?._experimental_afterQuery?.(
    defaultedOptions,
    result
  );
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise = isNewCacheEntry ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      client.getQueryCache().get(defaultedOptions.queryHash)?.promise
    );
    promise?.catch(noop).finally(() => {
      observer.updateResult();
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
function useQuery(options, queryClient2) {
  return useBaseQuery(options, QueryObserver);
}
function ReactQueryPage() {
  useData(Data);
  const { isLoading, error, data: data4 } = useQuery({
    queryKey: ["repoData"],
    queryFn: /* @__PURE__ */ __name(() => fetch.json("https://api.github.com/repos/tannerlinsley/react-query"), "queryFn")
  });
  if (isLoading) {
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(PageLayout, { children: "Loading..." });
  }
  if (error) {
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(PageLayout, { children: "An error has occurred: " + error.message });
  }
  if (!data4) {
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(PageLayout, { children: "An error has occurred: no data" });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(PageLayout, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h1", { children: data4.name }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { children: data4.description }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("strong", { children: [
      "\u{1F440} ",
      data4.subscribers_count
    ] }),
    " ",
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("strong", { children: [
      "\u2728 ",
      data4.stargazers_count
    ] }),
    " ",
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("strong", { children: [
      "\u{1F374} ",
      data4.forks_count
    ] })
  ] });
}
var import_jsx_runtime9, React4, import_classnames8, QueryClientContext, useQueryClient, IsRestoringContext, useIsRestoring, QueryErrorResetBoundaryContext, useQueryErrorResetBoundary, ensurePreventErrorBoundaryRetry, useClearResetErrorBoundary, getHasError, ensureSuspenseTimers, willFetch, shouldSuspend, fetchOptimistic, Data, import37, import27, configValuesSerialized7;
var init_pages_old_react_query = __esm({
  async ".dev/build/sky.examples.platform.web/web/server/entries/pages_old_react-query.mjs"() {
    "use strict";
    await init_chunk_D8IZrfLU();
    import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
    init_modern();
    React4 = __toESM(require_react(), 1);
    init_chunk_BmABpVUj();
    await init_chunk_sZbIegKP();
    init_index_web_only();
    init_runtime2();
    import_classnames8 = __toESM(require_classnames(), 1);
    init_es();
    init_chunk_CQSiE3_x();
    QueryClientContext = React4.createContext(
      void 0
    );
    useQueryClient = /* @__PURE__ */ __name((queryClient2) => {
      const client = React4.useContext(QueryClientContext);
      if (!client) {
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
      }
      return client;
    }, "useQueryClient");
    IsRestoringContext = React4.createContext(false);
    useIsRestoring = /* @__PURE__ */ __name(() => React4.useContext(IsRestoringContext), "useIsRestoring");
    IsRestoringContext.Provider;
    __name(createValue, "createValue");
    QueryErrorResetBoundaryContext = React4.createContext(createValue());
    useQueryErrorResetBoundary = /* @__PURE__ */ __name(() => React4.useContext(QueryErrorResetBoundaryContext), "useQueryErrorResetBoundary");
    ensurePreventErrorBoundaryRetry = /* @__PURE__ */ __name((options, errorResetBoundary) => {
      if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {
        if (!errorResetBoundary.isReset()) {
          options.retryOnMount = false;
        }
      }
    }, "ensurePreventErrorBoundaryRetry");
    useClearResetErrorBoundary = /* @__PURE__ */ __name((errorResetBoundary) => {
      React4.useEffect(() => {
        errorResetBoundary.clearReset();
      }, [errorResetBoundary]);
    }, "useClearResetErrorBoundary");
    getHasError = /* @__PURE__ */ __name(({
      result,
      errorResetBoundary,
      throwOnError,
      query: query2,
      suspense
    }) => {
      return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query2 && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query2]));
    }, "getHasError");
    ensureSuspenseTimers = /* @__PURE__ */ __name((defaultedOptions) => {
      if (defaultedOptions.suspense) {
        const MIN_SUSPENSE_TIME_MS = 1e3;
        const clamp2 = /* @__PURE__ */ __name((value) => value === "static" ? value : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS), "clamp");
        const originalStaleTime = defaultedOptions.staleTime;
        defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => clamp2(originalStaleTime(...args)) : clamp2(originalStaleTime);
        if (typeof defaultedOptions.gcTime === "number") {
          defaultedOptions.gcTime = Math.max(
            defaultedOptions.gcTime,
            MIN_SUSPENSE_TIME_MS
          );
        }
      }
    }, "ensureSuspenseTimers");
    willFetch = /* @__PURE__ */ __name((result, isRestoring) => result.isLoading && result.isFetching && !isRestoring, "willFetch");
    shouldSuspend = /* @__PURE__ */ __name((defaultedOptions, result) => defaultedOptions?.suspense && result.isPending, "shouldSuspend");
    fetchOptimistic = /* @__PURE__ */ __name((defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
      errorResetBoundary.clearReset();
    }), "fetchOptimistic");
    __name(useBaseQuery, "useBaseQuery");
    __name(useQuery, "useQuery");
    Data = data2(async (pageContext) => {
      const { queryClient: queryClient2 } = await pageContext.init({ ns: [] });
      if (runsOnServerSide) {
        queryClient2.setQueryData(
          ["repoData"],
          await fetch.json("https://api.github.com/repos/tannerlinsley/react-query")
        );
      }
      return {
        title: "React Query",
        description: ""
      };
    });
    import37 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: Data
    }, Symbol.toStringTag, { value: "Module" }));
    __name(ReactQueryPage, "ReactQueryPage");
    import27 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: ReactQueryPage
    }, Symbol.toStringTag, { value: "Module" }));
    configValuesSerialized7 = {
      ["isClientRuntimeLoaded"]: {
        type: "computed",
        definedAtData: null,
        valueSerialized: {
          type: "js-serialized",
          value: true
        }
      },
      ["onRenderHtml"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/renderer/+onRenderHtml.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import1
        }
      },
      ["Page"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/react-query/+Page.tsx", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import27
        }
      },
      ["passToClient"]: {
        type: "cumulative",
        definedAtData: [{ "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "passToClient"] }],
        valueSerialized: [{
          type: "js-serialized",
          value: ["errorWhileRendering", "is404", "domain", "lng", "lngPrefix", "urlLogical", "theme", "initial"]
        }]
      },
      ["data"]: {
        type: "standard",
        definedAtData: { "filePathToShowToUser": "/pages/old/react-query/+data.ts", "fileExportPathToShowToUser": [] },
        valueSerialized: {
          type: "plus-file",
          exportValues: import37
        }
      }
    };
  }
});

// .dev/build/sky.examples.platform.web/web/server/entry.mjs
var entry_exports = {};
function onBeforeRoute(pageContext) {
  const { pathname } = pageContext.urlParsed;
  const urlLogical = pathname;
  return {
    pageContext: {
      // domain,
      // lng,
      // lngPrefix,
      // Vike's router will use pageContext.urlLogical instead of pageContext.urlOriginal
      urlLogical
    }
  };
}
var telefuncFilesGlob, telefuncFiles, import12, pageFilesLazy, pageFilesEager, pageFilesExportNamesLazy, pageFilesExportNamesEager, pageFilesList, neverLoaded, pageConfigsSerialized, pageConfigGlobalSerialized, pageFilesLazyIsomorph1, pageFilesLazyIsomorph, pageFilesLazyServer1, pageFilesLazyServer, pageFilesEagerRoute1, pageFilesEagerRoute, pageFilesExportNamesEagerClient1, pageFilesExportNamesEagerClient, virtualFileExportsGlobalEntry;
var init_entry = __esm({
  ".dev/build/sky.examples.platform.web/web/server/entry.mjs"() {
    "use strict";
    init_loadBuildEntry();
    init_internal();
    telefuncFilesGlob = /* @__PURE__ */ Object.assign({ "/pages/index/HomePage.telefunc.ts": /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_chunk_DtOK7jkR(), chunk_DtOK7jkR_exports)), "/pages/index/HomePage.telefunc.ts"), "/pages/old/data-fetching/@id/Page.telefunc.ts": /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_chunk_BLGzEfE8(), chunk_BLGzEfE8_exports)), "/pages/old/data-fetching/@id/Page.telefunc.ts"), "/pages/old/data-fetching/index/Page.telefunc.ts": /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_chunk_VZQ4tFqC(), chunk_VZQ4tFqC_exports)), "/pages/old/data-fetching/index/Page.telefunc.ts"), "/pages/old/index/HomePage.telefunc.ts": /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_chunk_DCFQADSa(), chunk_DCFQADSa_exports)), "/pages/old/index/HomePage.telefunc.ts") });
    telefuncFiles = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      telefuncFilesGlob
    }, Symbol.toStringTag, { value: "Module" }));
    __name(onBeforeRoute, "onBeforeRoute");
    import12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      onBeforeRoute
    }, Symbol.toStringTag, { value: "Module" }));
    pageFilesLazy = {};
    pageFilesEager = {};
    pageFilesExportNamesLazy = {};
    pageFilesExportNamesEager = {};
    pageFilesList = [];
    neverLoaded = {};
    pageConfigsSerialized = [
      {
        pageId: "/pages/index",
        isErrorPage: void 0,
        routeFilesystem: { "routeString": "/", "definedAtLocation": "/pages/index/" },
        loadVirtualFilePageEntry: /* @__PURE__ */ __name(() => ({ moduleId: "virtual:vike:page-entry:server:/pages/index", moduleExportsPromise: init_pages_index().then(() => pages_index_exports) }), "loadVirtualFilePageEntry"),
        configValuesSerialized: {
          ["isClientRuntimeLoaded"]: {
            type: "computed",
            definedAtData: null,
            valueSerialized: {
              type: "js-serialized",
              value: false
            }
          }
        }
      },
      {
        pageId: "/pages/old/_error",
        isErrorPage: true,
        routeFilesystem: void 0,
        loadVirtualFilePageEntry: /* @__PURE__ */ __name(() => ({ moduleId: "virtual:vike:page-entry:server:/pages/old/_error", moduleExportsPromise: init_pages_old_error().then(() => pages_old_error_exports) }), "loadVirtualFilePageEntry"),
        configValuesSerialized: {
          ["isClientRuntimeLoaded"]: {
            type: "computed",
            definedAtData: null,
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          },
          ["clientRouting"]: {
            type: "standard",
            definedAtData: { "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "clientRouting"] },
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          }
        }
      },
      {
        pageId: "/pages/old/about",
        isErrorPage: void 0,
        routeFilesystem: { "routeString": "/old/about", "definedAtLocation": "/pages/old/about/" },
        loadVirtualFilePageEntry: /* @__PURE__ */ __name(() => ({ moduleId: "virtual:vike:page-entry:server:/pages/old/about", moduleExportsPromise: init_pages_old_about().then(() => pages_old_about_exports) }), "loadVirtualFilePageEntry"),
        configValuesSerialized: {
          ["isClientRuntimeLoaded"]: {
            type: "computed",
            definedAtData: null,
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          },
          ["clientRouting"]: {
            type: "standard",
            definedAtData: { "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "clientRouting"] },
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          }
        }
      },
      {
        pageId: "/pages/old/data-fetching/@id",
        isErrorPage: void 0,
        routeFilesystem: { "routeString": "/old/data-fetching/@id", "definedAtLocation": "/pages/old/data-fetching/@id/" },
        loadVirtualFilePageEntry: /* @__PURE__ */ __name(() => ({ moduleId: "virtual:vike:page-entry:server:/pages/old/data-fetching/@id", moduleExportsPromise: init_pages_old_data_fetching_id().then(() => pages_old_data_fetching_id_exports) }), "loadVirtualFilePageEntry"),
        configValuesSerialized: {
          ["isClientRuntimeLoaded"]: {
            type: "computed",
            definedAtData: null,
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          },
          ["clientRouting"]: {
            type: "standard",
            definedAtData: { "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "clientRouting"] },
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          }
        }
      },
      {
        pageId: "/pages/old/data-fetching/index",
        isErrorPage: void 0,
        routeFilesystem: { "routeString": "/old/data-fetching", "definedAtLocation": "/pages/old/data-fetching/index/" },
        loadVirtualFilePageEntry: /* @__PURE__ */ __name(() => ({ moduleId: "virtual:vike:page-entry:server:/pages/old/data-fetching/index", moduleExportsPromise: init_pages_old_data_fetching_index().then(() => pages_old_data_fetching_index_exports) }), "loadVirtualFilePageEntry"),
        configValuesSerialized: {
          ["isClientRuntimeLoaded"]: {
            type: "computed",
            definedAtData: null,
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          },
          ["clientRouting"]: {
            type: "standard",
            definedAtData: { "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "clientRouting"] },
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          }
        }
      },
      {
        pageId: "/pages/old/index",
        isErrorPage: void 0,
        routeFilesystem: { "routeString": "/old", "definedAtLocation": "/pages/old/index/" },
        loadVirtualFilePageEntry: /* @__PURE__ */ __name(() => ({ moduleId: "virtual:vike:page-entry:server:/pages/old/index", moduleExportsPromise: init_pages_old_index().then(() => pages_old_index_exports) }), "loadVirtualFilePageEntry"),
        configValuesSerialized: {
          ["isClientRuntimeLoaded"]: {
            type: "computed",
            definedAtData: null,
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          },
          ["clientRouting"]: {
            type: "standard",
            definedAtData: { "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "clientRouting"] },
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          }
        }
      },
      {
        pageId: "/pages/old/react-query",
        isErrorPage: void 0,
        routeFilesystem: { "routeString": "/old/react-query", "definedAtLocation": "/pages/old/react-query/" },
        loadVirtualFilePageEntry: /* @__PURE__ */ __name(() => ({ moduleId: "virtual:vike:page-entry:server:/pages/old/react-query", moduleExportsPromise: init_pages_old_react_query().then(() => pages_old_react_query_exports) }), "loadVirtualFilePageEntry"),
        configValuesSerialized: {
          ["isClientRuntimeLoaded"]: {
            type: "computed",
            definedAtData: null,
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          },
          ["clientRouting"]: {
            type: "standard",
            definedAtData: { "filePathToShowToUser": "/renderer/old/+config.ts", "fileExportPathToShowToUser": ["default", "clientRouting"] },
            valueSerialized: {
              type: "js-serialized",
              value: true
            }
          }
        }
      }
    ];
    pageConfigGlobalSerialized = {
      configValuesSerialized: {
        ["onBeforeRoute"]: {
          type: "standard",
          definedAtData: { "filePathToShowToUser": "/renderer/old/+onBeforeRoute.ts", "fileExportPathToShowToUser": [] },
          valueSerialized: {
            type: "plus-file",
            exportValues: import12
          }
        }
      }
    };
    pageFilesLazyIsomorph1 = /* @__PURE__ */ Object.assign({});
    pageFilesLazyIsomorph = { ...pageFilesLazyIsomorph1 };
    pageFilesLazy[".page"] = pageFilesLazyIsomorph;
    pageFilesLazyServer1 = /* @__PURE__ */ Object.assign({});
    pageFilesLazyServer = { ...pageFilesLazyServer1 };
    pageFilesLazy[".page.server"] = pageFilesLazyServer;
    pageFilesEagerRoute1 = /* @__PURE__ */ Object.assign({});
    pageFilesEagerRoute = { ...pageFilesEagerRoute1 };
    pageFilesEager[".page.route"] = pageFilesEagerRoute;
    pageFilesExportNamesEagerClient1 = /* @__PURE__ */ Object.assign({});
    pageFilesExportNamesEagerClient = { ...pageFilesExportNamesEagerClient1 };
    pageFilesExportNamesEager[".page.client"] = pageFilesExportNamesEagerClient;
    virtualFileExportsGlobalEntry = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      neverLoaded,
      pageConfigGlobalSerialized,
      pageConfigsSerialized,
      pageFilesEager,
      pageFilesExportNamesEager,
      pageFilesExportNamesLazy,
      pageFilesLazy,
      pageFilesList
    }, Symbol.toStringTag, { value: "Module" }));
    setTelefuncLoaders({
      loadTelefuncFiles: /* @__PURE__ */ __name(() => telefuncFiles, "loadTelefuncFiles"),
      loadManifest: /* @__PURE__ */ __name(() => ({
        "version": "0.2.11",
        "config": {}
      }), "loadManifest")
    });
    {
      const assetsManifest = {
        "../../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/index.js": {
          "file": "static/chunks/chunk-BOZzjomj.js",
          "name": "index",
          "src": "../../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/index.js",
          "isDynamicEntry": true
        },
        "../../../node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/client/runtime-client-routing/entry.js": {
          "file": "static/entries/entry-client-routing.idiQWH5p.js",
          "name": "entries/entry-client-routing",
          "src": "../../../node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/client/runtime-client-routing/entry.js",
          "isEntry": true,
          "imports": [
            "_chunk-DB9Bmd99.js",
            "_chunk-D6-4mDNZ.js",
            "_chunk-Ban36gwz.js"
          ],
          "dynamicImports": [
            "../../../virtual:vike:page-entry:client:/pages/index",
            "../../../virtual:vike:page-entry:client:/pages/old/_error",
            "../../../virtual:vike:page-entry:client:/pages/old/about",
            "../../../virtual:vike:page-entry:client:/pages/old/data-fetching/@id",
            "../../../virtual:vike:page-entry:client:/pages/old/data-fetching/index",
            "../../../virtual:vike:page-entry:client:/pages/old/index",
            "../../../virtual:vike:page-entry:client:/pages/old/react-query"
          ],
          "css": [
            "static/static/style-df91aa03.hGGmGWv8.css"
          ]
        },
        "../../../node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/client/runtime-server-routing/entry.js": {
          "file": "static/entries/entry-server-routing.Cim3okuy.js",
          "name": "entries/entry-server-routing",
          "src": "../../../node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/client/runtime-server-routing/entry.js",
          "isEntry": true,
          "imports": [
            "_chunk-DB9Bmd99.js",
            "_chunk-Ban36gwz.js",
            "_chunk-D6-4mDNZ.js"
          ],
          "dynamicImports": [
            "../../../virtual:vike:page-entry:client:/pages/index",
            "../../../virtual:vike:page-entry:client:/pages/old/_error",
            "../../../virtual:vike:page-entry:client:/pages/old/about",
            "../../../virtual:vike:page-entry:client:/pages/old/data-fetching/@id",
            "../../../virtual:vike:page-entry:client:/pages/old/data-fetching/index",
            "../../../virtual:vike:page-entry:client:/pages/old/index",
            "../../../virtual:vike:page-entry:client:/pages/old/react-query"
          ]
        },
        "../../../virtual:vike:page-entry:client:/pages/index": {
          "file": "static/entries/pages_index.CHEsZ1b_.js",
          "name": "entries/pages/index",
          "src": "../../../virtual:vike:page-entry:client:/pages/index",
          "isEntry": true,
          "isDynamicEntry": true,
          "imports": [
            "_chunk-B-t9GizM.js",
            "_chunk-BGH0UyRY.js",
            "_chunk-Ban36gwz.js",
            "_chunk-C5CBEOK6.js",
            "_chunk-D6-4mDNZ.js"
          ],
          "css": [
            "static/static/index.CNL29mzo.css"
          ]
        },
        "../../../virtual:vike:page-entry:client:/pages/old/_error": {
          "file": "static/entries/pages_old_error.CSIBtIes.js",
          "name": "entries/pages/old/_error",
          "src": "../../../virtual:vike:page-entry:client:/pages/old/_error",
          "isEntry": true,
          "isDynamicEntry": true,
          "imports": [
            "_chunk-B116Bhhb.js",
            "_chunk-B-t9GizM.js",
            "_chunk-BGH0UyRY.js",
            "_chunk-COfWIvyR.js",
            "_chunk-Ban36gwz.js"
          ]
        },
        "../../../virtual:vike:page-entry:client:/pages/old/about": {
          "file": "static/entries/pages_old_about.CD7PhZIj.js",
          "name": "entries/pages/old/about",
          "src": "../../../virtual:vike:page-entry:client:/pages/old/about",
          "isEntry": true,
          "isDynamicEntry": true,
          "imports": [
            "_chunk-B116Bhhb.js",
            "_chunk-B-t9GizM.js",
            "_chunk-BGH0UyRY.js",
            "_chunk-Ban36gwz.js"
          ],
          "css": [
            "static/static/about.CZHHJist.css"
          ]
        },
        "../../../virtual:vike:page-entry:client:/pages/old/data-fetching/@id": {
          "file": "static/entries/pages_old_data-fetching_-id.DhnXNZPI.js",
          "name": "entries/pages/old/data-fetching/@id",
          "src": "../../../virtual:vike:page-entry:client:/pages/old/data-fetching/@id",
          "isEntry": true,
          "isDynamicEntry": true,
          "imports": [
            "_chunk-B116Bhhb.js",
            "_chunk-B-t9GizM.js"
          ]
        },
        "../../../virtual:vike:page-entry:client:/pages/old/data-fetching/index": {
          "file": "static/entries/pages_old_data-fetching_index.BcmoLr6t.js",
          "name": "entries/pages/old/data-fetching/index",
          "src": "../../../virtual:vike:page-entry:client:/pages/old/data-fetching/index",
          "isEntry": true,
          "isDynamicEntry": true,
          "imports": [
            "_chunk-B116Bhhb.js",
            "_chunk-B-t9GizM.js"
          ]
        },
        "../../../virtual:vike:page-entry:client:/pages/old/index": {
          "file": "static/entries/pages_old_index.DrtJoV7W.js",
          "name": "entries/pages/old/index",
          "src": "../../../virtual:vike:page-entry:client:/pages/old/index",
          "isEntry": true,
          "isDynamicEntry": true,
          "imports": [
            "_chunk-B116Bhhb.js",
            "_chunk-B-t9GizM.js",
            "_chunk-BGH0UyRY.js",
            "_chunk-DLq35ETF.js",
            "_chunk-C5CBEOK6.js",
            "_chunk-Ban36gwz.js",
            "_chunk-COfWIvyR.js",
            "_chunk-D6-4mDNZ.js"
          ],
          "css": [
            "static/static/index.B11lhAvX.css"
          ]
        },
        "../../../virtual:vike:page-entry:client:/pages/old/react-query": {
          "file": "static/entries/pages_old_react-query.C-3EctDi.js",
          "name": "entries/pages/old/react-query",
          "src": "../../../virtual:vike:page-entry:client:/pages/old/react-query",
          "isEntry": true,
          "isDynamicEntry": true,
          "imports": [
            "_chunk-B116Bhhb.js",
            "_chunk-B-t9GizM.js",
            "_chunk-BGH0UyRY.js",
            "_chunk-DLq35ETF.js",
            "_chunk-Ban36gwz.js",
            "_chunk-COfWIvyR.js"
          ]
        },
        "_chunk-B-t9GizM.js": {
          "file": "static/chunks/chunk-B-t9GizM.js",
          "name": "jsx-runtime"
        },
        "_chunk-B116Bhhb.js": {
          "file": "static/chunks/chunk-B116Bhhb.js",
          "name": "_onHydrationEnd",
          "imports": [
            "_chunk-B-t9GizM.js"
          ]
        },
        "_chunk-BGH0UyRY.js": {
          "file": "static/chunks/chunk-BGH0UyRY.js",
          "name": "global",
          "imports": [
            "_chunk-B-t9GizM.js",
            "_chunk-Ban36gwz.js"
          ],
          "dynamicImports": [
            "../../../node_modules/.pnpm/@whatwg-node+disposablestack@0.0.6/node_modules/@whatwg-node/disposablestack/esm/index.js"
          ]
        },
        "_chunk-Ban36gwz.js": {
          "file": "static/chunks/chunk-Ban36gwz.js",
          "name": "preload-helper"
        },
        "_chunk-C5CBEOK6.js": {
          "file": "static/chunks/chunk-C5CBEOK6.js",
          "name": "remoteTelefunctionCall",
          "imports": [
            "_chunk-D6-4mDNZ.js"
          ]
        },
        "_chunk-COfWIvyR.js": {
          "file": "static/chunks/chunk-COfWIvyR.js",
          "name": "usePageContext",
          "imports": [
            "_chunk-BGH0UyRY.js",
            "_chunk-B-t9GizM.js"
          ]
        },
        "_chunk-D6-4mDNZ.js": {
          "file": "static/chunks/chunk-D6-4mDNZ.js",
          "name": "parse"
        },
        "_chunk-DB9Bmd99.js": {
          "file": "static/chunks/chunk-DB9Bmd99.js",
          "name": "getCurrentUrl",
          "imports": [
            "_chunk-D6-4mDNZ.js"
          ]
        },
        "_chunk-DLq35ETF.js": {
          "file": "static/chunks/chunk-DLq35ETF.js",
          "name": "data",
          "imports": [
            "_chunk-Ban36gwz.js",
            "_chunk-BGH0UyRY.js",
            "_chunk-COfWIvyR.js"
          ],
          "dynamicImports": [
            "renderer/old/queryClient.ts"
          ]
        },
        "_style-df91aa03.hGGmGWv8.css": {
          "file": "static/static/style-df91aa03.hGGmGWv8.css",
          "src": "_style-df91aa03.hGGmGWv8.css"
        },
        "renderer/old/queryClient.ts": {
          "file": "static/chunks/chunk-DldBoc5l.js",
          "name": "queryClient",
          "src": "renderer/old/queryClient.ts",
          "isDynamicEntry": true,
          "imports": [
            "_chunk-DLq35ETF.js",
            "_chunk-Ban36gwz.js",
            "_chunk-BGH0UyRY.js",
            "_chunk-B-t9GizM.js",
            "_chunk-COfWIvyR.js"
          ]
        }
      };
      const buildInfo = {
        "versionAtBuildTime": "0.4.238",
        "usesClientRouter": false,
        "viteConfigRuntime": {
          "root": "/Users/a/Space/Projects/EmptySet/sky-modules/examples/platform/web",
          "build": {
            "outDir": "/Users/a/Space/Projects/EmptySet/sky-modules/.dev/build/sky.examples.platform.web/web/"
          },
          "_baseViteOriginal": "/",
          "vitePluginServerEntry": {}
        }
      };
      setGlobalContext_prodBuildEntry({
        virtualFileExportsGlobalEntry,
        assetsManifest,
        buildInfo
      });
    }
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/autoImporter.js
var autoImporter_exports = {};
__export(autoImporter_exports, {
  loadServerEntry: () => loadServerEntry,
  paths: () => paths,
  pluginVersion: () => pluginVersion,
  status: () => status
});
var status, pluginVersion, loadServerEntry, paths;
var init_autoImporter = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/autoImporter.js"() {
    status = "SET";
    pluginVersion = "0.7.14";
    loadServerEntry = /* @__PURE__ */ __name(async () => {
      await Promise.resolve().then(() => (init_entry(), entry_exports));
    }, "loadServerEntry");
    paths = {
      autoImporterFilePathOriginal: "/Users/a/Space/Projects/EmptySet/sky-modules/node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/autoImporter.js",
      autoImporterFilePathActual: (() => {
        try {
          return import.meta.url;
        } catch {
          return null;
        }
      })(),
      serverEntryFilePathRelative: "../../../../../../../../../.dev/build/sky.examples.platform.web/web/server/entry.mjs",
      serverEntryFilePathOriginal: "/Users/a/Space/Projects/EmptySet/sky-modules/.dev/build/sky.examples.platform.web/web/server/entry.mjs",
      serverEntryFilePathResolved: /* @__PURE__ */ __name(() => import.meta.resolve("../../../../../../../../../.dev/build/sky.examples.platform.web/web/server/entry.mjs"), "serverEntryFilePathResolved")
    };
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/importServerProductionEntry.js
async function importServerProductionEntry(args = {}) {
  const autoImporter = await Promise.resolve().then(() => (init_autoImporter(), autoImporter_exports));
  debugLogsRuntimePre(autoImporter);
  let success = false;
  let requireError;
  let isOutsideOfCwd = null;
  if (autoImporter.status === "SET") {
    isOutsideOfCwd = isServerEntryOutsideOfCwd(autoImporter.paths);
    if (isOutsideOfCwd === false || isOutsideOfCwd === null) {
      try {
        await autoImporter.loadServerEntry();
        success = true;
      } catch (err) {
        if (!isDebug2) {
          throw err;
        } else {
          requireError = err;
        }
      }
    }
  }
  if (!success) {
    const outFilePath = await crawlOutDir({
      ...args,
      outFileSearch: [serverEntryFileNameBase, serverEntryFileNameBaseAlternative]
    });
    if (outFilePath) {
      await import_(outFilePath);
      success = true;
    }
  }
  debugLogsRuntimePost({ success, requireError, isOutsideOfCwd, ...args });
  if (args.tolerateDoesNotExist) {
    return success;
  } else {
    assertUsage2(success, wrongUsageNotBuilt);
    return null;
  }
}
function isServerEntryOutsideOfCwd(paths2) {
  const cwd = getCwdSafe();
  if (!cwd)
    return null;
  let serverEntryFilePath;
  try {
    serverEntryFilePath = paths2.serverEntryFilePathResolved();
  } catch {
    return null;
  }
  serverEntryFilePath = removeFilePrefix(serverEntryFilePath);
  if (isWebpackResolve(serverEntryFilePath, cwd))
    return null;
  serverEntryFilePath = toPosixPath2(serverEntryFilePath);
  assertPosixPath2(cwd);
  return !serverEntryFilePath.startsWith(cwd);
}
function removeFilePrefix(filePath) {
  assert2(process);
  const filePrefix = process.platform === "win32" ? "file:///" : "file://";
  if (filePath.startsWith(filePrefix))
    filePath = filePath.slice(filePrefix.length);
  return filePath;
}
var wrongUsageNotBuilt;
var init_importServerProductionEntry = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/importServerProductionEntry.js"() {
    init_utils5();
    init_debugLogsRuntime();
    init_debug3();
    init_serverEntryFileNameBase();
    init_crawlOutDir();
    init_esm();
    wrongUsageNotBuilt = "The server production entry is missing. (Re-)build your app and try again. If you still get this error, then you need to manually import the server production entry, see https://github.com/brillout/vite-plugin-server-entry#manual-import";
    __name(importServerProductionEntry, "importServerProductionEntry");
    __name(isServerEntryOutsideOfCwd, "isServerEntryOutsideOfCwd");
    __name(removeFilePrefix, "removeFilePrefix");
  }
});

// node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/index.js
var init_runtime = __esm({
  "node_modules/.pnpm/@brillout+vite-plugin-server-entry@0.7.14/node_modules/@brillout/vite-plugin-server-entry/dist/esm/runtime/index.js"() {
    init_importServerProductionEntry();
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/deduceRouteStringFromFilesystemPath.js
function deduceRouteStringFromFilesystemPath(pageId, filesystemRoots) {
  const filesystemRootsMatch = filesystemRoots.filter(({ filesystemRoot }) => pageId.startsWith(filesystemRoot)).sort(higherFirst(({ filesystemRoot }) => filesystemRoot.length));
  const fsBase = filesystemRootsMatch[0];
  let filesystemRoute;
  if (fsBase) {
    const { filesystemRoot, urlRoot } = fsBase;
    const debugInfo = { pageId, filesystemRoot, urlRoot };
    assert(urlRoot.startsWith("/") && pageId.startsWith("/") && filesystemRoot.startsWith("/"), debugInfo);
    assert(pageId.startsWith(filesystemRoot), debugInfo);
    if (filesystemRoot !== "/") {
      assert(!filesystemRoot.endsWith("/"), debugInfo);
      filesystemRoute = slice(pageId, filesystemRoot.length, 0);
    } else {
      filesystemRoute = pageId;
    }
    assert(filesystemRoute.startsWith("/"), debugInfo);
    filesystemRoute = urlRoot + (urlRoot.endsWith("/") ? "" : "/") + slice(filesystemRoute, 1, 0);
  } else {
    filesystemRoute = pageId;
  }
  assert(filesystemRoute.startsWith("/"));
  filesystemRoute = filesystemRoute.split("/").filter((dir) => dir !== "pages" && dir !== "src" && dir !== "index").join("/");
  assert(!filesystemRoute.includes(".page."));
  assert(!filesystemRoute.endsWith("."));
  if (filesystemRoute.endsWith("/index")) {
    filesystemRoute = slice(filesystemRoute, 0, -"/index".length);
  }
  if (filesystemRoute === "") {
    filesystemRoute = "/";
  }
  assert(filesystemRoute.startsWith("/"));
  assert(!filesystemRoute.endsWith("/") || filesystemRoute === "/");
  return filesystemRoute;
}
var init_deduceRouteStringFromFilesystemPath = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/deduceRouteStringFromFilesystemPath.js"() {
    init_utils4();
    __name(deduceRouteStringFromFilesystemPath, "deduceRouteStringFromFilesystemPath");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/loadPageRoutes.js
async function loadPageRoutes(pageFilesAll, pageConfigs, pageConfigGlobal, allPageIds) {
  await Promise.all(pageFilesAll.filter((p2) => p2.fileType === ".page.route").map((p2) => p2.loadFile?.()));
  return loadPageRoutesSync(pageFilesAll, pageConfigs, pageConfigGlobal, allPageIds);
}
function loadPageRoutesSync(pageFilesAll, pageConfigs, pageConfigGlobal, allPageIds) {
  const { onBeforeRouteHook, filesystemRoots } = getGlobalHooks(pageFilesAll, pageConfigs, pageConfigGlobal);
  const pageRoutes = getPageRoutes(filesystemRoots, pageFilesAll, pageConfigs, allPageIds);
  return { pageRoutes, onBeforeRouteHook };
}
function getPageRoutes(filesystemRoots, pageFilesAll, pageConfigs, allPageIds) {
  const pageRoutes = [];
  if (pageConfigs.length > 0) {
    assert(filesystemRoots === null);
    const comesFromV1PageConfig = true;
    pageConfigs.filter((p2) => !p2.isErrorPage).forEach((pageConfig) => {
      const pageId = pageConfig.pageId;
      let pageRoute = null;
      {
        const configName = "route";
        const configValue = getConfigValueRuntime(pageConfig, configName);
        if (configValue) {
          const route2 = configValue.value;
          assert(configValue.definedAtData);
          const definedAtString = getDefinedAtString(configValue.definedAtData, configName);
          if (typeof route2 === "string") {
            pageRoute = {
              pageId,
              comesFromV1PageConfig,
              routeString: route2,
              routeDefinedAtString: definedAtString,
              routeType: "STRING"
            };
          } else {
            const { definedAtData } = configValue;
            assert(!isArray(definedAtData) && !definedAtData.definedBy);
            const { filePathToShowToUser } = definedAtData;
            assert(filePathToShowToUser);
            assert(isCallable(route2));
            if (getConfigValueRuntime(pageConfig, "iKnowThePerformanceRisksOfAsyncRouteFunctions", "boolean"))
              warnDeprecatedAllowKey();
            pageRoute = {
              pageId,
              comesFromV1PageConfig,
              routeFunction: route2,
              routeFunctionFilePath: filePathToShowToUser,
              routeDefinedAtString: definedAtString,
              routeType: "FUNCTION"
            };
          }
        }
      }
      if (!pageRoute) {
        const { routeFilesystem } = pageConfig;
        assert(routeFilesystem);
        const { routeString, definedAtLocation } = routeFilesystem;
        assert(routeFilesystem.routeString.startsWith("/"));
        pageRoute = {
          pageId,
          routeFilesystemDefinedBy: definedAtLocation,
          comesFromV1PageConfig,
          routeString,
          routeDefinedAtString: null,
          routeType: "FILESYSTEM"
        };
      }
      assert(pageRoute);
      pageRoutes.push(pageRoute);
    });
  }
  if (pageConfigs.length === 0) {
    assert(filesystemRoots);
    const comesFromV1PageConfig = false;
    allPageIds.filter((pageId) => !isErrorPageId(pageId, false)).forEach((pageId) => {
      const pageRouteFile = pageFilesAll.find((p2) => p2.pageId === pageId && p2.fileType === ".page.route");
      if (!pageRouteFile || !("default" in pageRouteFile.fileExports)) {
        const routeString = deduceRouteStringFromFilesystemPath(pageId, filesystemRoots);
        assert(routeString.startsWith("/"));
        assert(!routeString.endsWith("/") || routeString === "/");
        pageRoutes.push({
          pageId,
          comesFromV1PageConfig,
          routeString,
          routeDefinedAtString: null,
          routeFilesystemDefinedBy: `${pageId}.page.*`,
          routeType: "FILESYSTEM"
        });
      } else {
        const { filePath, fileExports } = pageRouteFile;
        assert(fileExports.default);
        if (hasProp(fileExports, "default", "string")) {
          const routeString = fileExports.default;
          assertUsage(routeString.startsWith("/"), `A Route String should start with a leading slash '/' but ${filePath} has \`export default '${routeString}'\`. Make sure to \`export default '/${routeString}'\` instead.`);
          pageRoutes.push({
            pageId,
            comesFromV1PageConfig,
            routeString,
            routeDefinedAtString: filePath,
            routeType: "STRING"
          });
          return;
        }
        if (hasProp(fileExports, "default", "function")) {
          const routeFunction = fileExports.default;
          {
            const allowKey = "iKnowThePerformanceRisksOfAsyncRouteFunctions";
            if (allowKey in fileExports) {
              warnDeprecatedAllowKey();
            }
          }
          pageRoutes.push({
            pageId,
            comesFromV1PageConfig,
            routeFunction,
            routeFunctionFilePath: filePath,
            routeDefinedAtString: filePath,
            routeType: "FUNCTION"
          });
          return;
        }
        assertUsage(false, `The default export of ${filePath} should be a string or a function.`);
      }
    });
  }
  return pageRoutes;
}
function getGlobalHooks(pageFilesAll, pageConfigs, pageConfigGlobal) {
  if (pageConfigs.length > 0) {
    const hook2 = getHookFromPageConfigGlobal(pageConfigGlobal, "onBeforeRoute");
    return { onBeforeRouteHook: hook2, filesystemRoots: null };
  }
  let onBeforeRouteHook = null;
  const filesystemRoots = [];
  pageFilesAll.filter((p2) => p2.fileType === ".page.route" && p2.isDefaultPageFile).forEach(({ filePath, fileExports }) => {
    assert(fileExports);
    if ("onBeforeRoute" in fileExports) {
      assertUsage(hasProp(fileExports, "onBeforeRoute", "function"), `\`export { onBeforeRoute }\` of ${filePath} should be a function.`);
      const { onBeforeRoute: onBeforeRoute2 } = fileExports;
      const hookName = "onBeforeRoute";
      onBeforeRouteHook = {
        hookFilePath: filePath,
        hookFn: onBeforeRoute2,
        hookName,
        hookTimeout: getHookTimeoutDefault(hookName)
      };
    }
    if ("filesystemRoutingRoot" in fileExports) {
      assertUsage(hasProp(fileExports, "filesystemRoutingRoot", "string"), `\`export { filesystemRoutingRoot }\` of ${filePath} should be a string.`);
      assertUsage(hasProp(fileExports, "filesystemRoutingRoot", "string"), `\`export { filesystemRoutingRoot }\` of ${filePath} is \`'${fileExports.filesystemRoutingRoot}'\` but it should start with a leading slash \`/\`.`);
      filesystemRoots.push({
        filesystemRoot: dirname(filePath),
        urlRoot: fileExports.filesystemRoutingRoot
      });
    }
  });
  return { onBeforeRouteHook, filesystemRoots };
}
function dirname(filePath) {
  assert(filePath.startsWith("/"));
  assert(!filePath.endsWith("/"));
  const paths2 = filePath.split("/");
  const dirPath = slice(paths2, 0, -1).join("/") || "/";
  assert(dirPath.startsWith("/"));
  assert(!dirPath.endsWith("/") || dirPath === "/");
  return dirPath;
}
var init_loadPageRoutes = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/loadPageRoutes.js"() {
    init_error_page();
    init_utils4();
    init_deduceRouteStringFromFilesystemPath();
    init_utils();
    init_getConfigValueRuntime();
    init_getConfigDefinedAt();
    init_resolveRouteFunction();
    init_getHook();
    __name(loadPageRoutes, "loadPageRoutes");
    __name(loadPageRoutesSync, "loadPageRoutesSync");
    __name(getPageRoutes, "getPageRoutes");
    __name(getGlobalHooks, "getGlobalHooks");
    __name(dirname, "dirname");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/assertV1Design.js
function assertV1Design(pageConfigs, pageFilesAll) {
  const isOldDesign = pageFilesAll === true || pageFilesAll !== false && pageFilesAll.length > 0;
  const isV1Design = pageConfigs === true || pageConfigs !== false && pageConfigs.length > 0;
  if (isV1Design && isOldDesign) {
    const lines = ["Mixing the new V1 design with the old V0.4 design is forbidden."];
    const indent = "- ";
    if (typeof pageConfigs !== "boolean") {
      assert(pageConfigs.length > 0);
      const filesV1 = unique(pageConfigs.map((p2) => Object.values(p2.configValueSources).map((sources) => sources.map((c) => c.definedAt).map((definedAt) => definedAt.definedBy ? null : definedAt.filePathAbsoluteUserRootDir).filter(isNotNullish).map((filePathToShowToUser) => indent + filePathToShowToUser))).flat(2));
      lines.push(...["V1 design files:", ...filesV1]);
    }
    if (typeof pageFilesAll !== "boolean") {
      assert(pageFilesAll.length > 0);
      const filesOld = pageFilesAll.map((p2) => indent + p2.filePath);
      lines.push(...["Old design files:", ...filesOld]);
    }
    assertUsage(false, lines.join("\n"));
  }
  assertWarning2(!isOldDesign, "You are using Vike's deprecated design. Update to the new V1 design, see https://vike.dev/migration/v1-design for how to migrate.", { onlyOnce: true });
}
var init_assertV1Design = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/assertV1Design.js"() {
    init_utils2();
    __name(assertV1Design, "assertV1Design");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/resolveBase.js
function resolveBase(baseViteOriginal, baseServerUnresolved, baseAssetsUnresolved) {
  if (baseViteOriginal === "/__UNSET__")
    baseViteOriginal = null;
  {
    const wrongBase = /* @__PURE__ */ __name((val) => `should start with ${picocolors_default.cyan("/")}, ${picocolors_default.cyan("http://")}, or ${picocolors_default.cyan("https://")} (it's ${picocolors_default.cyan(val)} instead)`, "wrongBase");
    assertUsage(baseViteOriginal === null || isBaseAssets(baseViteOriginal), `vite.config.js#base ${wrongBase(baseViteOriginal)}`);
    assertUsage(baseAssetsUnresolved === null || isBaseAssets(baseAssetsUnresolved), `Config ${picocolors_default.cyan("baseAssets")} ${wrongBase(baseAssetsUnresolved)}`);
    assertUsage(baseServerUnresolved === null || baseServerUnresolved.startsWith("/"), `Config ${picocolors_default.cyan("baseServer")} should start with a leading slash ${picocolors_default.cyan("/")} (it's ${picocolors_default.cyan(String(baseServerUnresolved))} instead)`);
  }
  if (baseViteOriginal) {
    if (baseViteOriginal.startsWith("http")) {
      baseAssetsUnresolved = baseAssetsUnresolved ?? baseViteOriginal;
    } else {
      baseAssetsUnresolved = baseAssetsUnresolved ?? baseViteOriginal;
      baseServerUnresolved = baseServerUnresolved ?? baseViteOriginal;
    }
  }
  const baseServer2 = baseServerUnresolved ?? "/";
  const baseAssets = baseAssetsUnresolved ?? "/";
  assert(isBaseAssets(baseAssets));
  assert(isBaseServer(baseServer2));
  return {
    baseServer: baseServer2,
    baseAssets
  };
}
var init_resolveBase = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/resolveBase.js"() {
    init_utils2();
    init_picocolors();
    __name(resolveBase, "resolveBase");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/determinePageIdOld.js
function determinePageIdOld(filePath) {
  const pageSuffix = ".page.";
  const pageId = slice(filePath.split(pageSuffix), 0, -1).join(pageSuffix);
  assert(!pageId.includes("\\"));
  return pageId;
}
var init_determinePageIdOld = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/determinePageIdOld.js"() {
    init_utils();
    __name(determinePageIdOld, "determinePageIdOld");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/fileTypes.js
function determineFileType(filePath) {
  {
    const isCSS = filePath.endsWith(".css");
    if (isCSS) {
      return ".css";
    }
  }
  assert(isScriptFile(filePath), filePath);
  const fileName = filePath.split("/").slice(-1)[0];
  const parts = fileName.split(".");
  const suffix1 = parts.slice(-3)[0];
  const suffix2 = parts.slice(-2)[0];
  if (suffix2 === "page") {
    return ".page";
  }
  assert(suffix1 === "page", filePath);
  if (suffix2 === "server") {
    return ".page.server";
  }
  if (suffix2 === "client") {
    return ".page.client";
  }
  if (suffix2 === "route") {
    return ".page.route";
  }
  assert(false, filePath);
}
var fileTypes;
var init_fileTypes = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/fileTypes.js"() {
    init_utils();
    init_isScriptFile();
    fileTypes = [
      ".page",
      ".page.server",
      ".page.route",
      ".page.client",
      // New type `.page.css`/`.page.server.css`/`.page.client.css` for `extensions[number].pageFileDist`.
      //  - Extensions using `pageFileDist` are expected to use a bundler that generates a `.css` colocated next to the original `.page.js` file (e.g. `/renderer/_default.page.server.css` for `/renderer/_default.page.server.js`.
      //  - Since these `.page.css` files Bundlers We can therefore expect that there isn't any `.page.server.sass`/...
      ".css"
    ];
    __name(determineFileType, "determineFileType");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/getPageFileObject.js
function getPageFileObject(filePath) {
  const isRelevant = /* @__PURE__ */ __name((pageId) => pageFile.pageId === pageId || pageFile.isDefaultPageFile && (isRendererFilePath(pageFile.filePath) || isAncestorDefaultPage(pageId, pageFile.filePath)), "isRelevant");
  const fileType = determineFileType(filePath);
  const isEnv = /* @__PURE__ */ __name((env2) => {
    assert(fileType !== ".page.route");
    if (env2 === "CLIENT_ONLY") {
      return fileType === ".page.client" || fileType === ".css";
    }
    if (env2 === "SERVER_ONLY") {
      return fileType === ".page.server";
    }
    if (env2 === "CLIENT_AND_SERVER") {
      return fileType === ".page";
    }
    assert(false);
  }, "isEnv");
  const pageFile = {
    filePath,
    fileType,
    isEnv,
    isRelevant,
    isDefaultPageFile: isDefaultFilePath(filePath),
    isRendererPageFile: fileType !== ".css" && isDefaultFilePath(filePath) && isRendererFilePath(filePath),
    isErrorPageFile: isErrorPageId(filePath, false),
    pageId: determinePageIdOld(filePath)
  };
  return pageFile;
}
function isDefaultFilePath(filePath) {
  if (isErrorPageId(filePath, false)) {
    return false;
  }
  return filePath.includes("/_default");
}
function isRendererFilePath(filePath) {
  return filePath.includes("/renderer/");
}
function isAncestorDefaultPage(pageId, defaultPageFilePath) {
  assert(!pageId.endsWith("/"));
  assert(!defaultPageFilePath.endsWith("/"));
  assert(isDefaultFilePath(defaultPageFilePath));
  const defaultPageDir = slice(defaultPageFilePath.split("/"), 0, -1).filter((filePathSegment) => filePathSegment !== "_default").join("/");
  return pageId.startsWith(defaultPageDir);
}
var init_getPageFileObject = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/getPageFileObject.js"() {
    init_determinePageIdOld();
    init_error_page();
    init_utils();
    init_fileTypes();
    __name(getPageFileObject, "getPageFileObject");
    __name(isDefaultFilePath, "isDefaultFilePath");
    __name(isRendererFilePath, "isRendererFilePath");
    __name(isAncestorDefaultPage, "isAncestorDefaultPage");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/parseVirtualFileExportsGlobalEntry.js
function parseVirtualFileExportsGlobalEntry(virtualFileExportsGlobalEntry2) {
  assert(hasProp(virtualFileExportsGlobalEntry2, "pageFilesLazy", "object"));
  assert(hasProp(virtualFileExportsGlobalEntry2, "pageFilesEager", "object"));
  assert(hasProp(virtualFileExportsGlobalEntry2, "pageFilesExportNamesLazy", "object"));
  assert(hasProp(virtualFileExportsGlobalEntry2, "pageFilesExportNamesEager", "object"));
  assert(hasProp(virtualFileExportsGlobalEntry2.pageFilesLazy, ".page"));
  assert(hasProp(virtualFileExportsGlobalEntry2.pageFilesLazy, ".page.client") || hasProp(virtualFileExportsGlobalEntry2.pageFilesLazy, ".page.server"));
  assert(hasProp(virtualFileExportsGlobalEntry2, "pageFilesList", "string[]"));
  assert(hasProp(virtualFileExportsGlobalEntry2, "pageConfigsSerialized"));
  assert(hasProp(virtualFileExportsGlobalEntry2, "pageConfigGlobalSerialized"));
  const { pageConfigsSerialized: pageConfigsSerialized2, pageConfigGlobalSerialized: pageConfigGlobalSerialized2 } = virtualFileExportsGlobalEntry2;
  assertPageConfigsSerialized(pageConfigsSerialized2);
  assertPageConfigGlobalSerialized(pageConfigGlobalSerialized2);
  const { pageConfigs, pageConfigGlobal } = parsePageConfigsSerialized(pageConfigsSerialized2, pageConfigGlobalSerialized2);
  const pageFilesMap = {};
  parseGlobResult(virtualFileExportsGlobalEntry2.pageFilesLazy).forEach(({ filePath, pageFile, globValue }) => {
    pageFile = pageFilesMap[filePath] = pageFilesMap[filePath] ?? pageFile;
    const loadModule = globValue;
    assertLoadModule(loadModule);
    pageFile.loadFile = async () => {
      if (!("fileExports" in pageFile)) {
        pageFile.fileExports = await loadModule();
        assertExportValues(pageFile);
      }
    };
  });
  parseGlobResult(virtualFileExportsGlobalEntry2.pageFilesExportNamesLazy).forEach(({ filePath, pageFile, globValue }) => {
    pageFile = pageFilesMap[filePath] = pageFilesMap[filePath] ?? pageFile;
    const loadModule = globValue;
    assertLoadModule(loadModule);
    pageFile.loadExportNames = async () => {
      if (!("exportNames" in pageFile)) {
        const moduleExports = await loadModule();
        assert(hasProp(moduleExports, "exportNames", "string[]"), pageFile.filePath);
        pageFile.exportNames = moduleExports.exportNames;
      }
    };
  });
  parseGlobResult(virtualFileExportsGlobalEntry2.pageFilesEager).forEach(({ filePath, pageFile, globValue }) => {
    pageFile = pageFilesMap[filePath] = pageFilesMap[filePath] ?? pageFile;
    const moduleExports = globValue;
    assert(isObject(moduleExports));
    pageFile.fileExports = moduleExports;
  });
  parseGlobResult(virtualFileExportsGlobalEntry2.pageFilesExportNamesEager).forEach(({ filePath, pageFile, globValue }) => {
    pageFile = pageFilesMap[filePath] = pageFilesMap[filePath] ?? pageFile;
    const moduleExports = globValue;
    assert(isObject(moduleExports));
    assert(hasProp(moduleExports, "exportNames", "string[]"), pageFile.filePath);
    pageFile.exportNames = moduleExports.exportNames;
  });
  virtualFileExportsGlobalEntry2.pageFilesList.forEach((filePath) => {
    pageFilesMap[filePath] = pageFilesMap[filePath] ?? getPageFileObject(filePath);
  });
  const pageFilesAll = Object.values(pageFilesMap);
  pageFilesAll.forEach(({ filePath }) => {
    assert(!filePath.includes("\\"));
  });
  return { pageFilesAll, pageConfigs, pageConfigGlobal };
}
function parseGlobResult(globObject) {
  const ret = [];
  Object.entries(globObject).forEach(([fileType, globFiles]) => {
    cast(fileType);
    assert(fileTypes.includes(fileType));
    assert(isObject(globFiles));
    Object.entries(globFiles).forEach(([filePath, globValue]) => {
      const pageFile = getPageFileObject(filePath);
      assert(pageFile.fileType === fileType);
      ret.push({ filePath, pageFile, globValue });
    });
  });
  return ret;
}
function assertLoadModule(globValue) {
  assert(isCallable(globValue));
}
function assertPageConfigsSerialized(pageConfigsSerialized2) {
  assert(isArray(pageConfigsSerialized2));
  pageConfigsSerialized2.forEach((pageConfigSerialized) => {
    assert(isObject(pageConfigSerialized));
    assert(hasProp(pageConfigSerialized, "pageId", "string"));
    assert(hasProp(pageConfigSerialized, "routeFilesystem"));
    assert(hasProp(pageConfigSerialized, "configValuesSerialized"));
  });
}
function assertPageConfigGlobalSerialized(pageConfigGlobalSerialized2) {
  assert(hasProp(pageConfigGlobalSerialized2, "configValuesSerialized"));
}
var init_parseVirtualFileExportsGlobalEntry = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageFiles/parseVirtualFileExportsGlobalEntry.js"() {
    init_utils();
    init_assert_exports_old_design();
    init_getPageFileObject();
    init_fileTypes();
    init_parsePageConfigsSerialized();
    __name(parseVirtualFileExportsGlobalEntry, "parseVirtualFileExportsGlobalEntry");
    __name(parseGlobResult, "parseGlobResult");
    __name(assertLoadModule, "assertLoadModule");
    __name(assertPageConfigsSerialized, "assertPageConfigsSerialized");
    __name(assertPageConfigGlobalSerialized, "assertPageConfigGlobalSerialized");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/createGlobalContextShared.js
async function createGlobalContextShared(virtualFileExportsGlobalEntry2, globalObject24, addGlobalContext2, addGlobalContextTmp2, addGlobalContextAsync2) {
  const { previousCreateGlobalContextPromise } = globalObject24;
  const { promise, resolve } = genPromise({
    // Avoid this Cloudflare Worker error:
    // ```console
    // Error: Disallowed operation called within global scope. Asynchronous I/O (ex: fetch() or connect()), setting a timeout, and generating random values are not allowed within global scope. To fix this error, perform this operation within a handler.
    // ```
    timeout: null
  });
  globalObject24.previousCreateGlobalContextPromise = promise;
  if (previousCreateGlobalContextPromise) {
    assert(globalObject24.globalContext);
    await previousCreateGlobalContextPromise;
  }
  const globalContext = createGlobalContextBase(virtualFileExportsGlobalEntry2);
  let isNewGlobalContext;
  if (!globalObject24.globalContext) {
    globalObject24.globalContext = globalContext;
    isNewGlobalContext = false;
  } else {
    isNewGlobalContext = true;
  }
  if (addGlobalContext2 && // TO-DO/next-major-release: remove
  globalContext._pageConfigs.length > 0) {
    const globalContextAdded = addGlobalContext2?.(globalContext);
    objectAssign(globalContext, globalContextAdded);
  } else {
    const globalContextAdded = await addGlobalContextTmp2?.(globalContext);
    objectAssign(globalContext, globalContextAdded);
  }
  {
    const globalContextAddedAsync = await addGlobalContextAsync2?.(globalContext);
    objectAssign(globalContext, globalContextAddedAsync);
  }
  const onCreateGlobalContextHooks = getHookFromPageConfigGlobalCumulative(globalContext._pageConfigGlobal, "onCreateGlobalContext");
  let hooksCalled = false;
  if (!hooksAreEqual(globalObject24.onCreateGlobalContextHooks ?? [], onCreateGlobalContextHooks)) {
    globalObject24.onCreateGlobalContextHooks = onCreateGlobalContextHooks;
    await execHookGlobal("onCreateGlobalContext", globalContext._pageConfigGlobal, null, globalContext, prepareGlobalContextForPublicUsage);
    hooksCalled = true;
  }
  if (isNewGlobalContext) {
    if (hooksCalled) {
      objectReplace(globalObject24.globalContext, globalContext);
    } else {
      objectAssign(globalObject24.globalContext, globalContext, true);
    }
  }
  resolve();
  return globalObject24.globalContext;
}
function createGlobalContextBase(virtualFileExportsGlobalEntry2) {
  const { pageFilesAll, allPageIds, pageConfigs, pageConfigGlobal, vikeConfigPublicGlobal, vikeConfigPublicPagesEager } = getConfigsAll(virtualFileExportsGlobalEntry2);
  const globalContext = {
    /**
     * Useful for distinguishing `globalContext` from other objects and narrowing down TypeScript unions.
     *
     * https://vike.dev/globalContext#typescript
     */
    isGlobalContext: true,
    _isOriginalObject: true,
    _virtualFileExportsGlobalEntry: virtualFileExportsGlobalEntry2,
    _pageFilesAll: pageFilesAll,
    _pageConfigs: pageConfigs,
    _pageConfigGlobal: pageConfigGlobal,
    _allPageIds: allPageIds,
    _vikeConfigPublicGlobal: vikeConfigPublicGlobal,
    config: vikeConfigPublicGlobal.config,
    pages: vikeConfigPublicPagesEager
  };
  changeEnumerable(globalContext, "_isOriginalObject", false);
  return globalContext;
}
function getConfigsAll(virtualFileExportsGlobalEntry2) {
  const { pageFilesAll, pageConfigs, pageConfigGlobal } = parseVirtualFileExportsGlobalEntry(virtualFileExportsGlobalEntry2);
  const allPageIds = getAllPageIds(pageFilesAll, pageConfigs);
  const vikeConfigPublicGlobal = resolveVikeConfigPublicGlobal({
    pageConfigGlobalValues: pageConfigGlobal.configValues
  });
  const vikeConfigPublicPagesEager = Object.fromEntries(pageConfigs.map((pageConfig) => {
    return resolveVikeConfigPublicPageEagerLoaded(pageConfigGlobal.configValues, pageConfig, pageConfig.configValues);
  }));
  return {
    pageFilesAll,
    allPageIds,
    pageConfigs,
    pageConfigGlobal,
    vikeConfigPublicGlobal,
    vikeConfigPublicPagesEager
  };
}
function getAllPageIds(pageFilesAll, pageConfigs) {
  const fileIds = pageFilesAll.filter(({ isDefaultPageFile }) => !isDefaultPageFile).map(({ pageId }) => pageId);
  const allPageIds = unique(fileIds);
  const allPageIds2 = pageConfigs.map((p2) => p2.pageId);
  return [...allPageIds, ...allPageIds2];
}
function hooksAreEqual(hooks1, hooks2) {
  const hooksFn1 = hooks1.map((hook2) => hook2.hookFn);
  const hooksFn2 = hooks2.map((hook2) => hook2.hookFn);
  return hooksFn1.every((hook2) => hooksFn2.includes(hook2)) && //
  hooksFn2.every((hook2) => hooksFn1.includes(hook2));
}
var init_createGlobalContextShared = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/createGlobalContextShared.js"() {
    init_utils();
    init_parseVirtualFileExportsGlobalEntry();
    init_resolveVikeConfigPublic();
    init_execHook();
    init_prepareGlobalContextForPublicUsage();
    init_getHook();
    __name(createGlobalContextShared, "createGlobalContextShared");
    __name(createGlobalContextBase, "createGlobalContextBase");
    __name(getConfigsAll, "getConfigsAll");
    __name(getAllPageIds, "getAllPageIds");
    __name(hooksAreEqual, "hooksAreEqual");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/getVikeConfigError.js
function setVikeConfigError(val) {
  if ("errorRuntime" in val)
    globalObject20.errorRuntime = val.errorRuntime;
  if ("errorBuild" in val)
    globalObject20.errorBuild = val.errorBuild;
}
function getVikeConfigError() {
  return globalObject20.errorBuild || globalObject20.errorRuntime;
}
function getVikeConfigErrorBuild() {
  return globalObject20.errorBuild;
}
var globalObject20;
var init_getVikeConfigError = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/shared/getVikeConfigError.js"() {
    init_utils2();
    globalObject20 = getGlobalObject("node/shared/getVikeConfigError.ts", {
      errorRuntime: false,
      errorBuild: false
    });
    __name(setVikeConfigError, "setVikeConfigError");
    __name(getVikeConfigError, "getVikeConfigError");
    __name(getVikeConfigErrorBuild, "getVikeConfigErrorBuild");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/api/context.js
function getVikeApiOperation() {
  return globalObject21.vikeApiOperation ?? null;
}
var globalObject21;
var init_context2 = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/api/context.js"() {
    init_utils3();
    globalObject21 = getGlobalObject("api/context.ts", {});
    __name(getVikeApiOperation, "getVikeApiOperation");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/globalContext.js
async function getGlobalContextServerInternal() {
  assert(globalObject22.isInitialized);
  assertGlobalContextIsDefined();
  if (!isProd())
    await globalObject22.waitForUserFilesUpdate;
  const { globalContext } = globalObjectTyped;
  assertIsDefined(globalContext);
  return { globalContext };
}
function assertIsDefined(globalContext) {
  if (!globalContext) {
    debug6("globalContext", globalContext);
    debug6("assertIsDefined()", new Error().stack);
    assert(false);
  }
}
function assertGlobalContextIsDefined() {
  assertIsDefined(globalObjectTyped.globalContext);
  assert(globalObject22.globalContext);
}
async function initGlobalContext_renderPage() {
  debug6("initGlobalContext_renderPage()");
  globalObject22.isAfterFirstRenderPageCall = true;
  await initGlobalContext();
}
async function initGlobalContext() {
  const isProduction2 = isProd();
  if (!isProduction2) {
    if (isProcessSharedWithVite()) {
      await globalObject22.viteDevServerPromise;
    } else {
      assert(isNonRunnableDev());
      await updateUserFiles();
    }
    assert(globalObject22.waitForUserFilesUpdate);
    await globalObject22.waitForUserFilesUpdate;
  } else {
    await loadProdBuildEntry(globalObject22.viteConfigRuntime?.build.outDir);
  }
  assertGlobalContextIsDefined();
  globalObject22.isInitialized = true;
}
function assertViteManifest(manifest) {
  assert(isPlainObject(manifest));
}
async function loadProdBuildEntry(outDir) {
  debug6("loadProdBuildEntry()");
  if (globalObject22.globalContext) {
    debug6("loadProdBuildEntry() - already done");
    return;
  }
  if (!globalObject22.prodBuildEntry) {
    debug6("importServerProductionEntry()");
    await importServerProductionEntry({ outDir });
    if (!globalObject22.prodBuildEntry) {
      debug6("globalObject.prodBuildEntryPrevious");
      globalObject22.prodBuildEntry = globalObject22.prodBuildEntryPrevious;
    }
    assert(globalObject22.prodBuildEntry);
    assertWarning2(
      // vike-server => `inject === true`
      // vike-node => `inject === [ 'index' ]` => we don't show the warning to vike-node users (I don't remember why).
      globalObject22.buildInfo?.viteConfigRuntime.vitePluginServerEntry.inject !== true || globalObject22.isPrerendering,
      `Run the built server entry (e.g. ${picocolors_default.cyan("$ node dist/server/index.mjs")}) instead of the original server entry (e.g. ${picocolors_default.cyan("$ ts-node server/index.ts")})`,
      { onlyOnce: true }
    );
  }
  const { prodBuildEntry } = globalObject22;
  assertProdBuildEntry(prodBuildEntry);
  globalObject22.assetsManifest = prodBuildEntry.assetsManifest;
  globalObject22.buildInfo = prodBuildEntry.buildInfo;
  await createGlobalContext(prodBuildEntry.virtualFileExportsGlobalEntry);
}
async function setGlobalContext_prodBuildEntry(prodBuildEntry) {
  debug6("setGlobalContext_prodBuildEntry()");
  assertProdBuildEntry(prodBuildEntry);
  globalObject22.prodBuildEntry = prodBuildEntry;
  globalObject22.prodBuildEntryPrevious = prodBuildEntry;
  assert(globalObject22.prodBuildEntry);
  await loadProdBuildEntry();
  assertGlobalContextIsDefined();
  debug6("setGlobalContext_prodBuildEntry() - done");
}
function assertProdBuildEntry(prodBuildEntry) {
  assert(isObject(prodBuildEntry));
  assert(hasProp(prodBuildEntry, "virtualFileExportsGlobalEntry", "object"));
  const { virtualFileExportsGlobalEntry: virtualFileExportsGlobalEntry2 } = prodBuildEntry;
  assert(hasProp(prodBuildEntry, "assetsManifest", "object"));
  const { assetsManifest } = prodBuildEntry;
  assertViteManifest(assetsManifest);
  assert(hasProp(prodBuildEntry, "buildInfo", "object"));
  const { buildInfo } = prodBuildEntry;
  assertBuildInfo(buildInfo);
  checkType({ virtualFileExportsGlobalEntry: virtualFileExportsGlobalEntry2, assetsManifest, buildInfo });
}
function assertBuildInfo(buildInfo) {
  assert(isObject(buildInfo));
  assert(hasProp(buildInfo, "versionAtBuildTime", "string"));
  assertVersionAtBuildTime(buildInfo.versionAtBuildTime);
  assert(hasProp(buildInfo, "viteConfigRuntime", "object"));
  assert(hasProp(buildInfo.viteConfigRuntime, "_baseViteOriginal", "string"));
  assert(hasProp(buildInfo.viteConfigRuntime, "root", "string"));
  assert(hasProp(buildInfo.viteConfigRuntime, "build", "object"));
  assert(hasProp(buildInfo.viteConfigRuntime.build, "outDir", "string"));
  assert(hasProp(buildInfo.viteConfigRuntime, "vitePluginServerEntry", "object"));
  assert(hasProp(buildInfo, "usesClientRouter", "boolean"));
}
function assertVersionAtBuildTime(versionAtBuildTime) {
  const versionAtRuntime = PROJECT_VERSION;
  const pretty = /* @__PURE__ */ __name((version2) => picocolors_default.bold(`vike@${version2}`), "pretty");
  assertUsage(versionAtBuildTime === versionAtRuntime, `Re-build your app (you're using ${pretty(versionAtRuntime)} but your app was built with ${pretty(versionAtBuildTime)})`);
}
async function updateUserFiles() {
  debug6("updateUserFiles()");
  assert(!isProd());
  const { promise, resolve } = genPromise();
  globalObject22.waitForUserFilesUpdate = promise;
  globalObject22.waitForUserFilesUpdateResolve ?? (globalObject22.waitForUserFilesUpdateResolve = []);
  globalObject22.waitForUserFilesUpdateResolve.push(resolve);
  const onError = /* @__PURE__ */ __name((err2) => {
    if (!hasAlreadyLogged(err2)) {
      logRuntimeError(err2, null);
    }
    setVikeConfigError({ errorRuntime: { err: err2 } });
    globalObject22.vikeConfigHasRuntimeError = true;
    return { success: false };
  }, "onError");
  const onSuccess = /* @__PURE__ */ __name(() => {
    if (globalObject22.vikeConfigHasRuntimeError) {
      assert(logRuntimeInfo);
      logRuntimeInfo(vikeConfigErrorRecoverMsg, null, "error-recover");
    }
    globalObject22.vikeConfigHasRuntimeError = false;
    setVikeConfigError({ errorRuntime: false });
    globalObject22.waitForUserFilesUpdateResolve.forEach((resolve2) => resolve2());
    globalObject22.waitForUserFilesUpdateResolve = [];
    resolve();
    return { success: true };
  }, "onSuccess");
  const isOutdated = /* @__PURE__ */ __name(() => (
    // There is a newer call — let the new call supersede the old one.
    // We deliberately swallow the intermetidate state (including any potential error) — it's now outdated and has existed only for a very short period of time.
    globalObject22.waitForUserFilesUpdate !== promise || // Avoid race condition: abort if there is a new globalObject.viteDevServer (happens when vite.config.js is modified => Vite's dev server is fully reloaded).
    viteDevServer !== globalObject22.viteDevServer
  ), "isOutdated");
  const { viteDevServer } = globalObject22;
  let hasError = false;
  let virtualFileExportsGlobalEntry2;
  let err;
  if (viteDevServer) {
    assert(isRunnable(viteDevServer));
    try {
      virtualFileExportsGlobalEntry2 = await viteDevServer.ssrLoadModule(virtualFileIdGlobalEntryServer);
    } catch (err_) {
      hasError = true;
      err = err_;
    }
  } else {
    try {
      virtualFileExportsGlobalEntry2 = await __VIKE__DYNAMIC_IMPORT("virtual:vike:global-entry:server");
    } catch (err_) {
      hasError = true;
      err = err_;
    }
  }
  if (isOutdated())
    return { success: false };
  if (hasError)
    return onError(err);
  virtualFileExportsGlobalEntry2 = virtualFileExportsGlobalEntry2.default || virtualFileExportsGlobalEntry2;
  if (getVikeConfigErrorBuild()) {
    return { success: false };
  }
  try {
    await createGlobalContext(virtualFileExportsGlobalEntry2);
  } catch (err_) {
    hasError = true;
    err = err_;
  }
  if (isOutdated())
    return { success: false };
  if (hasError)
    return onError(err);
  return onSuccess();
}
async function createGlobalContext(virtualFileExportsGlobalEntry2) {
  debug6("createGlobalContext()");
  assert(!getVikeConfigErrorBuild());
  const globalContextPromise = createGlobalContextShared(virtualFileExportsGlobalEntry2, globalObject22, addGlobalContext, addGlobalContextTmp, addGlobalContextAsync);
  debug6("createGlobalContext() - done [sync]");
  assert(globalObject22.globalContext);
  const globalContext = await globalContextPromise;
  debug6("createGlobalContext() - done [async]");
  assertV1Design(
    // pageConfigs is PageConfigRuntime[] but assertV1Design() requires PageConfigBuildTime[]
    globalContext._pageConfigs.length > 0,
    globalContext._pageFilesAll
  );
  assertGlobalContextIsDefined();
  onSetupRuntime();
  return globalContext;
}
async function addGlobalContextTmp(globalContext) {
  debug6("addGlobalContextTmp()");
  const { pageRoutes, onBeforeRouteHook } = await loadPageRoutes(globalContext._pageFilesAll, globalContext._pageConfigs, globalContext._pageConfigGlobal, globalContext._allPageIds);
  return addGlobalContextCommon(globalContext, pageRoutes, onBeforeRouteHook);
}
function addGlobalContext(globalContext) {
  debug6("addGlobalContext()");
  const { pageRoutes, onBeforeRouteHook } = loadPageRoutesSync(globalContext._pageFilesAll, globalContext._pageConfigs, globalContext._pageConfigGlobal, globalContext._allPageIds);
  return addGlobalContextCommon(globalContext, pageRoutes, onBeforeRouteHook);
}
function addGlobalContextCommon(globalContext, pageRoutes, onBeforeRouteHook) {
  const globalContextBase = {
    isClientSide: false,
    _pageRoutes: pageRoutes,
    _onBeforeRouteHook: onBeforeRouteHook
  };
  const { viteDevServer, viteConfig, isPrerendering } = globalObject22;
  const isProduction2 = isProd();
  if (!isProduction2) {
    assert(globalContext);
    assert(!isPrerendering);
    return {
      ...globalContextBase,
      _isProduction: false,
      _isPrerendering: false,
      assetsManifest: null,
      _viteDevServer: viteDevServer,
      viteConfig
    };
  } else {
    assert(globalObject22.prodBuildEntry);
    assert(globalContext);
    const { buildInfo, assetsManifest } = globalObject22;
    assert(buildInfo);
    assert(assetsManifest);
    const globalContextBase2 = {
      ...globalContextBase,
      _isProduction: true,
      assetsManifest,
      _viteDevServer: null,
      _usesClientRouter: buildInfo.usesClientRouter
    };
    if (isPrerendering) {
      assert(viteConfig);
      return {
        ...globalContextBase2,
        _isPrerendering: true,
        viteConfig
      };
    } else {
      return {
        ...globalContextBase2,
        _isPrerendering: false,
        viteConfig: null
      };
    }
  }
}
async function addGlobalContextAsync(globalContext) {
  debug6("addGlobalContextAsync()");
  let { viteConfigRuntime, buildInfo } = globalObject22;
  if (!viteConfigRuntime) {
    if (buildInfo) {
      viteConfigRuntime = buildInfo.viteConfigRuntime;
    } else {
      assert(!isProcessSharedWithVite());
      assert(!isProd());
      assert(isNonRunnableDev());
      const rpc = getViteRPC();
      viteConfigRuntime = await rpc.getViteConfigRuntimeRPC();
    }
  }
  assert(viteConfigRuntime);
  return {
    viteConfigRuntime,
    ...resolveBaseRuntime(viteConfigRuntime, globalContext.config)
  };
}
function getInitialGlobalObject() {
  debug6("getInitialGlobalObject()");
  const { promise: viteDevServerPromise, resolve: viteDevServerPromiseResolve } = genPromise();
  return {
    viteDevServerPromise,
    viteDevServerPromiseResolve
  };
}
function resolveBaseRuntime(viteConfigRuntime, config) {
  const baseViteOriginal = viteConfigRuntime._baseViteOriginal;
  const baseServerUnresolved = config.baseServer ?? null;
  const baseAssetsUnresolved = config.baseAssets ?? null;
  return resolveBase(baseViteOriginal, baseServerUnresolved, baseAssetsUnresolved);
}
function isProcessSharedWithVite() {
  const yes = globalThis.__VIKE__IS_PROCESS_SHARED_WITH_VITE ?? false;
  if (yes)
    assert(!isNonRunnableDev());
  return yes;
}
function isRunnable(viteDevServer) {
  const yes = (
    // Vite 5
    !viteDevServer.environments || // Vite 6 or above
    isRunnableDevEnvironment(viteDevServer.environments.ssr)
  );
  if (yes)
    assert(!isNonRunnableDev());
  return yes;
}
function isProd() {
  const isProduction2 = isProdOptional();
  if (isProduction2 === null) {
    if (globalObject22.isAfterFirstRenderPageCall) {
      return true;
    } else {
      assert(false);
    }
  }
  return isProduction2;
}
function isProdOptional() {
  const vikeApiOperation = getVikeApiOperation()?.operation ?? null;
  const yes = (
    // setGlobalContext_prodBuildEntry() was called
    !!globalObject22.prodBuildEntry || globalObject22.isPrerendering === true || // Vike CLI & Vike API
    !!vikeApiOperation && vikeApiOperation !== "dev" || // Vite command
    globalObject22.isProductionAccordingToVite === true || // getGlobalContextAsync(isProduction)
    globalObject22.isProductionAccordingToUser === true || // vite-plugin-vercel
    globalObject22.isProductionAccordingToPhotonVercel === true
  );
  assert(typeof yes === "boolean");
  const no = !!globalObject22.viteDevServer || // Vike CLI & Vike API
  vikeApiOperation === "dev" || // Vite command
  globalObject22.isProductionAccordingToVite === false || // getGlobalContextAsync(isProduction)
  globalObject22.isProductionAccordingToUser === false || // @cloudflare/vite-plugin
  isNonRunnableDev() === true;
  assert(typeof no === "boolean");
  if (yes) {
    assert(no === false);
    return true;
  }
  if (no) {
    assert(yes === false);
    return false;
  }
  return null;
}
var debug6, globalObject22, globalObjectTyped, vikeConfigErrorRecoverMsg;
var init_globalContext2 = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/globalContext.js"() {
    init_utils3();
    init_runtime();
    init_virtualFileId2();
    init_picocolors();
    init_loadPageRoutes();
    init_assertV1Design();
    init_resolveBase();
    init_createGlobalContextShared();
    init_prepareGlobalContextForPublicUsage();
    init_loggerRuntime();
    init_getVikeConfigError();
    init_isNewError();
    init_context2();
    debug6 = createDebugger("vike:globalContext");
    globalObject22 = getGlobalObject("runtime/globalContext.ts", getInitialGlobalObject());
    globalObjectTyped = globalObject22;
    vikeConfigErrorRecoverMsg = picocolors_default.bold(picocolors_default.green("Vike config loaded"));
    assertIsNotBrowser();
    __name(getGlobalContextServerInternal, "getGlobalContextServerInternal");
    __name(assertIsDefined, "assertIsDefined");
    __name(assertGlobalContextIsDefined, "assertGlobalContextIsDefined");
    __name(initGlobalContext_renderPage, "initGlobalContext_renderPage");
    __name(initGlobalContext, "initGlobalContext");
    __name(assertViteManifest, "assertViteManifest");
    __name(loadProdBuildEntry, "loadProdBuildEntry");
    __name(setGlobalContext_prodBuildEntry, "setGlobalContext_prodBuildEntry");
    __name(assertProdBuildEntry, "assertProdBuildEntry");
    __name(assertBuildInfo, "assertBuildInfo");
    __name(assertVersionAtBuildTime, "assertVersionAtBuildTime");
    __name(updateUserFiles, "updateUserFiles");
    __name(createGlobalContext, "createGlobalContext");
    __name(addGlobalContextTmp, "addGlobalContextTmp");
    __name(addGlobalContext, "addGlobalContext");
    __name(addGlobalContextCommon, "addGlobalContextCommon");
    __name(addGlobalContextAsync, "addGlobalContextAsync");
    __name(getInitialGlobalObject, "getInitialGlobalObject");
    __name(resolveBaseRuntime, "resolveBaseRuntime");
    __name(isProcessSharedWithVite, "isProcessSharedWithVite");
    __name(isRunnable, "isRunnable");
    __name(isProd, "isProd");
    __name(isProdOptional, "isProdOptional");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageContextRequestUrl.js
var pageContextJsonFileExtension, doNotCreateExtraDirectory;
var init_getPageContextRequestUrl = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/getPageContextRequestUrl.js"() {
    init_urlToFile();
    pageContextJsonFileExtension = ".pageContext.json";
    doNotCreateExtraDirectory = false;
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/modifyUrlSameOrigin.js
function modifyUrlSameOrigin(url, modify) {
  const urlParsed = parseUrl(url, "/");
  const pathname = modify.pathname ?? urlParsed.pathnameOriginal;
  assertUsageUrlPathnameAbsolute(pathname, "modify.pathname");
  let search = modify.search === null ? "" : !modify.search ? urlParsed.searchOriginal : resolveSearch(urlParsed, modify.search);
  if (search === "?")
    search = "";
  let hash;
  if (modify.hash === null) {
    hash = "";
  } else if (modify.hash === void 0) {
    hash = urlParsed.hashOriginal ?? "";
  } else {
    hash = modify.hash;
    if (!hash.startsWith("#"))
      hash = "#" + hash;
  }
  const urlModified = createUrlFromComponents(urlParsed.origin, pathname, search, hash);
  return urlModified;
}
function resolveSearch(urlParsed, modifySearch) {
  let searchParams;
  if (modifySearch instanceof URLSearchParams) {
    searchParams = modifySearch;
  } else {
    const searchMap = objectFilter({ ...urlParsed.search, ...objectFilter(modifySearch, isNotUndefined) }, isNotNullish_keyVal);
    searchParams = new URLSearchParams(searchMap);
  }
  return "?" + searchParams.toString();
}
function isNotUndefined(arg) {
  return arg[1] !== void 0;
}
var init_modifyUrlSameOrigin = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/modifyUrlSameOrigin.js"() {
    init_utils();
    __name(modifyUrlSameOrigin, "modifyUrlSameOrigin");
    __name(resolveSearch, "resolveSearch");
    __name(isNotUndefined, "isNotUndefined");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/modifyUrl.js
function modifyUrl(url, modify) {
  url = modifyUrlSameOrigin(url, modify);
  const urlParsed = parseUrl(url, "/");
  const originParts = [
    modify.protocol ?? urlParsed.protocol ?? "",
    modify.hostname ?? urlParsed.hostname ?? ""
  ];
  const port = modify.port ?? urlParsed.port;
  if (port || port === 0) {
    originParts.push(`:${port}`);
  }
  const origin = originParts.join("");
  const urlModified = createUrlFromComponents(origin, urlParsed.pathname, urlParsed.searchOriginal, urlParsed.hashOriginal);
  return urlModified;
}
var init_modifyUrl = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/modifyUrl.js"() {
    init_modifyUrlSameOrigin();
    init_utils();
    __name(modifyUrl, "modifyUrl");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/handlePageContextRequestUrl.js
function handlePageContextRequestUrl(url) {
  const urlParsed = parseUrl(url, baseServer);
  if (!isMatch(urlParsed)) {
    return {
      isPageContextJsonRequest: false,
      urlWithoutPageContextRequestSuffix: url
    };
  } else {
    const { urlWithoutPageContextRequestSuffix, searchVikeArgs } = processUrl(urlParsed, url);
    const previousUrl = parseSearchVikeArgs(searchVikeArgs);
    return {
      /* TO-DO/soon/once: pass & use previousUrl
      isPageContextJsonRequest: { previousUrl },
      /*/
      isPageContextJsonRequest: true,
      //*/
      urlWithoutPageContextRequestSuffix
    };
  }
}
function isMatch(urlParsed) {
  const { pathnameOriginal, pathname } = urlParsed;
  assert(pathname.endsWith(pageContextJsonFileExtension) === pathnameOriginal.endsWith(pageContextJsonFileExtension));
  return pathname.endsWith(pageContextJsonFileExtension);
}
function processUrl(urlParsed, url) {
  const { pathnameOriginal, search } = urlParsed;
  assert(doNotCreateExtraDirectory === false);
  const urlSuffix = `/index${pageContextJsonFileExtension}`;
  assert(pathnameOriginal.endsWith(urlSuffix), { url });
  let pathnameModified = slice(pathnameOriginal, 0, -1 * urlSuffix.length);
  if (pathnameModified === "")
    pathnameModified = "/";
  const searchVikeArgs = search?._vike;
  const urlWithoutPageContextRequestSuffix = modifyUrl(url, {
    pathname: pathnameModified,
    search: {
      _vike: searchVikeArgs ? null : void 0
    }
  });
  return {
    searchVikeArgs,
    urlWithoutPageContextRequestSuffix
  };
}
function parseSearchVikeArgs(searchVikeArgs) {
  const args = {
    previousUrl: null
  };
  if (searchVikeArgs) {
    const parsed = JSON.parse(searchVikeArgs);
    assert(isObject(parsed));
    if ("previousUrl" in parsed) {
      assert(hasProp(parsed, "previousUrl", "string"));
      args.previousUrl = parsed.previousUrl;
    }
  }
  return args;
}
var init_handlePageContextRequestUrl = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/handlePageContextRequestUrl.js"() {
    init_getPageContextRequestUrl();
    init_modifyUrl();
    init_utils3();
    __name(handlePageContextRequestUrl, "handlePageContextRequestUrl");
    __name(isMatch, "isMatch");
    __name(processUrl, "processUrl");
    __name(parseSearchVikeArgs, "parseSearchVikeArgs");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/assertArguments.js
function assertArguments(...args) {
  const prefix3 = `${picocolors_default.code("renderPage(pageContextInit)")} (https://vike.dev/renderPage)`;
  const pageContextInit = args[0];
  assertUsage(pageContextInit !== void 0 && pageContextInit !== null, prefix3 + ` argument ${picocolors_default.cyan("pageContextInit")} is missing`, { showStackTrace: true });
  const len = args.length;
  assertUsage(len === 1, `${prefix3} called with ${len} arguments but renderPage() accepts only one argument.'`, {
    showStackTrace: true
  });
  assertUsage(isObject(pageContextInit), `${prefix3} called with ${picocolors_default.code(`typeof pageContextInit === ${JSON.stringify(typeof pageContextInit)}`)} but ${picocolors_default.code("pageContextInit")} should be an object.`, { showStackTrace: true });
  if ("url" in pageContextInit) {
    assertWarning2(false, "`pageContextInit.url` has been renamed to `pageContextInit.urlOriginal`: replace `renderPage({ url })` with `renderPage({ urlOriginal })`. (See https://vike.dev/migration/0.4.23 for more information.)", { showStackTrace: true, onlyOnce: true });
    pageContextInit.urlOriginal = pageContextInit.url;
    delete pageContextInit.url;
  }
  assert(!("url" in pageContextInit));
  assertUsage(hasProp(pageContextInit, "urlOriginal"), prefix3 + ` ${picocolors_default.cyan("pageContextInit")} is missing the property ${picocolors_default.cyan("pageContextInit.urlOriginal")}`, { showStackTrace: true });
  const { urlOriginal } = pageContextInit;
  assertUsage(typeof urlOriginal === "string", prefix3 + ` ${picocolors_default.cyan("pageContextInit.urlOriginal")} should be a string but ${picocolors_default.cyan(`typeof pageContextInit.urlOriginal === ${JSON.stringify(typeof urlOriginal)}`)}`, { showStackTrace: true });
  assertUsage(urlOriginal.startsWith("/") || urlOriginal.startsWith("https://") || urlOriginal.startsWith("http://"), prefix3 + ` ${picocolors_default.cyan("pageContextInit.urlOriginal")} should start with ${picocolors_default.cyan("/")} (e.g. ${picocolors_default.cyan("/product/42")}), ${picocolors_default.cyan("http://")}, or ${picocolors_default.cyan("https://")} (e.g. ${picocolors_default.cyan("https://example.com/product/42")}), but ${picocolors_default.cyan(`pageContextInit.urlOriginal === ${JSON.stringify(urlOriginal)}`)}`, { showStackTrace: true });
  const urlOriginalWithoutOrigin = urlOriginal.startsWith("http") ? urlOriginal : "http://fake-origin.example.org" + urlOriginal;
  try {
    new URL(urlOriginalWithoutOrigin);
  } catch (err) {
    assertUsage(false, prefix3 + ` ${picocolors_default.cyan("pageContextInit.urlOriginal")} should be a URL but ${picocolors_default.cyan(`pageContextInit.urlOriginal === ${JSON.stringify(urlOriginal)}`)}`, { showStackTrace: true });
  }
}
var init_assertArguments = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/assertArguments.js"() {
    init_utils3();
    init_picocolors();
    __name(assertArguments, "assertArguments");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/noRouteMatch.js
var noRouteMatch;
var init_noRouteMatch = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/noRouteMatch.js"() {
    noRouteMatch = "doesn't match the route of any of your pages";
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/log404/index.js
async function log404(pageContext) {
  const { urlPathname } = pageContext;
  const pageRoutes = pageContext._globalContext._pageRoutes;
  assertUsage(pageRoutes.length > 0, "No page found.");
  const globalContext = pageContext._globalContext;
  if (!globalContext._isProduction && !isFileRequest(urlPathname) && !pageContext.isClientSideNavigation) {
    const routesInfo = getRoutesInfo(pageRoutes);
    let msg = `URL ${picocolors_default.cyan(urlPathname)} ${noRouteMatch}`;
    const outro = "See https://vike.dev/routing for more information about routing.";
    if (!routesInfo) {
      msg = `${msg}. ${picocolors_default.dim(outro)}`;
    } else {
      msg = `${msg}:
${routesInfo}
${outro}`;
    }
    assertInfo(false, msg, { onlyOnce: false });
  }
}
function getRoutesInfo(pageRoutes) {
  const entries = pageRoutes.map((pageRoute) => {
    let routeStr;
    let routeTypeSrc;
    let routeDefinedBy;
    if (pageRoute.routeType === "FILESYSTEM") {
      assert(pageRoute.routeFilesystemDefinedBy);
      routeDefinedBy = pageRoute.routeFilesystemDefinedBy;
    } else {
      assert(pageRoute.routeDefinedAtString);
      routeDefinedBy = pageRoute.routeDefinedAtString;
    }
    if (pageRoute.routeType === "STRING") {
      routeStr = pageRoute.routeString;
      routeTypeSrc = "Route String";
    } else if (pageRoute.routeType === "FUNCTION") {
      routeStr = String(pageRoute.routeFunction);
      routeTypeSrc = "Route Function";
    } else {
      routeStr = pageRoute.routeString;
      routeTypeSrc = "Filesystem Route";
    }
    assert(routeStr && routeTypeSrc && routeDefinedBy);
    return { routeStr, routeTypeSrc, routeDefinedBy };
  }).sort((e1, e2) => {
    if (e1.routeTypeSrc !== "Route Function" && e2.routeTypeSrc === "Route Function") {
      return -1;
    }
    if (e1.routeTypeSrc === "Route Function" && e2.routeTypeSrc !== "Route Function") {
      return 1;
    }
    return compareString(e1.routeStr, e2.routeStr);
  });
  const linesContent = [
    {
      routeStr: "ROUTE",
      routeTypeSrc: "TYPE",
      routeDefinedBy: "DEFINED BY"
    },
    ...entries
  ];
  const terminalWidth = getTerminalWidth() || 134;
  let width2 = Math.max(...linesContent.map(({ routeTypeSrc }) => stripAnsi2(routeTypeSrc).length));
  let width3 = Math.max(...linesContent.map(({ routeDefinedBy }) => stripAnsi2(routeDefinedBy).length));
  const width1_max = terminalWidth - width3 - width2 - // Total width of table border & padding
  10;
  if (width1_max < 10)
    return null;
  linesContent.forEach((lineContent) => {
    let { routeStr } = lineContent;
    if (lineContent.routeTypeSrc === "Route Function") {
      routeStr = truncateRouteFunction(routeStr, width1_max);
      assert(stripAnsi2(routeStr).length <= width1_max);
    }
    lineContent.routeStr = routeStr;
  });
  let width1 = Math.max(...linesContent.map(({ routeStr }) => stripAnsi2(routeStr).length));
  if (width1 > width1_max)
    return null;
  let lines = linesContent.map(({ routeStr, routeTypeSrc, routeDefinedBy }, i) => {
    let cell1 = padEnd(routeStr, width1 + (stripAnsi2(routeStr).length - stripAnsi2(routeStr).length));
    let cell2 = padEnd(routeTypeSrc, width2);
    let cell3 = padEnd(routeDefinedBy, width3);
    const isHeader = i === 0;
    if (isHeader) {
      cell1 = picocolors_default.dim(cell1);
      cell2 = picocolors_default.dim(cell2);
      cell3 = picocolors_default.dim(cell3);
    }
    let line = [cell1, cell2, cell3].join(picocolors_default.dim(" \u2502 "));
    line = picocolors_default.dim("\u2502 ") + line + picocolors_default.dim(" \u2502");
    return line;
  });
  width1 = width1 + 2;
  width2 = width2 + 2;
  width3 = width3 + 2;
  lines = [
    picocolors_default.dim(`\u250C${"\u2500".repeat(width1)}\u252C${"\u2500".repeat(width2)}\u252C${"\u2500".repeat(width3)}\u2510`),
    lines[0],
    picocolors_default.dim(`\u251C${"\u2500".repeat(width1)}\u253C${"\u2500".repeat(width2)}\u253C${"\u2500".repeat(width3)}\u2524`),
    ...lines.slice(1),
    picocolors_default.dim(`\u2514${"\u2500".repeat(width1)}\u2534${"\u2500".repeat(width2)}\u2534${"\u2500".repeat(width3)}\u2518`)
  ];
  lines.forEach((line) => {
    assert(stripAnsi2(line).length <= terminalWidth);
  });
  return lines.join("\n");
}
function truncateRouteFunction(routeStr, lenMax) {
  routeStr = stripAnsi2(routeStr);
  routeStr = removeNonAscii(routeStr);
  routeStr = routeStr.split(/\s/).filter(Boolean).join(" ");
  routeStr = truncateString(routeStr, lenMax);
  return routeStr;
}
function padEnd(str, width) {
  const padWidth = Math.max(0, width - stripAnsi2(str).length);
  return str + "".padEnd(padWidth, " ");
}
function removeNonAscii(str) {
  return str.replace(/[^\x00-\x7F]/g, "");
}
function isFileRequest(urlPathname) {
  assert(urlPathname.startsWith("/"));
  const paths2 = urlPathname.split("/");
  const lastPath = paths2[paths2.length - 1];
  assert(typeof lastPath === "string");
  const parts = lastPath.split(".");
  if (parts.length < 2) {
    return false;
  }
  const fileExtension = parts[parts.length - 1];
  assert(typeof fileExtension === "string");
  return /^[a-z0-9]+$/.test(fileExtension);
}
var init_log404 = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/log404/index.js"() {
    init_noRouteMatch();
    init_utils3();
    init_picocolors();
    __name(log404, "log404");
    __name(getRoutesInfo, "getRoutesInfo");
    __name(truncateRouteFunction, "truncateRouteFunction");
    __name(padEnd, "padEnd");
    __name(removeNonAscii, "removeNonAscii");
    __name(isFileRequest, "isFileRequest");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/handleErrorWithoutErrorPage.js
async function handleErrorWithoutErrorPage(pageContext) {
  assert(pageContext.pageId === null);
  assert(pageContext.errorWhileRendering || pageContext.is404);
  {
    const isV1 = pageContext._globalContext._pageConfigs.length > 0;
    await warnMissingErrorPage(isV1, pageContext._globalContext._isProduction);
  }
  if (!pageContext.isClientSideNavigation) {
    const httpResponse = createHttpResponseError(pageContext);
    objectAssign(pageContext, { httpResponse });
    return pageContext;
  } else {
    const __getPageAssets = /* @__PURE__ */ __name(async () => [], "__getPageAssets");
    objectAssign(pageContext, { __getPageAssets });
    const httpResponse = await createHttpResponsePage(stringify({ serverSideError: true }), null, pageContext);
    objectAssign(pageContext, { httpResponse });
    return pageContext;
  }
}
async function warnMissingErrorPage(isV1, isProduction2) {
  if (!isProduction2) {
    const msg = [
      `No ${isV1 ? "error page" : picocolors_default.cyan("_error.page.js")} found,`,
      "we recommend defining one",
      "https://vike.dev/error-page"
    ].join(" ");
    assertWarning2(false, msg, { onlyOnce: true });
  }
}
var init_handleErrorWithoutErrorPage = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/handleErrorWithoutErrorPage.js"() {
    init_stringify();
    init_utils3();
    init_createHttpResponse();
    init_picocolors();
    __name(handleErrorWithoutErrorPage, "handleErrorWithoutErrorPage");
    __name(warnMissingErrorPage, "warnMissingErrorPage");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/resolveUrlPathname.js
function resolveUrlPathname(routeString, routeParams) {
  let parts = [{ val: routeString, type: "ROUTE_STRING" }];
  Object.entries(routeParams).forEach(([key, val]) => {
    if (key.startsWith("*")) {
      assert(key === "*" || /\d+/.test(key.slice(1)));
      assertUsage(key === "*", "Resolving URL with multiple globs isn't implemented yet");
    } else {
      key = `@${key}`;
    }
    parts = parts.map((part) => {
      if (part.type === "URL") {
        return part;
      } else {
        return part.val.split(key).map((rest, i) => {
          const partURL = { val, type: "URL" };
          const partRouteString = { val: rest, type: "ROUTE_STRING" };
          return i === 0 ? [partRouteString] : [partURL, partRouteString];
        }).flat();
      }
    }).flat();
  });
  const urlPathname = parts.map((p2) => p2.val).join("");
  return urlPathname;
}
var init_resolveUrlPathname = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/shared/route/resolveUrlPathname.js"() {
    init_assertIsNotBrowser();
    init_utils();
    assertIsNotBrowser();
    __name(resolveUrlPathname, "resolveUrlPathname");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/resolveRedirects.js
function resolveRedirects(redirectsAll, urlPathname) {
  const redirects = merge(redirectsAll);
  for (const [urlSource, urlTarget] of Object.entries(redirects)) {
    const urlResolved = resolveRouteStringRedirect(urlSource, urlTarget, urlPathname);
    if (urlResolved)
      return urlResolved;
  }
  return null;
}
function resolveRouteStringRedirect(urlSource, urlTarget, urlPathname) {
  assertRedirect(urlSource, urlTarget);
  const match = resolveRouteString(urlSource, urlPathname);
  if (!match)
    return null;
  const urlResolved = resolveUrlPathname(urlTarget, match.routeParams);
  if (urlResolved === urlPathname)
    return null;
  assert(isUrlRedirectTarget(urlResolved));
  return urlResolved;
}
function assertRedirect(urlSource, urlTarget) {
  assertRouteString(urlSource, `${redirectsErrPrefix} Invalid`);
  assertUsageUrlRedirectTarget(urlTarget, `${redirectsErrPrefix} The URL redirection target`, true);
  assertParams(urlSource, urlTarget);
}
function assertParams(urlSource, urlTarget) {
  const routeSegments = urlTarget.split("/");
  routeSegments.forEach((routeSegment) => {
    if (routeSegment.startsWith("@") || routeSegment.startsWith("*")) {
      const segments = urlSource.split("/");
      assertUsage(segments.includes(routeSegment), `${redirectsErrPrefix} The redirection source URL ${picocolors_default.string(urlSource)} is missing the URL parameter ${picocolors_default.string(routeSegment)} used by the redirection target URL ${picocolors_default.string(urlTarget)}`);
    }
  });
}
function merge(objs) {
  const obj = {};
  objs.forEach((e2) => {
    Object.assign(obj, e2);
  });
  return obj;
}
var redirectsErrPrefix;
var init_resolveRedirects = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage/resolveRedirects.js"() {
    init_assertIsNotBrowser();
    init_utils();
    init_resolveUrlPathname();
    init_resolveRouteString();
    init_picocolors();
    assertIsNotBrowser();
    redirectsErrPrefix = "[+redirects]";
    __name(resolveRedirects, "resolveRedirects");
    __name(resolveRouteStringRedirect, "resolveRouteStringRedirect");
    __name(assertRedirect, "assertRedirect");
    __name(assertParams, "assertParams");
    __name(merge, "merge");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage.js
async function renderPage(pageContextInit) {
  assertArguments(...arguments);
  assert(hasProp(pageContextInit, "urlOriginal", "string"));
  assertIsUrl(pageContextInit.urlOriginal);
  onSetupRuntime();
  const pageContextSkipRequest = getPageContextSkipRequest(pageContextInit);
  if (pageContextSkipRequest)
    return pageContextSkipRequest;
  const httpRequestId = getRequestId();
  const urlOriginalPretty = getUrlPretty(pageContextInit.urlOriginal);
  logHttpRequest(urlOriginalPretty, httpRequestId);
  const { pageContextReturn } = await globalObject23.asyncHookWrapper(httpRequestId, () => renderPagePrepare(pageContextInit, httpRequestId));
  logHttpResponse(urlOriginalPretty, httpRequestId, pageContextReturn);
  checkType(pageContextReturn);
  assert(pageContextReturn.httpResponse);
  return pageContextReturn;
}
function getFallbackAsyncHookWrapper() {
  return async (_httpRequestId, ret) => ({
    pageContextReturn: await ret()
  });
}
async function renderPagePrepare(pageContextInit, httpRequestId) {
  {
    const vikeConfigError = getVikeConfigError();
    if (vikeConfigError) {
      return getPageContextInvalidVikeConfig(vikeConfigError.err, pageContextInit, httpRequestId);
    }
  }
  try {
    await initGlobalContext_renderPage();
  } catch (err) {
    assert(!isAbortError(err));
    logRuntimeError(err, httpRequestId);
    const pageContextWithError = getPageContextHttpResponseErrorWithoutGlobalContext(err, pageContextInit);
    return pageContextWithError;
  }
  {
    const vikeConfigError = getVikeConfigError();
    if (vikeConfigError) {
      return getPageContextInvalidVikeConfig(vikeConfigError.err, pageContextInit, httpRequestId);
    } else {
    }
  }
  const { globalContext } = await getGlobalContextServerInternal();
  const pageContextBegin = getPageContextBegin(pageContextInit, globalContext, httpRequestId);
  {
    const pageContextHttpResponse = await checkBaseUrl(pageContextBegin, globalContext);
    if (pageContextHttpResponse)
      return pageContextHttpResponse;
  }
  {
    const pageContextHttpResponse = await normalizeUrl(pageContextBegin, globalContext, httpRequestId);
    if (pageContextHttpResponse)
      return pageContextHttpResponse;
  }
  {
    const pageContextHttpResponse = await getPermanentRedirect(pageContextBegin, globalContext, httpRequestId);
    if (pageContextHttpResponse)
      return pageContextHttpResponse;
  }
  return await renderPageAlreadyPrepared(pageContextBegin, globalContext, httpRequestId, []);
}
async function renderPageAlreadyPrepared(pageContextBegin, globalContext, httpRequestId, pageContextsFromRewrite) {
  const pageContextNominalPageBegin = forkPageContext(pageContextBegin);
  assertNoInfiniteAbortLoop(
    pageContextsFromRewrite.length,
    // There doesn't seem to be a way to count the number of HTTP redirects (vike don't have access to the HTTP request headers/cookies)
    // https://stackoverflow.com/questions/9683007/detect-infinite-http-redirect-loop-on-server-side
    0
  );
  let pageContextNominalPageSuccess;
  const pageContextFromAllRewrites = getPageContextFromAllRewrites(pageContextsFromRewrite);
  assert(pageContextFromAllRewrites._urlRewrite === null || typeof pageContextFromAllRewrites._urlRewrite === "string");
  objectAssign(pageContextNominalPageBegin, pageContextFromAllRewrites);
  let errNominalPage;
  {
    try {
      pageContextNominalPageSuccess = await renderPageNominal(pageContextNominalPageBegin);
    } catch (err) {
      errNominalPage = err;
      assert(errNominalPage);
      logRuntimeError(errNominalPage, httpRequestId);
    }
    if (!errNominalPage) {
      assert(pageContextNominalPageSuccess === pageContextNominalPageBegin);
    }
  }
  if (pageContextNominalPageSuccess && "is404" in pageContextNominalPageSuccess && pageContextNominalPageSuccess.is404 === true) {
    await log404(pageContextNominalPageSuccess);
  }
  if (errNominalPage === void 0) {
    assert(pageContextNominalPageSuccess);
    return pageContextNominalPageSuccess;
  } else {
    assert(errNominalPage);
    assert(pageContextNominalPageSuccess === void 0);
    return await renderPageOnError(errNominalPage, pageContextBegin, pageContextNominalPageBegin, globalContext, httpRequestId, pageContextsFromRewrite);
  }
}
async function renderPageOnError(errNominalPage, pageContextBegin, pageContextNominalPageBegin, globalContext, httpRequestId, pageContextsFromRewrite) {
  assert(pageContextNominalPageBegin);
  assert(hasProp(pageContextNominalPageBegin, "urlOriginal", "string"));
  const pageContextErrorPageInit = await getPageContextErrorPageInit(pageContextBegin, errNominalPage);
  if (isAbortError(errNominalPage)) {
    const handled = await handleAbortError(errNominalPage, pageContextsFromRewrite, pageContextBegin, pageContextNominalPageBegin, httpRequestId, pageContextErrorPageInit, globalContext);
    if (handled.pageContextReturn) {
      return handled.pageContextReturn;
    } else {
    }
    Object.assign(pageContextErrorPageInit, handled.pageContextAbort);
  }
  {
    const errorPageId = getErrorPageId(globalContext._pageFilesAll, globalContext._pageConfigs);
    if (!errorPageId) {
      objectAssign(pageContextErrorPageInit, { pageId: null });
      return handleErrorWithoutErrorPage(pageContextErrorPageInit);
    }
    objectAssign(pageContextErrorPageInit, { pageId: errorPageId });
  }
  let pageContextErrorPage;
  try {
    pageContextErrorPage = await renderPageAfterRoute(pageContextErrorPageInit);
  } catch (errErrorPage) {
    if (isAbortError(errErrorPage)) {
      const handled = await handleAbortError(errErrorPage, pageContextsFromRewrite, pageContextBegin, pageContextNominalPageBegin, httpRequestId, pageContextErrorPageInit, globalContext);
      if (!handled.pageContextReturn) {
        const pageContextAbort = errErrorPage._pageContextAbort;
        assertWarning2(false, `Failed to render error page because ${picocolors_default.cyan(pageContextAbort._abortCall)} was called: make sure ${picocolors_default.cyan(pageContextAbort._abortCaller)} doesn't occur while the error page is being rendered.`, { onlyOnce: false });
        const pageContextHttpWithError = getPageContextHttpResponseError(errNominalPage, pageContextBegin);
        return pageContextHttpWithError;
      }
      return handled.pageContextReturn;
    }
    if (isNewError(errErrorPage, errNominalPage)) {
      logRuntimeError(errErrorPage, httpRequestId);
    }
    const pageContextWithError = getPageContextHttpResponseError(errNominalPage, pageContextBegin);
    return pageContextWithError;
  }
  return pageContextErrorPage;
}
function logHttpRequest(urlOriginal, httpRequestId) {
  logRuntimeInfo?.(getRequestInfoMessage(urlOriginal), httpRequestId, "info");
}
function getRequestInfoMessage(urlOriginal) {
  return `HTTP request: ${prettyUrl(urlOriginal)}`;
}
function logHttpResponse(urlOriginalPretty, httpRequestId, pageContextReturn) {
  const statusCode = pageContextReturn.httpResponse?.statusCode ?? null;
  let msg;
  let isNominal;
  {
    const { errorWhileRendering } = pageContextReturn;
    const isSkipped = statusCode === null && !errorWhileRendering;
    if (isSkipped) {
      assert(errorWhileRendering === null || errorWhileRendering === void 0);
      msg = `HTTP response ${prettyUrl(urlOriginalPretty)} ${picocolors_default.dim("null")}`;
      isNominal = true;
    } else {
      const isSuccess = statusCode !== null && statusCode >= 200 && statusCode <= 399;
      isNominal = isSuccess || statusCode === 404;
      const color = /* @__PURE__ */ __name((s) => picocolors_default.bold(isSuccess ? picocolors_default.green(String(s)) : picocolors_default.red(String(s))), "color");
      const isRedirect = statusCode && 300 <= statusCode && statusCode <= 399;
      const type2 = isRedirect ? "redirect" : "response";
      if (isRedirect) {
        assert(pageContextReturn.httpResponse);
        const headerRedirect = pageContextReturn.httpResponse.headers.slice().reverse().find((header) => header[0] === "Location");
        assert(headerRedirect);
        const urlRedirect = headerRedirect[1];
        urlOriginalPretty = urlRedirect;
      }
      msg = `HTTP ${type2} ${prettyUrl(urlOriginalPretty)} ${color(statusCode ?? "ERR")}`;
    }
  }
  logRuntimeInfo?.(msg, httpRequestId, isNominal ? "info" : "error");
}
function prettyUrl(url) {
  try {
    url = decodeURI(url);
  } catch {
  }
  return picocolors_default.bold(url);
}
function getPageContextHttpResponseError(err, pageContextBegin) {
  const pageContextWithError = forkPageContext(pageContextBegin);
  const httpResponse = createHttpResponseError(pageContextBegin);
  objectAssign(pageContextWithError, {
    httpResponse,
    errorWhileRendering: err
  });
  return pageContextWithError;
}
function getPageContextHttpResponseErrorWithoutGlobalContext(err, pageContextInit) {
  const pageContextWithError = createPageContextServerSideWithoutGlobalContext(pageContextInit);
  const httpResponse = createHttpResponseErrorWithoutGlobalContext();
  objectAssign(pageContextWithError, {
    httpResponse,
    errorWhileRendering: err
  });
  return pageContextWithError;
}
async function renderPageNominal(pageContext) {
  objectAssign(pageContext, { errorWhileRendering: null });
  {
    const pageContextFromRoute = await route(pageContext);
    objectAssign(pageContext, pageContextFromRoute);
    objectAssign(pageContext, { is404: pageContext.pageId ? null : true });
    if (pageContext.pageId === null) {
      const errorPageId = getErrorPageId(pageContext._globalContext._pageFilesAll, pageContext._globalContext._pageConfigs);
      if (!errorPageId) {
        assert(hasProp(pageContext, "pageId", "null"));
        return handleErrorWithoutErrorPage(pageContext);
      }
      objectAssign(pageContext, { pageId: errorPageId });
    }
  }
  assert(hasProp(pageContext, "pageId", "string"));
  assert(pageContext.errorWhileRendering === null);
  const pageContextAfterRender = await renderPageAfterRoute(pageContext);
  assert(pageContext === pageContextAfterRender);
  return pageContextAfterRender;
}
async function getPageContextErrorPageInit(pageContextBegin, errNominalPage) {
  const pageContext = forkPageContext(pageContextBegin);
  assert(errNominalPage);
  objectAssign(pageContext, {
    is404: false,
    errorWhileRendering: errNominalPage,
    routeParams: {}
  });
  assert(pageContext.errorWhileRendering);
  return pageContext;
}
function getPageContextBegin(pageContextInit, globalContext, httpRequestId) {
  const { isClientSideNavigation, _urlHandler, _isPageContextJsonRequest } = handlePageContextUrl(pageContextInit.urlOriginal);
  const pageContextBegin = createPageContextServerSide(pageContextInit, globalContext, {
    isPrerendering: false,
    ssr: {
      urlHandler: _urlHandler,
      isClientSideNavigation
    }
  });
  objectAssign(pageContextBegin, { _httpRequestId: httpRequestId, _isPageContextJsonRequest });
  return pageContextBegin;
}
function handlePageContextUrl(urlOriginal) {
  const { isPageContextJsonRequest } = handlePageContextRequestUrl(urlOriginal);
  return {
    isClientSideNavigation: !!isPageContextJsonRequest,
    _isPageContextJsonRequest: isPageContextJsonRequest,
    _urlHandler: /* @__PURE__ */ __name((url) => handlePageContextRequestUrl(url).urlWithoutPageContextRequestSuffix, "_urlHandler")
  };
}
function getRequestId() {
  const httpRequestId = ++globalObject23.httpRequestsCount;
  assert(httpRequestId >= 1);
  return httpRequestId;
}
function assertIsUrl(urlOriginal) {
  assertUsage(isUrl(urlOriginal), `${picocolors_default.code("renderPage(pageContextInit)")} (https://vike.dev/renderPage) called with ${picocolors_default.code(`pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}`)} which isn't a valid URL.`);
}
function assertIsNotViteRequest(urlPathname, urlOriginal) {
  const isViteRequest = urlPathname.startsWith("/@vite/client") || urlPathname.startsWith("/@fs/") || urlPathname.startsWith("/__vite_ping");
  if (!isViteRequest)
    return;
  assertUsage(false, `${picocolors_default.code("renderPage(pageContextInit)")} called with ${picocolors_default.code(`pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}`)} which is unexpected because the URL ${picocolors_default.bold(urlOriginal)} should have already been handled by the development middleware: make sure the ${picocolors_default.cyan("createDevMiddleware()")} middleware is executed *before* the ${picocolors_default.cyan("renderPage()")} middleware, see ${picocolors_default.underline("https://vike.dev/renderPage")}`);
}
async function normalizeUrl(pageContextBegin, globalContext, httpRequestId) {
  const pageContext = forkPageContext(pageContextBegin);
  const { trailingSlash, disableUrlNormalization } = globalContext.config;
  if (disableUrlNormalization)
    return null;
  const { urlOriginal } = pageContext;
  const { isPageContextJsonRequest } = handlePageContextRequestUrl(urlOriginal);
  if (isPageContextJsonRequest)
    return null;
  const urlNormalized = normalizeUrlPathname(urlOriginal, trailingSlash ?? false, globalContext.baseServer);
  if (!urlNormalized)
    return null;
  logRuntimeInfo?.(`URL normalized from ${picocolors_default.cyan(urlOriginal)} to ${picocolors_default.cyan(urlNormalized)} (https://vike.dev/url-normalization)`, httpRequestId, "info");
  const httpResponse = createHttpResponseRedirect({ url: urlNormalized, statusCode: 301 }, pageContext);
  objectAssign(pageContext, { httpResponse });
  return pageContext;
}
async function getPermanentRedirect(pageContextBegin, globalContext, httpRequestId) {
  const pageContext = forkPageContext(pageContextBegin);
  const urlWithoutBase = removeBaseServer2(pageContext.urlOriginal, globalContext.baseServer);
  let origin = null;
  let urlTargetExternal = null;
  let urlTarget = modifyUrlPathname(urlWithoutBase, (urlPathname) => {
    const urlTarget2 = resolveRedirects(globalContext.config.redirects ?? [], urlPathname);
    if (urlTarget2 === null)
      return null;
    if (!isUrl(urlTarget2)) {
      assert(isUri(urlTarget2));
      urlTargetExternal = urlTarget2;
      return null;
    }
    const { urlModified, origin: origin_ } = removeUrlOrigin(urlTarget2);
    origin = origin_;
    return urlModified;
  });
  if (urlTargetExternal) {
    urlTarget = urlTargetExternal;
  } else {
    let originChanged = false;
    if (origin) {
      const urlModified = setUrlOrigin(urlTarget, origin);
      if (urlModified !== false) {
        originChanged = true;
        urlTarget = urlModified;
      }
    }
    if (normalize2(urlTarget) === normalize2(urlWithoutBase))
      return null;
    if (!originChanged)
      urlTarget = prependBase(urlTarget, globalContext.baseServer);
    assert(urlTarget !== pageContext.urlOriginal);
  }
  logRuntimeInfo?.(`Permanent redirection defined by config.redirects (https://vike.dev/redirects)`, httpRequestId, "info");
  const httpResponse = createHttpResponseRedirect({ url: urlTarget, statusCode: 301 }, pageContext);
  objectAssign(pageContext, { httpResponse });
  return pageContext;
}
function normalize2(url) {
  return url || "/";
}
async function handleAbortError(errAbort, pageContextsFromRewrite, pageContextBegin, pageContextNominalPageBegin, httpRequestId, pageContextErrorPageInit, globalContext) {
  logAbortErrorHandled(errAbort, globalContext._isProduction, pageContextNominalPageBegin);
  const pageContextAbort = errAbort._pageContextAbort;
  let pageContextSerialized;
  if (pageContextNominalPageBegin.isClientSideNavigation) {
    if (pageContextAbort.abortStatusCode) {
      const errorPageId = getErrorPageId(globalContext._pageFilesAll, globalContext._pageConfigs);
      const abortCall = pageContextAbort._abortCall;
      assert(abortCall);
      assertUsage(errorPageId, `You called ${picocolors_default.cyan(abortCall)} but you didn't define an error page, make sure to define one https://vike.dev/error-page`);
      const pageContext = forkPageContext(pageContextBegin);
      objectAssign(pageContext, { pageId: errorPageId });
      objectAssign(pageContext, pageContextAbort);
      objectAssign(pageContext, pageContextErrorPageInit, true);
      updateType(pageContext, await loadPageConfigsLazyServerSide(pageContext));
      pageContextSerialized = getPageContextClientSerialized(pageContext, false);
    } else {
      pageContextSerialized = getPageContextClientSerializedAbort(pageContextAbort, false);
    }
    const httpResponse = await createHttpResponsePageContextJson(pageContextSerialized);
    const pageContextReturn = { httpResponse };
    return { pageContextReturn };
  }
  if (pageContextAbort._urlRewrite) {
    const pageContextReturn = await renderPageAlreadyPrepared(pageContextBegin, globalContext, httpRequestId, [
      ...pageContextsFromRewrite,
      pageContextAbort
    ]);
    Object.assign(pageContextReturn, pageContextAbort);
    return { pageContextReturn };
  }
  if (pageContextAbort._urlRedirect) {
    const pageContextReturn = forkPageContext(pageContextBegin);
    objectAssign(pageContextReturn, pageContextAbort);
    const httpResponse = createHttpResponseRedirect(pageContextAbort._urlRedirect, pageContextBegin);
    objectAssign(pageContextReturn, { httpResponse });
    return { pageContextReturn };
  }
  assert(pageContextAbort.abortStatusCode);
  return { pageContextAbort };
}
async function checkBaseUrl(pageContextBegin, globalContext) {
  const pageContext = forkPageContext(pageContextBegin);
  const { baseServer: baseServer2 } = globalContext;
  const { urlOriginal } = pageContext;
  const { isBaseMissing } = parseUrl(urlOriginal, baseServer2);
  if (!isBaseMissing)
    return;
  const httpResponse = createHttpResponseBaseIsMissing(urlOriginal, baseServer2);
  objectAssign(pageContext, {
    httpResponse,
    isBaseMissing: true
  });
  checkType(pageContext);
  return pageContext;
}
function getPageContextSkipRequest(pageContextInit) {
  const urlPathnameWithBase = parseUrl(pageContextInit.urlOriginal, "/").pathname;
  assertIsNotViteRequest(urlPathnameWithBase, pageContextInit.urlOriginal);
  let errMsg404;
  if (urlPathnameWithBase.endsWith("/favicon.ico")) {
    errMsg404 = "No favicon.ico found";
  }
  if (urlPathnameWithBase.endsWith(".well-known/appspecific/com.chrome.devtools.json")) {
    errMsg404 = "Not supported";
  }
  if (!errMsg404)
    return;
  const pageContext = createPageContextServerSideWithoutGlobalContext(pageContextInit);
  const httpResponse = createHttpResponse404(errMsg404);
  objectAssign(pageContext, { httpResponse });
  checkType(pageContext);
  return pageContext;
}
function getPageContextInvalidVikeConfig(err, pageContextInit, httpRequestId) {
  logRuntimeInfo?.(picocolors_default.bold(picocolors_default.red("Error loading Vike config \u2014 see error above")), httpRequestId, "error");
  const pageContextWithError = getPageContextHttpResponseErrorWithoutGlobalContext(err, pageContextInit);
  return pageContextWithError;
}
function forkPageContext(pageContextBegin) {
  const pageContext = {};
  objectAssign(pageContext, pageContextBegin, true);
  return pageContext;
}
var globalObject23;
var init_renderPage = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/renderPage.js"() {
    init_renderPageAfterRoute();
    init_createPageContextServerSide();
    init_route();
    init_utils3();
    init_abort();
    init_globalContext2();
    init_handlePageContextRequestUrl();
    init_createHttpResponse();
    init_loggerRuntime();
    init_isNewError();
    init_assertArguments();
    init_log404();
    init_picocolors();
    init_serializeContext();
    init_error_page();
    init_handleErrorWithoutErrorPage();
    init_loadPageConfigsLazyServerSide();
    init_resolveRedirects();
    init_getVikeConfigError();
    globalObject23 = getGlobalObject("runtime/renderPage.ts", {
      httpRequestsCount: 0,
      asyncHookWrapper: getFallbackAsyncHookWrapper()
    });
    __name(renderPage, "renderPage");
    __name(getFallbackAsyncHookWrapper, "getFallbackAsyncHookWrapper");
    __name(renderPagePrepare, "renderPagePrepare");
    __name(renderPageAlreadyPrepared, "renderPageAlreadyPrepared");
    __name(renderPageOnError, "renderPageOnError");
    __name(logHttpRequest, "logHttpRequest");
    __name(getRequestInfoMessage, "getRequestInfoMessage");
    __name(logHttpResponse, "logHttpResponse");
    __name(prettyUrl, "prettyUrl");
    __name(getPageContextHttpResponseError, "getPageContextHttpResponseError");
    __name(getPageContextHttpResponseErrorWithoutGlobalContext, "getPageContextHttpResponseErrorWithoutGlobalContext");
    __name(renderPageNominal, "renderPageNominal");
    __name(getPageContextErrorPageInit, "getPageContextErrorPageInit");
    __name(getPageContextBegin, "getPageContextBegin");
    __name(handlePageContextUrl, "handlePageContextUrl");
    __name(getRequestId, "getRequestId");
    __name(assertIsUrl, "assertIsUrl");
    __name(assertIsNotViteRequest, "assertIsNotViteRequest");
    __name(normalizeUrl, "normalizeUrl");
    __name(getPermanentRedirect, "getPermanentRedirect");
    __name(normalize2, "normalize");
    __name(handleAbortError, "handleAbortError");
    __name(checkBaseUrl, "checkBaseUrl");
    __name(getPageContextSkipRequest, "getPageContextSkipRequest");
    __name(getPageContextInvalidVikeConfig, "getPageContextInvalidVikeConfig");
    __name(forkPageContext, "forkPageContext");
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime-dev/index.js
var init_runtime_dev = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime-dev/index.js"() {
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/types/index-dreprecated.js
var init_index_dreprecated = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/types/index-dreprecated.js"() {
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/injectAssets__public.js
var init_injectAssets_public = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/html/injectAssets/injectAssets__public.js"() {
    init_utils3();
    init_injectAssets();
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/createPageRenderer.js
var init_createPageRenderer = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/createPageRenderer.js"() {
    init_renderPage();
    init_utils3();
  }
});

// node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/index.js
var init_runtime2 = __esm({
  "node_modules/.pnpm/vike@0.4.238_react-streaming@0.4.3_react-dom@19.1.1_react@19.1.1__react@19.1.1__vite@7._9d96860c70530a0a33fc054a6963f5bb/node_modules/vike/dist/esm/node/runtime/index.js"() {
    init_isBrowser();
    init_assert();
    init_renderPage();
    init_renderHtml();
    init_stream();
    init_utils3();
    init_globalContext2();
    init_runtime_dev();
    init_index_dreprecated();
    init_injectAssets_public();
    init_createPageRenderer();
    init_utils3();
    init_picocolors();
    init_abort();
    assert(!isBrowser());
  }
});

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/compose.js
var compose = /* @__PURE__ */ __name((middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || void 0;
      }
      if (handler) {
        try {
          res = await handler(context, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
    __name(dispatch, "dispatch");
  };
}, "compose");

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT = Symbol();

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/utils/body.js
var parseBody = /* @__PURE__ */ __name(async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
}, "parseBody");
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
__name(parseFormData, "parseFormData");
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
__name(convertFormDataToBodyData, "convertFormDataToBodyData");
var handleParsingAllValues = /* @__PURE__ */ __name((form, key, value) => {
  if (form[key] !== void 0) {
    if (Array.isArray(form[key])) {
      ;
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
}, "handleParsingAllValues");
var handleParsingNestedValues = /* @__PURE__ */ __name((form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
}, "handleParsingNestedValues");

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/utils/url.js
var splitPath = /* @__PURE__ */ __name((path) => {
  const paths2 = path.split("/");
  if (paths2[0] === "") {
    paths2.shift();
  }
  return paths2;
}, "splitPath");
var splitRoutingPath = /* @__PURE__ */ __name((routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths2 = splitPath(path);
  return replaceGroupMarks(paths2, groups);
}, "splitRoutingPath");
var extractGroupsFromPath = /* @__PURE__ */ __name((path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
}, "extractGroupsFromPath");
var replaceGroupMarks = /* @__PURE__ */ __name((paths2, groups) => {
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths2.length - 1; j >= 0; j--) {
      if (paths2[j].includes(mark)) {
        paths2[j] = paths2[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths2;
}, "replaceGroupMarks");
var patternCache = {};
var getPattern = /* @__PURE__ */ __name((label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
}, "getPattern");
var tryDecode = /* @__PURE__ */ __name((str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match);
      } catch {
        return match;
      }
    });
  }
}, "tryDecode");
var tryDecodeURI = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURI), "tryDecodeURI");
var getPath = /* @__PURE__ */ __name((request) => {
  const url = request.url;
  const start = url.indexOf("/", url.indexOf(":") + 4);
  let i = start;
  for (; i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i);
}, "getPath");
var getPathNoStrict = /* @__PURE__ */ __name((request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
}, "getPathNoStrict");
var mergePath = /* @__PURE__ */ __name((base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
}, "mergePath");
var checkOptionalParameter = /* @__PURE__ */ __name((path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
}, "checkOptionalParameter");
var _decodeURI = /* @__PURE__ */ __name((value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
}, "_decodeURI");
var _getQueryParam = /* @__PURE__ */ __name((url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      ;
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
}, "_getQueryParam");
var getQueryParam = _getQueryParam;
var getQueryParams = /* @__PURE__ */ __name((url, key) => {
  return _getQueryParam(url, key, true);
}, "getQueryParams");
var decodeURIComponent_ = decodeURIComponent;

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/request.js
var tryDecodeURIComponent = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURIComponent_), "tryDecodeURIComponent");
var HonoRequest = class {
  static {
    __name(this, "HonoRequest");
  }
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param ? /\%/.test(param) ? tryDecodeURIComponent(param) : param : void 0;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = /* @__PURE__ */ __name((key) => {
    const { bodyCache, raw: raw2 } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw2[key]();
  }, "#cachedBody");
  json() {
    return this.#cachedBody("text").then((text) => JSON.parse(text));
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data4) {
    this.#validatedData[target] = data4;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route2]]) => route2);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route2]]) => route2)[this.routeIndex].path;
  }
};

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = /* @__PURE__ */ __name((value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
}, "raw");
var resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))
    ).then(() => buffer[0])
  );
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
}, "resolveCallback");

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = /* @__PURE__ */ __name((contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
}, "setDefaultContentType");
var Context = class {
  static {
    __name(this, "Context");
  }
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers()
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = /* @__PURE__ */ __name((...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  }, "render");
  setLayout = /* @__PURE__ */ __name((layout) => this.#layout = layout, "setLayout");
  getLayout = /* @__PURE__ */ __name(() => this.#layout, "getLayout");
  setRenderer = /* @__PURE__ */ __name((renderer) => {
    this.#renderer = renderer;
  }, "setRenderer");
  header = /* @__PURE__ */ __name((name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();
    if (value === void 0) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  }, "header");
  status = /* @__PURE__ */ __name((status2) => {
    this.#status = status2;
  }, "status");
  set = /* @__PURE__ */ __name((key, value) => {
    this.#var ??= /* @__PURE__ */ new Map();
    this.#var.set(key, value);
  }, "set");
  get = /* @__PURE__ */ __name((key) => {
    return this.#var ? this.#var.get(key) : void 0;
  }, "get");
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data4, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status2 = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data4, { status: status2, headers: responseHeaders });
  }
  newResponse = /* @__PURE__ */ __name((...args) => this.#newResponse(...args), "newResponse");
  body = /* @__PURE__ */ __name((data4, arg, headers) => this.#newResponse(data4, arg, headers), "body");
  text = /* @__PURE__ */ __name((text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(
      text,
      arg,
      setDefaultContentType(TEXT_PLAIN, headers)
    );
  }, "text");
  json = /* @__PURE__ */ __name((object, arg, headers) => {
    return this.#newResponse(
      JSON.stringify(object),
      arg,
      setDefaultContentType("application/json", headers)
    );
  }, "json");
  html = /* @__PURE__ */ __name((html, arg, headers) => {
    const res = /* @__PURE__ */ __name((html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers)), "res");
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  }, "html");
  redirect = /* @__PURE__ */ __name((location, status2) => {
    const locationString = String(location);
    this.header(
      "Location",
      !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString)
    );
    return this.newResponse(null, status2 ?? 302);
  }, "redirect");
  notFound = /* @__PURE__ */ __name(() => {
    this.#notFoundHandler ??= () => new Response();
    return this.#notFoundHandler(this);
  }, "notFound");
};

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
  static {
    __name(this, "UnsupportedPathError");
  }
};

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/hono-base.js
var notFoundHandler = /* @__PURE__ */ __name((c) => {
  return c.text("404 Not Found", 404);
}, "notFoundHandler");
var errorHandler = /* @__PURE__ */ __name((err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
}, "errorHandler");
var Hono = class {
  static {
    __name(this, "Hono");
  }
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p2 of [path].flat()) {
        this.#path = p2;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.errorHandler = this.errorHandler;
    clone.#notFoundHandler = this.#notFoundHandler;
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app2) {
    const subApp = this.basePath(path);
    app2.routes.map((r) => {
      let handler;
      if (app2.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = /* @__PURE__ */ __name(async (c, next) => (await compose([], app2.errorHandler)(c, () => r.handler(c, next))).res, "handler");
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = /* @__PURE__ */ __name((handler) => {
    this.errorHandler = handler;
    return this;
  }, "onError");
  notFound = /* @__PURE__ */ __name((handler) => {
    this.#notFoundHandler = handler;
    return this;
  }, "notFound");
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = /* @__PURE__ */ __name((request) => request, "replaceRequest");
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = void 0;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = /* @__PURE__ */ __name(async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    }, "handler");
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env2, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env2, "GET")))();
    }
    const path = this.getPath(request, { env: env2 });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env: env2,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))
      ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error(
            "Context is not finalized. Did you forget to return a Response object or `await next()`?"
          );
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = /* @__PURE__ */ __name((request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  }, "fetch");
  request = /* @__PURE__ */ __name((input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(
      new Request(
        /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`,
        requestInit
      ),
      Env,
      executionCtx
    );
  }, "request");
  fire = /* @__PURE__ */ __name(() => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));
    });
  }, "fire");
};

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
__name(compareKey, "compareKey");
var Node = class {
  static {
    __name(this, "Node");
  }
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node();
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node();
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  static {
    __name(this, "Trie");
  }
  #context = { varIndex: 0 };
  #root = new Node();
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== void 0) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== void 0) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(
    path === "*" ? "" : `^${path.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
__name(buildWildcardRegExp, "buildWildcardRegExp");
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
__name(clearWildcardRegExpCache, "clearWildcardRegExpCache");
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route2) => [!/\*|\/:/.test(route2[0]), ...route2]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e2) {
      throw e2 === PATH_ERROR ? new UnsupportedPathError(path) : e2;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length; k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
__name(buildMatcherFromPreprocessedRoutes, "buildMatcherFromPreprocessedRoutes");
function findMiddleware(middleware, path) {
  if (!middleware) {
    return void 0;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return void 0;
}
__name(findMiddleware, "findMiddleware");
var RegExpRouter = class {
  static {
    __name(this, "RegExpRouter");
  }
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      ;
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p2) => {
          handlerMap[method][p2] = [...handlerMap[METHOD_NAME_ALL][p2]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p2) => {
            re.test(p2) && middleware[m][p2].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach(
            (p2) => re.test(p2) && routes[m][p2].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths2 = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths2.length; i < len; i++) {
      const path2 = paths2[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.#buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  #buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = void 0;
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  static {
    __name(this, "SmartRouter");
  }
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init2) {
    this.#routers = init2.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (; i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e2) {
        if (e2 instanceof UnsupportedPathError) {
          continue;
        }
        throw e2;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = void 0;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  static {
    __name(this, "Node");
  }
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const p2 = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p2, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p2;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2();
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length; i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== void 0) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(
                ...this.#getHandlerSets(nextNode.#children["*"], method, node.#params)
              );
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key, name, matcher] = pattern;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(
                  ...this.#getHandlerSets(child.#children["*"], method, params, node.#params)
                );
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  static {
    __name(this, "TrieRouter");
  }
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length; i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  static {
    __name(this, "Hono");
  }
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/utils/color.js
function getColorEnabled() {
  const { process: process2, Deno } = globalThis;
  const isNoColor = typeof Deno?.noColor === "boolean" ? Deno.noColor : process2 !== void 0 ? "NO_COLOR" in process2?.env : false;
  return !isNoColor;
}
__name(getColorEnabled, "getColorEnabled");

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/utils/handler.js
var isMiddleware = /* @__PURE__ */ __name((handler) => handler.length > 1, "isMiddleware");
var findTargetHandler = /* @__PURE__ */ __name((handler) => {
  return handler[COMPOSED_HANDLER] ? findTargetHandler(handler[COMPOSED_HANDLER]) : handler;
}, "findTargetHandler");

// node_modules/.pnpm/hono@4.9.6/node_modules/hono/dist/helper/dev/index.js
var handlerName = /* @__PURE__ */ __name((handler) => {
  return handler.name || (isMiddleware(handler) ? "[middleware]" : "[handler]");
}, "handlerName");
var inspectRoutes = /* @__PURE__ */ __name((hono) => {
  return hono.routes.map(({ path, method, handler }) => {
    const targetHandler = findTargetHandler(handler);
    return {
      path,
      method,
      name: handlerName(targetHandler),
      isMiddleware: isMiddleware(targetHandler)
    };
  });
}, "inspectRoutes");
var showRoutes = /* @__PURE__ */ __name((hono, opts) => {
  const colorEnabled = opts?.colorize ?? getColorEnabled();
  const routeData = {};
  let maxMethodLength = 0;
  let maxPathLength = 0;
  inspectRoutes(hono).filter(({ isMiddleware: isMiddleware2 }) => opts?.verbose || !isMiddleware2).map((route2) => {
    const key = `${route2.method}-${route2.path}`;
    (routeData[key] ||= []).push(route2);
    if (routeData[key].length > 1) {
      return;
    }
    maxMethodLength = Math.max(maxMethodLength, route2.method.length);
    maxPathLength = Math.max(maxPathLength, route2.path.length);
    return { method: route2.method, path: route2.path, routes: routeData[key] };
  }).forEach((data4) => {
    if (!data4) {
      return;
    }
    const { method, path, routes } = data4;
    const methodStr = colorEnabled ? `\x1B[32m${method}\x1B[0m` : method;
    console.log(`${methodStr} ${" ".repeat(maxMethodLength - method.length)} ${path}`);
    if (!opts?.verbose) {
      return;
    }
    routes.forEach(({ name }) => {
      console.log(`${" ".repeat(maxMethodLength + 3)} ${name}`);
    });
  });
}, "showRoutes");

// serverless/vike-handler.ts
init_runtime2();
var vikeHandler = /* @__PURE__ */ __name(async (c) => {
  const pageContext = await renderPage({
    urlOriginal: c.req.url,
    headersOriginal: Object.fromEntries(c.req.raw.headers),
    // Передаем объект запроса, чтобы Vike мог получить к нему доступ
    request: c.req.raw
  });
  if (pageContext.httpResponse) {
    const { statusCode, body, contentType } = pageContext.httpResponse;
    c.status(statusCode);
    c.header("Content-Type", contentType);
    return c.body(body);
  }
  return c.text("Not Found", 404);
}, "vikeHandler");

// serverless/hono.ts
var app = new Hono2();
app.get("/api/hello", (c) => {
  return c.json({
    message: "Hello from Hono on Cloudflare Workers!",
    // Используем геоданные от Cloudflare
    location: {
      city: c.req.raw?.cf?.city || "Unknown",
      country: c.req.raw?.cf?.country || "Unknown",
      colo: c.req.raw?.cf?.colo || "Unknown"
    }
  });
});
app.post("/api/echo", async (c) => {
  const body = await c.req.json();
  return c.json({ echoed: body, timestamp: (/* @__PURE__ */ new Date()).toISOString() });
});
app.get("*", vikeHandler);
showRoutes(app);
var hono_default = app;

// serverless/worker.ts
var worker_default = {
  async fetch(request, env2, ctx) {
    return hono_default.fetch(request, env2, ctx);
  }
};

// ../../../../Library/pnpm/global/5/.pnpm/wrangler@4.35.0/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
var drainBody = /* @__PURE__ */ __name(async (request, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env2);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e2) {
      console.error("Failed to drain the unused request body.", e2);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// .wrangler/tmp/bundle-OLahSq/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default
];
var middleware_insertion_facade_default = worker_default;

// ../../../../Library/pnpm/global/5/.pnpm/wrangler@4.35.0/node_modules/wrangler/templates/middleware/common.ts
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env2, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env2, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env2, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env2, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-OLahSq/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env2, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env2, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env2, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type2, init2) {
        if (type2 === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init2.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env2, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env2, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request, env2, ctx) => {
      this.env = env2;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type2, init2) => {
      if (type2 === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init2.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! pages/index/HomePage.telefunc.ts [vike:pluginModuleBanner] */
/*! pages/old/data-fetching/@id/Page.telefunc.ts [vike:pluginModuleBanner] */
/*! pages/old/data-fetching/index/Page.telefunc.ts [vike:pluginModuleBanner] */
/*! pages/old/index/HomePage.telefunc.ts [vike:pluginModuleBanner] */
/*! /favicon.svg [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/react/renderer/+onRenderHtml.tsx [vike:pluginModuleBanner] */
/*! renderer/+onRenderHtml.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/platform/runsOnSide.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/platform/initial.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/platform/web/initial.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/Promise/_Promise-new.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/runtime.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/as.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/modules.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/__array.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/__makePlain.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/__observe.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/__reactivePropertyDescriptors.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/__local.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/_define.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/_loadDefines.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/_plain.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/_reaction.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/_save.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/_share.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/_types.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/async.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/define/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/.dev/defines/sky.examples.platform.web/index.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/mergeNamespace.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/globalify/_globalify.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/pkgs/react/_captureUI.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/pkgs/react/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/.dev/defines/sky/standard/index.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/Array/Array+last.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/Array/Array+remove.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/Array/Array+shuffle.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/Array/Array+toShuffled.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/bind/_bind.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/Console.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/Console/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/EventEmitter/_EventEmitter.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/EventEmitter/_EventEmitter-extend.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/EventEmitter/_EventEmitter+emit.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/EventEmitter/_EventEmitter+off.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/EventEmitter/_EventEmitter+on.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/EventEmitter/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/fetch/__local.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/fetch/_fetch-call.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/fetch/_fetch-json.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/fetch/_fetch-text.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/globalify/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/idle/_idle.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/idle/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/justTry/_justTry.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/justTry/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/Math/_minmax.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/Math/_random.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/measures/_defineMeasures.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/measures/KilometersPerHour.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/measures/Length.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/measures/MetersPerSecond.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/measures/Percents.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/measures/PercentsPerMillisecond.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/measures/PercentsPerSecond.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/measures/Time.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/measures/Weight.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/Object/Object+freezeDeep.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/assert.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/asyncCreate.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/canClone.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/disposable.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/events.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/hmr.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/hooks.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/mixin.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/not.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/repeat.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/Service.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/.dev/defines/sky/standard/switch_thread/index.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/switch_thread.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/transform.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/type-guards.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/type-guards.global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/standard/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/utilities/colors/_colors.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/utilities/Timer/_Timer.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/utilities/Timer/index.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/utilities/Timer/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/utilities/times/milliseconds/_milliseconds.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/utilities/times/milliseconds/index.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/utilities/times/milliseconds/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/helpers/cn/_cn.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/helpers/cn/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/features/effect/__signalOnDestroy.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/features/effect/__BaseOfEffect.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/features/effect/_Effect.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/math/__three/MathUtils.js [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/math/__three/Vector2.js [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/features/effect/_EffectsRoot.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/features/effect/_standard-effects.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/helpers/Loop/_Loop.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/helpers/Loop/global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/react/components/layout/Box.tsx [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/react/components/layout/Box.global.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/react/sx.tsx [vike:pluginModuleBanner] */
/*! pages/index/HomePage.module.scss [vike:pluginModuleBanner] */
/*! pages/index/HomePage.tsx [vike:pluginModuleBanner] */
/*! pages/index/+Page.tsx [vike:pluginModuleBanner] */
/*! pages/index/+data.ts [vike:pluginModuleBanner] */
/*! virtual:vike:page-entry:server:/pages/index [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/react/providers/PageContext.tsx [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/platform/web/renderer/usePageContext.tsx [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/platform/web/renderer/afterInitPage.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/platform/web/renderer/initPage.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/platform/web/helpers/data.ts [vike:pluginModuleBanner] */
/*! pages/old/_error/+Page.tsx [vike:pluginModuleBanner] */
/*! pages/old/_error/+data.ts [vike:pluginModuleBanner] */
/*! virtual:vike:page-entry:server:/pages/old/_error [vike:pluginModuleBanner] */
/*! pages/old/about/AboutPage.module.scss [vike:pluginModuleBanner] */
/*! pages/old/about/AboutPage.tsx [vike:pluginModuleBanner] */
/*! pages/old/about/+Page.tsx [vike:pluginModuleBanner] */
/*! pages/old/about/+data.tsx [vike:pluginModuleBanner] */
/*! virtual:vike:page-entry:server:/pages/old/about [vike:pluginModuleBanner] */
/*! pages/old/data-fetching/@id/+Page.tsx [vike:pluginModuleBanner] */
/*! pages/old/data-fetching/@id/+data.ts [vike:pluginModuleBanner] */
/*! virtual:vike:page-entry:server:/pages/old/data-fetching/@id [vike:pluginModuleBanner] */
/*! pages/old/data-fetching/index/+Page.tsx [vike:pluginModuleBanner] */
/*! pages/old/data-fetching/index/+data.ts [vike:pluginModuleBanner] */
/*! virtual:vike:page-entry:server:/pages/old/data-fetching/index [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/platform/web/renderer/queryClient.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/platform/web/renderer/useData.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/styles/helpers/layout/Container/_Container.scss [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/styles/helpers/layout/Container/_Container.tsx [vike:pluginModuleBanner] */
/*! pages/old/index/+data.ts [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/react/providers/StoreContext.tsx [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/platform/web/hooks/useStore.ts [vike:pluginModuleBanner] */
/*! stores/CounterStore.ts [vike:pluginModuleBanner] */
/*! pages/old/index/Counter.tsx [vike:pluginModuleBanner] */
/*! pages/old/index/HomePage.tsx [vike:pluginModuleBanner] */
/*! pages/old/index/+Page.tsx [vike:pluginModuleBanner] */
/*! virtual:vike:page-entry:server:/pages/old/index [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/node_modules/.pnpm/@tanstack+react-query@5.87.4_react@19.1.1/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/node_modules/.pnpm/@tanstack+react-query@5.87.4_react@19.1.1/node_modules/@tanstack/react-query/build/modern/IsRestoringProvider.js [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/node_modules/.pnpm/@tanstack+react-query@5.87.4_react@19.1.1/node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/node_modules/.pnpm/@tanstack+react-query@5.87.4_react@19.1.1/node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/node_modules/.pnpm/@tanstack+react-query@5.87.4_react@19.1.1/node_modules/@tanstack/react-query/build/modern/suspense.js [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/node_modules/.pnpm/@tanstack+react-query@5.87.4_react@19.1.1/node_modules/@tanstack/react-query/build/modern/useBaseQuery.js [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/node_modules/.pnpm/@tanstack+react-query@5.87.4_react@19.1.1/node_modules/@tanstack/react-query/build/modern/useQuery.js [vike:pluginModuleBanner] */
/*! pages/old/react-query/+data.ts [vike:pluginModuleBanner] */
/*! pages/old/react-query/+Page.tsx [vike:pluginModuleBanner] */
/*! virtual:vike:page-entry:server:/pages/old/react-query [vike:pluginModuleBanner] */
/*! virtual:telefunc:entry [vike:pluginModuleBanner] */
/*! /Users/a/Space/Projects/EmptySet/sky-modules/platform/web/renderer/+onBeforeRoute.ts [vike:pluginModuleBanner] */
/*! renderer/old/+onBeforeRoute.ts [vike:pluginModuleBanner] */
/*! virtual:vike:global-entry:server [vike:pluginModuleBanner] */
/*! virtual:@brillout/vite-plugin-server-entry:serverEntry [vike:pluginModuleBanner] */
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.edge.development.js:
  (**
   * @license React
   * react-dom-server.edge.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server-legacy.browser.development.js:
  (**
   * @license React
   * react-dom-server-legacy.browser.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=worker.js.map
